// ----------------------------------------------------------------------
// This file is automatically generated from the script:
//
// ./create_headers_from_register_map_h.pl
//
// and was applied to the file
//
// ./register_map.h
//
// DO NOT EDIT!!!!!
// ----------------------------------------------------------------------
//
#ifdef C_ARC_POINTER_H
#error xx
#else
#define C_ARC_POINTER_H
#define Wr(reg,val)  (*(reg))=val
#define Rd(reg)       (*(reg))
//
// Reading file:  ./register_map.h
//
// synopsys translate_off
// synopsys translate_on
//
// Reading file:  stb_define.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// CBUS_BASE:  STB_CBUS_BASE = 0x16
// -----------------------------------------------
// There are two instantiations under one CBUS slave.  Each CBUS slave can support
// 256 registers.  Each demux is allocated 128 registers so set the offset in
// the middle
// Copy this define but don't add a base address
#define SECOND_DEMUX_OFFSET_0  0x50
#define THIRD_DEMUX_OFFSET_0   0xa0
//========================================================================
//  STB TOP Registers				    (8'hf0 - 8'hf7)
//========================================================================
// bit 22 -- invert fec_error for S2P1
// bit 21 -- invert fec_data for S2P1
// bit 20 -- invert fec_sync for S2P1
// bit 19 -- invert fec_valid for S2P1
// bit 18 -- invert fec_clk for S2P1
// bit 17:16 -- fec_s_sel for S2P1  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
// Bit 15 -- enable_des_pl_clk
// Bit 14:13 -- reserved
// Bit 12:10 -- ts_out_select, 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File
// bit 9:8 -- des_i_sel 00 -- select_fec_0, 01 -- select_fec_1, 10 -- select_fec_2, 11 - reserved
// bit 7 -- enable_des_pl
// bit 6 -- invert fec_error for S2P0
// bit 5 -- invert fec_data for S2P0
// bit 4 -- invert fec_sync for S2P0
// bit 3 -- invert fec_valid for S2P0
// bit 2 -- invert fec_clk for S2P0
// bit 1:0 -- fec_s_sel for S2P0  00 - select TS0, 01 -- select TS1, 10 -- select TS2, 11 - reserved
#define P_STB_TOP_CONFIG                           (volatile unsigned long *)0xc1105bc0
// 15:8 -- TS_package_length_sub_1 (default : 187)
//  7:0 -- fec_sync_byte (default : 0x47)
#define P_TS_TOP_CONFIG                            (volatile unsigned long *)0xc1105bc4
// Bit 23:16 -- file_m2ts_skip_bytes
// Bit 15:8 -- des_out_dly
// Bit 7:6 -- transport_scrambling_control_odd // should be 3
// Bit 5 -- ts_hiu_enable
// Bit 4:0 -- fec_clk_div
#define P_TS_FILE_CONFIG                           (volatile unsigned long *)0xc1105bc8
// Bit 13:8 -- des ts pl state   -- Read Only
// Bit 3:0 PID index to 8 PID to get key-set
// auto increse after TS_PL_PID_DATA read/write
#define P_TS_PL_PID_INDEX                          (volatile unsigned long *)0xc1105bcc
// Bit 13 -- PID match disble
// Bit 12:0 -- PID
#define P_TS_PL_PID_DATA                           (volatile unsigned long *)0xc1105bd0
#define P_COMM_DESC_KEY0                           (volatile unsigned long *)0xc1105bd4
#define P_COMM_DESC_KEY1                           (volatile unsigned long *)0xc1105bd8
#define P_COMM_DESC_KEY_RW                         (volatile unsigned long *)0xc1105bdc
//
// NOTE:  Don't process the demux registers using the standard create_headers.... perl script.
//        Instead, since the demux has multiple instances (and many registers) use a separate
//        script to create a separate stb_define.h for C-code.  
//========================================================================
//  STB Registers				    (8'h00 - 8'h4f)
//
//========================================================================
// STB registers are 8'h0x
// Bit 15:0 -- version number : 0x0002  (v0.01)
// Bit 15 -- fec_core_select 1 - select descramble output
// Bit 14:12 -  fec_select 0-TS0, 1-TS1, 2-TS2, 3,4-Reserved, 5-S2P1, 6-S2P0, 7-File 
// Bit 11 -- FEC_CLK
// Bit 10 -- SOP
// Bit 9 -- D_VALID
// Bit 8 -- D_FAIL
// Bit 7:0 -- D_DATA 7:0
// bit 31 -- enable_free_clk_fec_data_valid
// bit 30 -- enable_free_clk_stb_reg
// bit 29:21 -- reserved
// bit 20 (bit 4) -- Bypass use recoder path
// bit 19 (bit 3) -- clear_PID_continuity_counter_valid
// bit 18 (bit 2) -- Disable Splicing
// bit 17 (bit 1) -- Insert PES_STRONG_SYNC in Audio PES
// bit 16 (bit 0) -- Insert PES_STRONG_SYNC in Video PES
// Bit 15 - do not trust section length
// Bit 14 - om cmd push even zero
// Bit 13 - reserved
// Bit 12 - SUB, OTHER PES interrupt at beginning of PES
// Bit 11 - discard_av_package -- for ts_recorder use only 
// Bit 10 - ts_recorder_select  0:after PID filter 1:before PID filter
// Bit 9 - ts_recorder_enable
// Bit 8 - (table_id == 0xff) means section_end
// Bit 7 - do not send uncomplete section
// Bit 6 - do not discard duplicate package
// Bit 5 - search SOP when trasport_error_indicator
// Bit 4 - stb demux enable
// Bit 3 - do not reset state machine on SOP
// Bit 2 - search SOP when error happened ( when ignore_fail_n_sop, will have this case)
// Bit 1 - do not use SOP input ( check FEC sync byte instead )
// Bit 0 - ignore fec_error bit when non sop ( check error on SOP only)
// bit 15:8 demux package length - 1 ( default : 187 )
// bit 7:0 default is 0x47
// bit 31:16 -- filter memory write data hi[31:16]
// bit 15:0 -- filter memory write data low [15:0]
// bit 31:24 -- advanced setting hi
// bit 23:16 -- advanced setting low
// bit 15 -- filter memory write data request
// bit 7:0 -- filter memory write addr
// bit 13:8 demux state  -- read only
// bit 7:4 -- maxnum section filter compare address
// bit 3:0 -- maxnum PID filter compare address
// bit 15 - transport_error_indicator
// bit 14 - payload_unit_start_indicator
// bit 13 - transport_priority
// bit 12:0 - PID
// bit 7:6 transport_scrambling_control
// bit 5:4 adaptation_field_control
// bit 3:0 continuity_counter
// bit 15:12 -- om_cmd_count (read only)
// bit  11:9 -- overflow_count // bit  11:9 -- om_cmd_wr_ptr (read only)
// bit   8:6 -- om_overwrite_count // bit   8:6 -- om_cmd_rd_ptr (read only)
// bit   5:3 -- type_stb_om_w_rd (read only)
// bit     2 -- unit_start_stb_om_w_rd (read only)
// bit     1 -- om_cmd_overflow (read only)
// bit     0 -- om_cmd_pending (read) 
// bit     0 -- om_cmd_read_finished (write)
// bit 15:9 // bit 14:8 -- count_stb_om_w_rd  (read only)
// bit 8:0  // bit  7:0 -- start_stb_om_wa_rd (read only)
// bit 11:0 -- offset for section data
// bit 31:16 -- base address for section buffer group 0 (*0x400 to get real address)
// bit 15:0 -- base address for section buffer group 1 (*0x400 to get real address)
// bit 31:16 -- ba2e address for section buffer group 2 (*0x400 to get real address)
// bit 15:0 -- base address for section buffer group 3 (*0x400 to get real address)
// bit 3:0 -- section buffer size for group 0 (bit used,  for example, 10 means 1K)
// bit 7:4 -- section buffer size for group 1
// bit 11:8 -- section buffer size for group 2
// bit 15:12 -- section buffer size for group 3
// section buffer busy status for buff 31:0 ( Read Only )
// section buffer write status for buff 31:0 -- Read
// clear buffer status ( buff READY and BUSY ) -- write
// bit 4:0 -- SEC_BUFFER_INDEX   RW
// bit 12:8 -- SEC_BUFFER_NUMBER for the INDEX buffer  Read_Only
// bit 14 -- output_section_buffer_valid
// bit 15 -- section_reset_busy (Read Only)
// bit 9:5 -- BYPASS PID number
// bit 4:0 -- PCR PID number
// bit 15:0 -- stream_id filter bit enable
// bit 7:0 -- stream_id filter target
// bit 12 -- PCR_EN
// bit 11:0 -- PCR90K_DIV
// bit 15:0 -- PCR[31:0] R/W
// bit 15:0 -- VPTS[31:0] R/W
// bit 15:0 -- VDTS[31:0] R/W
// bit 15:0 -- APTS[31:0] R/W
// bit 15:0 -- SPTS[31:0] R/W
// read -- status, write 1 clear status
// bit 15 -- SUB_PTS[32]
// bit 14 -- AUDIO_PTS[32]
// bit 13 -- VIDEO_DTS[32]
// bit 12 -- VIDEO_PTS[32]
// bit 3 -- sub_pts_ready
// bit 2 -- audio_pts_ready
// bit 1 -- video_dts_ready
// bit 0 -- video_pts_ready
// bit 3:0 --
//  0 -- adaptation_field_length[7:0], adaption_field_byte_1[7:0] 
//  1 -- stream_id[7:0], pes_header_bytes_left[7:0]
//  2 -- pes_package_bytes_left[15:0]
//  3 -- pes_ctr_byte[7:0], pes_flag_byte[7:0]
// 
// read only
// default : 0x807f
// bit 15:9  -- MAX OM DMA COUNT  (default: 0x40) 
// bit 8:0   -- LAST ADDR OF OM ADDR (default: 127)
// 15:0  WRITE 1 CLEAR to clear interrupt source
// 9 -- splicing_point
// 8 -- other_PES_int
// 7 -- sub_PES_int 
// 6 -- discontinuity
// 5 -- duplicated_pack_found
// 4 -- New PDTS ready
// 3 -- om_cmd_buffer ready for access
// 2 -- section buffer ready 
// 1 -- transport_error_indicator
// 0 -- TS ERROR PIN 
// Bit 5:3 - demux om write endian control for bypass
// Bit 2:0 - demux om write endian control for section
// When Bit 31 - 1 write will indicate all type use sepertate endian (Write Only)
// Bit 23:21 - demux om write endian control for OTHER_PES_PACKET
// Bit 20:18 - demux om write endian control for SCR_ONLY_PACKET
// Bit 17:15 - demux om write endian control for SUB_PACKET
// Bit 14:12 - demux om write endian control for AUDIO_PACKET
// Bit 11:9  - demux om write endian control for VIDEO_PACKET
// 
// When Bit 31 - 0 write will indicate all type else use Bit 8:6
// Bit 8:6 - demux om write endian control for else
// Bit 15:8 -- last_burst_threshold
// Bit 7 -- use hi_bsf interface
// Bit 6:2 - fec_clk_div
// Bit 1 ts_source_sel 
// Bit 0 - Hiu TS generate enable 
// bit 15:0 -- base address for section buffer start (*0x10000 to get real base)
// bit 11 -- mask bit for OTHER_PES_AHB_DMA_EN
// bit 10 -- mask bit for SUB_AHB_DMA_EN
// bit 9 -- mask bit for BYPASS_AHB_DMA_EN
// bit 8 -- mask bit for SECTION_AHB_DMA_EN
// bit 7 -- mask bit for recoder stream
// bit 6:0 -- mask bit for each type
// bit 31:0 -- vb_wr_ptr for video PDTS 
// bit 31:0 -- ab_wr_ptr for audio PDTS
// bit 20:0 -- SB_WRITE_PTR (sb_wr_ptr << 3 == byte write position)
// bit 19:0 -- SB_START (sb_start << 12 == byte address);  
// bit 20:0 -- SB_SIZE (sb_size << 3 == byte size, 16M maximun) 
// bit 31:0 -- sb_wr_ptr for sub PES
// bit 31:16 -- ob_wr_ptr for other PES
// bit 20:0 -- OB_WRITE_PTR (ob_wr_ptr << 3 == byte write position)
// bit 19:0 -- OB_START (ob_start << 12 == byte address);  
// bit 20:0 -- OB_SIZE (ob_size << 3 == byte size, 16M maximun) 
// bit 31:0 -- ob_wr_ptr for sub PES
// 15:0  DEMUX interrupt MASK
// 9 -- splicing_point
// 8 -- other_PES_int
// 7 -- sub_PES_int 
// 6 -- discontinuity
// 5 -- duplicated_pack_found
// 4 -- New PDTS ready
// 3 -- om_cmd_buffer ready for access
// 2 -- section buffer ready 
// 1 -- transport_error_indicator
// 0 -- TS ERROR PIN 
// 31:16 VIDEO PID filter data
//15 -- splicing VIDEO PID change enable 
//14:10 -- VIDEO PID FILTER ADDRESS
// 9 -- PES splicing active (Read Only) 
// 8 -- splicing active (Read Only)
// 7:0  splicing countdown (Read Only)
// 31:16 AUDIO PID filter data
//15 -- splicing AUDIO PID change enable 
//14:10 -- AUDIO PID FILTER ADDRESS
// 9 -- PES splicing active (Read Only) 
// 8 -- splicing active (Read Only)
// 7:0  splicing countdown (Read Only)
// 23:16 M2TS_SKIP_BYTES
// 15:8 LAST TS PACKAGE BYTE COUNT (Read Only)
// 7:0  PACKAGE BYTE COUNT (Read Only)
// 15:0 2 bytes strong sync add to PES
// bit 15 -- stb_om_ren
// bit 14:11 -- reserved
// bit  10:0 -- OM_DATA_RD_ADDR
// bit 15:0 -- OM_DATA_RD
// AUTO STOP SETTING for 32 channels
// 4-nbits per channel
// when write
// bit 3 -- set section active
// bit 2:0 -- auto stop after count (0 means never stop)
// when read
// bit 3 -- current active status (1 - active, 0 - stopped )
// bit 2:0 -- count down to auto stop
// section 31:24
// section 23:16
// section 15:8
// section 7:0
// bit 31:0 reset channel status - each bit reset each channel 
// read -- 32 channel status 
// bit 4 -- video_stamp_use_dts
// bit 3 -- audio_stamp_sync_1_en 
// bit 2 -- audio_stamp_insert_en 
// bit 1 -- video_stamp_sync_1_en 
// bit 0 -- video_stamp_insert_en 
// Write : Bit[4:0] secter filter number for reset
// Read  : select according to output_section_buffer_valid : 
//         per bit per section buffer valid status
//         or section_buffer_ignore
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  stb_define.h
//
//
// Reading file:  periphs_reg.h
//
// $periphs/rtl/periphs_core register defines for the 
// APB bus
// -------------------------------------------------------------------
// PSEL Group #0:  0x000 ~ 0xFF
// -------------------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS0_CBUS_BASE = 0x20
// -----------------------------------------------
// The following are handled by $periphs/rtl/periphs_reg.v
#define P_PREG_CTLREG0_ADDR                        (volatile unsigned long *)0xc1108000
// ----------------------------
// Dummy regs to keep XIF ports from being synthesized away
// ----------------------------
#define P_XIF_DUMMY_0                              (volatile unsigned long *)0xc1108004
#define P_XIF_DUMMY_1                              (volatile unsigned long *)0xc1108008
#define P_XIF_DUMMY_2                              (volatile unsigned long *)0xc110800c
#define P_XIF_DUMMY_3                              (volatile unsigned long *)0xc1108010
#define P_XIF_DUMMY_4                              (volatile unsigned long *)0xc1108014
// ----------------------------
#define P_PREG_JTAG_GPIO_ADDR                      (volatile unsigned long *)0xc110802c
// ----------------------------
// Pre-defined GPIO addresses
// ----------------------------
#define P_PREG_EGPIO_EN_N                          (volatile unsigned long *)0xc1108030
#define P_PREG_EGPIO_O                             (volatile unsigned long *)0xc1108034
#define P_PREG_EGPIO_I                             (volatile unsigned long *)0xc1108038
// ----------------------------
#define P_PREG_FGPIO_EN_N                          (volatile unsigned long *)0xc110803c
#define P_PREG_FGPIO_O                             (volatile unsigned long *)0xc1108040
#define P_PREG_FGPIO_I                             (volatile unsigned long *)0xc1108044
// ----------------------------
#define P_PREG_GGPIO_EN_N                          (volatile unsigned long *)0xc1108048
#define P_PREG_GGPIO_O                             (volatile unsigned long *)0xc110804c
#define P_PREG_GGPIO_I                             (volatile unsigned long *)0xc1108050
// ----------------------------
#define P_PREG_HGPIO_EN_N                          (volatile unsigned long *)0xc1108054
#define P_PREG_HGPIO_O                             (volatile unsigned long *)0xc1108058
#define P_PREG_HGPIO_I                             (volatile unsigned long *)0xc110805c
// ----------------------------
// unused `define PREG_IGPIO_EN_N                     8'h18
// unused `define PREG_IGPIO_O                        8'h19
// unused `define PREG_IGPIO_I                        8'h1a
// ----------------------------
// unused `define PREG_JGPIO_EN_N                     8'h1b
// unused `define PREG_JGPIO_O                        8'h1c
// unused `define PREG_JGPIO_I                        8'h1d
// ----------------------------
// A9 and L2 chche
// ----------------------------
#define P_A9_CFG0                                  (volatile unsigned long *)0xc1108080
#define P_A9_CFG1                                  (volatile unsigned long *)0xc1108084
#define P_A9_CFG2                                  (volatile unsigned long *)0xc1108088
#define P_A9_PERIPH_BASE                           (volatile unsigned long *)0xc110808c
#define P_A9_L2_REG_BASE                           (volatile unsigned long *)0xc1108090
#define P_A9_L2_STATUS                             (volatile unsigned long *)0xc1108094
#define P_A9_POR_CFG                               (volatile unsigned long *)0xc1108098
// ----------------------------
// Pin Mux  (9)
// ----------------------------
#define P_PERIPHS_PIN_MUX_0                        (volatile unsigned long *)0xc11080b0
#define P_PERIPHS_PIN_MUX_1                        (volatile unsigned long *)0xc11080b4
#define P_PERIPHS_PIN_MUX_2                        (volatile unsigned long *)0xc11080b8
#define P_PERIPHS_PIN_MUX_3                        (volatile unsigned long *)0xc11080bc
#define P_PERIPHS_PIN_MUX_4                        (volatile unsigned long *)0xc11080c0
#define P_PERIPHS_PIN_MUX_5                        (volatile unsigned long *)0xc11080c4
#define P_PERIPHS_PIN_MUX_6                        (volatile unsigned long *)0xc11080c8
#define P_PERIPHS_PIN_MUX_7                        (volatile unsigned long *)0xc11080cc
#define P_PERIPHS_PIN_MUX_8                        (volatile unsigned long *)0xc11080d0
#define P_PERIPHS_PIN_MUX_9                        (volatile unsigned long *)0xc11080d4
#define P_PERIPHS_PIN_MUX_10                       (volatile unsigned long *)0xc11080d8
#define P_PERIPHS_PIN_MUX_11                       (volatile unsigned long *)0xc11080dc
#define P_PERIPHS_PIN_MUX_12                       (volatile unsigned long *)0xc11080e0
// ----------------------------
// Pad conntrols
// ----------------------------
#define P_PAD_PULL_UP_REG0                         (volatile unsigned long *)0xc11080ec
#define P_PAD_PULL_UP_REG1                         (volatile unsigned long *)0xc11080f0
#define P_PAD_PULL_UP_REG2                         (volatile unsigned long *)0xc11080f4
#define P_PAD_PULL_UP_REG3                         (volatile unsigned long *)0xc11080f8
// ----------------------------
// Random (2)
// ----------------------------
#define P_RAND64_ADDR0                             (volatile unsigned long *)0xc1108100
#define P_RAND64_ADDR1                             (volatile unsigned long *)0xc1108104
// ---------------------------
// Ethernet (1)
// ----------------------------
#define P_PREG_ETHERNET_ADDR0                      (volatile unsigned long *)0xc1108108
// ---------------------------
// AM_ANALOG_TOP
// ----------------------------
#define P_PREG_AM_ANALOG_ADDR                      (volatile unsigned long *)0xc110810c
// ---------------------------
// Mali55 (1)
// ----------------------------
#define P_PREG_MALI_BYTE_CNTL                      (volatile unsigned long *)0xc1108110
// ---------------------------
// WIFI (1)
// ----------------------------
#define P_PREG_WIFI_CNTL                           (volatile unsigned long *)0xc1108114
// ---------------------------
// SATA 
// ----------------------------
#define P_PREG_SATA_REG0                           (volatile unsigned long *)0xc1108140
#define P_PREG_SATA_REG1                           (volatile unsigned long *)0xc1108144
#define P_PREG_SATA_REG2                           (volatile unsigned long *)0xc1108148
#define P_PREG_SATA_REG3                           (volatile unsigned long *)0xc110814c
#define P_PREG_SATA_REG4                           (volatile unsigned long *)0xc1108150
#define P_PREG_SATA_REG5                           (volatile unsigned long *)0xc1108154
// ---------------------------
// am_analog_top
// ----------------------------
#define P_AM_ANALOG_TOP_REG0                       (volatile unsigned long *)0xc11081b8
// ---------------------------
// Sticky regs
// ----------------------------
#define P_PREG_STICKY_REG0                         (volatile unsigned long *)0xc11081f0
#define P_PREG_STICKY_REG1                         (volatile unsigned long *)0xc11081f4
// ---------------------------
// AM Ring Oscillator 
// ----------------------------
#define P_AM_RING_OSC_REG0                         (volatile unsigned long *)0xc11081fc
// -------------------------------------------------------------------
// PSEL Group #1:  0x400 ~ 0x7FF
// -------------------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS1_CBUS_BASE = 0x21
// -----------------------------------------------
// ----------------------------
// $usb/rtl/usb_reg.v   (8)
// ----------------------------
#define P_USB_ADDR0                                (volatile unsigned long *)0xc1108400
#define P_USB_ADDR1                                (volatile unsigned long *)0xc1108404
#define P_USB_ADDR2                                (volatile unsigned long *)0xc1108408
#define P_USB_ADDR3                                (volatile unsigned long *)0xc110840c
#define P_USB_ADDR4                                (volatile unsigned long *)0xc1108410
#define P_USB_ADDR5                                (volatile unsigned long *)0xc1108414
#define P_USB_ADDR6                                (volatile unsigned long *)0xc1108418
// ----------------------------
// Smart Card (8)
// ----------------------------
#define P_SMARTCARD_REG0                           (volatile unsigned long *)0xc1108440
#define P_SMARTCARD_REG1                           (volatile unsigned long *)0xc1108444
#define P_SMARTCARD_REG2                           (volatile unsigned long *)0xc1108448
#define P_SMARTCARD_STATUS                         (volatile unsigned long *)0xc110844c
#define P_SMARTCARD_INTR                           (volatile unsigned long *)0xc1108450
#define P_SMARTCARD_REG5                           (volatile unsigned long *)0xc1108454
#define P_SMARTCARD_REG6                           (volatile unsigned long *)0xc1108458
#define P_SMARTCARD_FIFO                           (volatile unsigned long *)0xc110845c
// ----------------------------
// IR Remote (8)
// ----------------------------
#define P_IR_DEC_LDR_ACTIVE                        (volatile unsigned long *)0xc1108480
#define P_IR_DEC_LDR_IDLE                          (volatile unsigned long *)0xc1108484
#define P_IR_DEC_LDR_REPEAT                        (volatile unsigned long *)0xc1108488
#define P_IR_DEC_BIT_0                             (volatile unsigned long *)0xc110848c
#define P_IR_DEC_REG0                              (volatile unsigned long *)0xc1108490
#define P_IR_DEC_FRAME                             (volatile unsigned long *)0xc1108494
#define P_IR_DEC_STATUS                            (volatile unsigned long *)0xc1108498
#define P_IR_DEC_REG1                              (volatile unsigned long *)0xc110849c
// ----------------------------
// WIFI
// ----------------------------
#define P_WIFI_ADC_SAMPLING                        (volatile unsigned long *)0xc11084b8
#define P_WIFI_ADC_READBACK                        (volatile unsigned long *)0xc11084bc
// ----------------------------
// UART0
// ----------------------------
#define P_UART0_WFIFO                              (volatile unsigned long *)0xc11084c0
#define P_UART0_RFIFO                              (volatile unsigned long *)0xc11084c4
#define P_UART0_CONTROL                            (volatile unsigned long *)0xc11084c8
#define P_UART0_STATUS                             (volatile unsigned long *)0xc11084cc
#define P_UART0_MISC                               (volatile unsigned long *)0xc11084d0
// ----------------------------
// UART1
// ----------------------------
#define P_UART1_WFIFO                              (volatile unsigned long *)0xc11084dc
#define P_UART1_RFIFO                              (volatile unsigned long *)0xc11084e0
#define P_UART1_CONTROL                            (volatile unsigned long *)0xc11084e4
#define P_UART1_STATUS                             (volatile unsigned long *)0xc11084e8
#define P_UART1_MISC                               (volatile unsigned long *)0xc11084ec
// ----------------------------
// Dynamic pin sampling
// ----------------------------
#define P_DYNAMIC_PIN_SAMPLE_REG0                  (volatile unsigned long *)0xc11084f0
#define P_DYNAMIC_PIN_SAMPLE_REG1                  (volatile unsigned long *)0xc11084f4
// ----------------------------
// I2C Master (8)
// ----------------------------
#define P_I2C_M_0_CONTROL_REG                      (volatile unsigned long *)0xc1108500
    #define     I2C_M_MANUAL_SDA_I        26
    #define     I2C_M_MANUAL_SCL_I        25
    #define     I2C_M_MANUAL_SDA_O        24
    #define     I2C_M_MANUAL_SCL_O        23
    #define     I2C_M_MANUAL_EN           22
    #define     I2C_M_DELAY_MSB           21
    #define     I2C_M_DELAY_LSB           12
    #define     I2C_M_DATA_CNT_MSB        11
    #define     I2C_M_DATA_CNT_LSB        8
    #define     I2C_M_CURR_TOKEN_MSB      7
    #define     I2C_M_CURR_TOKEN_LSB      4
    #define     I2C_M_ERROR               3
    #define     I2C_M_STATUS              2
    #define     I2C_M_ACK_IGNORE          1
    #define     I2C_M_START               0
#define P_I2C_M_0_SLAVE_ADDR                       (volatile unsigned long *)0xc1108504
#define P_I2C_M_0_TOKEN_LIST0                      (volatile unsigned long *)0xc1108508
#define P_I2C_M_0_TOKEN_LIST1                      (volatile unsigned long *)0xc110850c
#define P_I2C_M_0_WDATA_REG0                       (volatile unsigned long *)0xc1108510
#define P_I2C_M_0_WDATA_REG1                       (volatile unsigned long *)0xc1108514
#define P_I2C_M_0_RDATA_REG0                       (volatile unsigned long *)0xc1108518
#define P_I2C_M_0_RDATA_REG1                       (volatile unsigned long *)0xc110851c
// ----------------------------
// I2C Master 
// ----------------------------
#define P_I2C_M_1_CONTROL_REG                      (volatile unsigned long *)0xc1108520
#define P_I2C_M_1_SLAVE_ADDR                       (volatile unsigned long *)0xc1108524
#define P_I2C_M_1_TOKEN_LIST0                      (volatile unsigned long *)0xc1108528
#define P_I2C_M_1_TOKEN_LIST1                      (volatile unsigned long *)0xc110852c
#define P_I2C_M_1_WDATA_REG0                       (volatile unsigned long *)0xc1108530
#define P_I2C_M_1_WDATA_REG1                       (volatile unsigned long *)0xc1108534
#define P_I2C_M_1_RDATA_REG0                       (volatile unsigned long *)0xc1108538
#define P_I2C_M_1_RDATA_REG1                       (volatile unsigned long *)0xc110853c
// ----------------------------
// I2C Slave (3)
// ----------------------------
#define P_I2C_S_CONTROL_REG                        (volatile unsigned long *)0xc1108540
#define P_I2C_S_SEND_REG                           (volatile unsigned long *)0xc1108544
#define P_I2C_S_RECV_REG                           (volatile unsigned long *)0xc1108548
#define P_I2C_S_CNTL1_REG                          (volatile unsigned long *)0xc110854c
// ----------------------------
// PWM / DS A/B
// ----------------------------
#define P_PWM_PWM_A                                (volatile unsigned long *)0xc1108550
#define P_PWM_PWM_B                                (volatile unsigned long *)0xc1108554
#define P_PWM_MISC_REG_AB                          (volatile unsigned long *)0xc1108558
#define P_PWM_DELTA_SIGMA_AB                       (volatile unsigned long *)0xc110855c
// ---------------------------
// EFUSE (4)
// ----------------------------
#define P_EFUSE_CNTL0                              (volatile unsigned long *)0xc1108560
#define P_EFUSE_CNTL1                              (volatile unsigned long *)0xc1108564
#define P_EFUSE_CNTL2                              (volatile unsigned long *)0xc1108568
#define P_EFUSE_CNTL3                              (volatile unsigned long *)0xc110856c
#define P_EFUSE_CNTL4                              (volatile unsigned long *)0xc1108570
// ---------------------------------------------
// Separate APB slave that shares the CBUS/APB
// register space of the static registers
// ---------------------------------------------
#define P_ATAPI_IDEREG0                            (volatile unsigned long *)0xc1108580
   #define IDE_UDMA_PIO_STATE         15
   #define IDE_BUSY                   14
   #define IDE_ERROR_BIT              13
   #define IDE_DMARQ_BIT              12
   #define IDE_IORDY_BIT              11
   #define IDE_IORDY_EN_BIT           10
   #define IDE_DIS_CSEL_BIT            9
   #define IDE_CSEL_BIT                8
   #define IDE_IRQ14                   2
   #define IDE_ATAPI_GPIO_EN           3
   #define IDE_DMARQ_FULL              1
   #define IDE_ENABLE                  0
#define P_ATAPI_IDEREG1                            (volatile unsigned long *)0xc1108584
#define P_ATAPI_IDEREG2                            (volatile unsigned long *)0xc1108588
    #define IDE_XFER_CNT_MSB_BIT      18
    #define IDE_XFER_CNT_LSB_BIT       0
#define P_ATAPI_CYCTIME                            (volatile unsigned long *)0xc110858c
#define P_ATAPI_IDETIME                            (volatile unsigned long *)0xc1108590
#define P_ATAPI_PIO_TIMING                         (volatile unsigned long *)0xc1108594
#define P_ATAPI_TABLE_ADD_REG                      (volatile unsigned long *)0xc1108598
#define P_ATAPI_IDEREG3                            (volatile unsigned long *)0xc110859c
#define P_ATAPI_UDMA_REG0                          (volatile unsigned long *)0xc11085a0
#define P_ATAPI_UDMA_REG1                          (volatile unsigned long *)0xc11085a4
// Room for registers here
#define P_TRANS_PWMA_REG0                          (volatile unsigned long *)0xc11085c0
#define P_TRANS_PWMA_REG1                          (volatile unsigned long *)0xc11085c4
#define P_TRANS_PWMA_MUX0                          (volatile unsigned long *)0xc11085c8
#define P_TRANS_PWMA_MUX1                          (volatile unsigned long *)0xc11085cc
#define P_TRANS_PWMA_MUX2                          (volatile unsigned long *)0xc11085d0
#define P_TRANS_PWMA_MUX3                          (volatile unsigned long *)0xc11085d4
#define P_TRANS_PWMA_MUX4                          (volatile unsigned long *)0xc11085d8
#define P_TRANS_PWMA_MUX5                          (volatile unsigned long *)0xc11085dc
#define P_TRANS_PWMB_REG0                          (volatile unsigned long *)0xc11085e0
#define P_TRANS_PWMB_REG1                          (volatile unsigned long *)0xc11085e4
#define P_TRANS_PWMB_MUX0                          (volatile unsigned long *)0xc11085e8
#define P_TRANS_PWMB_MUX1                          (volatile unsigned long *)0xc11085ec
#define P_TRANS_PWMB_MUX2                          (volatile unsigned long *)0xc11085f0
#define P_TRANS_PWMB_MUX3                          (volatile unsigned long *)0xc11085f4
#define P_TRANS_PWMB_MUX4                          (volatile unsigned long *)0xc11085f8
#define P_TRANS_PWMB_MUX5                          (volatile unsigned long *)0xc11085fc
// ----------------------------
// NAND (21)
// ----------------------------
#define P_NAND_CMD                                (volatile unsigned long *)0xc1108600
#define P_NAND_CFG                                (volatile unsigned long *)0xc1108604
#define P_NAND_DADR                               (volatile unsigned long *)0xc1108608
#define P_NAND_IADR                               (volatile unsigned long *)0xc110860c
#define P_NAND_BUF                                (volatile unsigned long *)0xc1108610
#define P_NAND_INFO                               (volatile unsigned long *)0xc1108614
#define P_NAND_DC                                 (volatile unsigned long *)0xc1108618
#define P_NAND_ADR                                (volatile unsigned long *)0xc110861c
#define P_NAND_DL                                 (volatile unsigned long *)0xc1108620
#define P_NAND_DH                                 (volatile unsigned long *)0xc1108624

// ----------------------------
// PWM / DS C/D
// ----------------------------
#define P_PWM_PWM_C                                (volatile unsigned long *)0xc1108650
#define P_PWM_PWM_D                                (volatile unsigned long *)0xc1108654
#define P_PWM_MISC_REG_CD                          (volatile unsigned long *)0xc1108658
#define P_PWM_DELTA_SIGMA_CD                       (volatile unsigned long *)0xc110865c
// ----------------------------
// SAR ADC (16)
// ----------------------------
#define P_SAR_ADC_REG0                             (volatile unsigned long *)0xc1108680
#define P_SAR_ADC_CHAN_LIST                        (volatile unsigned long *)0xc1108684
#define P_SAR_ADC_AVG_CNTL                         (volatile unsigned long *)0xc1108688
#define P_SAR_ADC_REG3                             (volatile unsigned long *)0xc110868c
#define P_SAR_ADC_DELAY                            (volatile unsigned long *)0xc1108690
#define P_SAR_ADC_LAST_RD                          (volatile unsigned long *)0xc1108694
#define P_SAR_ADC_FIFO_RD                          (volatile unsigned long *)0xc1108698
#define P_SAR_ADC_AUX_SW                           (volatile unsigned long *)0xc110869c
#define P_SAR_ADC_CHAN_10_SW                       (volatile unsigned long *)0xc11086a0
#define P_SAR_ADC_DETECT_IDLE_SW                   (volatile unsigned long *)0xc11086a4
#define P_SAR_ADC_DELTA_10                         (volatile unsigned long *)0xc11086a8
// ----------------------------
// CTouch (16)
// ----------------------------
#define P_CTOUCH_REG0                              (volatile unsigned long *)0xc11086c0
#define P_CTOUCH_REG1                              (volatile unsigned long *)0xc11086c4
#define P_CTOUCH_FIFO                              (volatile unsigned long *)0xc11086c8
#define P_CTOUCH_REG3                              (volatile unsigned long *)0xc11086cc
#define P_CTOUCH_INIT_CLK0                         (volatile unsigned long *)0xc11086d0
#define P_CTOUCH_INIT_CLK1                         (volatile unsigned long *)0xc11086d4
#define P_CTOUCH_REG6                              (volatile unsigned long *)0xc11086d8
#define P_CTOUCH_GND_SW_MASK                       (volatile unsigned long *)0xc11086dc
#define P_CTOUCH_MSR_TB_SEL                        (volatile unsigned long *)0xc11086e0
#define P_CTOUCH_CAP_THRESH0                       (volatile unsigned long *)0xc11086e4
#define P_CTOUCH_CAP_THRESH1                       (volatile unsigned long *)0xc11086e8
#define P_CTOUCH_CHAN_LIST0                        (volatile unsigned long *)0xc11086ec
#define P_CTOUCH_CHAN_LIST1                        (volatile unsigned long *)0xc11086f0
#define P_CTOUCH_MSR_TB0                           (volatile unsigned long *)0xc11086f4
#define P_CTOUCH_MSR_TB1                           (volatile unsigned long *)0xc11086f8
#define P_CTOUCH_REG15                             (volatile unsigned long *)0xc11086fc
// ---------------------------
// RTC (4)
// ---------------------------
#define P_RTC_ADDR0                                (volatile unsigned long *)0xc1108740
#define P_RTC_ADDR1                                (volatile unsigned long *)0xc1108744
#define P_RTC_ADDR2                                (volatile unsigned long *)0xc1108748
#define P_RTC_ADDR3                                (volatile unsigned long *)0xc110874c
#define P_RTC_ADDR4                                (volatile unsigned long *)0xc1108750
// ----------------------------
// clock measure (4)
// ----------------------------
#define P_MSR_CLK_REG0                             (volatile unsigned long *)0xc110875c
#define P_MSR_CLK_REG1                             (volatile unsigned long *)0xc1108760
#define P_MSR_CLK_REG2                             (volatile unsigned long *)0xc1108764
// ----------------------------
// LED PWM
// ----------------------------
#define P_LED_PWM_REG0                             (volatile unsigned long *)0xc1108768
#define P_LED_PWM_REG1                             (volatile unsigned long *)0xc110876c
#define P_LED_PWM_REG2                             (volatile unsigned long *)0xc1108770
#define P_LED_PWM_REG3                             (volatile unsigned long *)0xc1108774
#define P_LED_PWM_REG4                             (volatile unsigned long *)0xc1108778
// ----------------------------
// VGHL PWM
// ----------------------------
#define P_VGHL_PWM_REG0                            (volatile unsigned long *)0xc1108780
#define P_VGHL_PWM_REG1                            (volatile unsigned long *)0xc1108784
#define P_VGHL_PWM_REG2                            (volatile unsigned long *)0xc1108788
#define P_VGHL_PWM_REG3                            (volatile unsigned long *)0xc110878c
#define P_VGHL_PWM_REG4                            (volatile unsigned long *)0xc1108790
// -------------------------------------------------------------------
// PSEL Group #2:  0x800 ~ 0xbFF
// -------------------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS2_CBUS_BASE = 0x22
// -----------------------------------------------
// ----------------------------
// AUDIN (64)
// ----------------------------
#define P_AUDIN_SPDIF_MODE                         (volatile unsigned long *)0xc1108800
    #define SPDIF_EN        31
    #define SPDIF_IRQ_ITV   24              // 31 :24 do we need this?
    #define SPDIF_TIE_0     23
    #define SPDIF_BIT_ORDER 19
    #define SPDIF_CHNL_ORDER 18
    #define SPDIF_DATA_TYPE_SEL 17
    #define SPDIF_PATH_SEL      16
    #define SPDIF_XTDCLK_UPD_ITVL  13   //15:13
    #define SPDIF_CLKNUM_54U       0     //12:0 
#define P_AUDIN_SPDIF_FS_CLK_RLTN                  (volatile unsigned long *)0xc1108804
    #define SPDIF_CLKNUM_192K  24     //29:24 
    #define SPDIF_CLKNUM_96K   18     //23:18 
    #define SPDIF_CLKNUM_48K   12     //17:12 
    #define SPDIF_CLKNUM_44K   6     // 11:6
    #define SPDIF_CLKNUM_32K   0     // 5:0
#define P_AUDIN_SPDIF_CHNL_STS_A                   (volatile unsigned long *)0xc1108808
#define P_AUDIN_SPDIF_CHNL_STS_B                   (volatile unsigned long *)0xc110880c
#define P_AUDIN_SPDIF_MISC                         (volatile unsigned long *)0xc1108810
#define P_AUDIN_SPDIF_NPCM_PCPD                    (volatile unsigned long *)0xc1108814
#define P_AUDIN_SPDIF_END                          (volatile unsigned long *)0xc110883c
#define P_AUDIN_I2SIN_CTRL                         (volatile unsigned long *)0xc1108840
    #define I2SIN_DIR       0    // I2S CLK and LRCLK direction. 0 : input 1 : output.
    #define I2SIN_CLK_SEL    1    // I2S clk selection : 0 : from pad input. 1 : from AIU.
    #define I2SIN_LRCLK_SEL 2
    #define I2SIN_POS_SYNC  3
    #define I2SIN_LRCLK_SKEW 4    // 6:4
    #define I2SIN_LRCLK_INVT 7
    #define I2SIN_SIZE       8    //9:8 : 0 16 bit. 1 : 18 bits 2 : 20 bits 3 : 24bits.
    #define I2SIN_CHAN_EN   10    //13:10. 
    #define I2SIN_EN        15
#define P_AUDIN_I2S_END                            (volatile unsigned long *)0xc110887c
#define P_AUDIN_FIFO0_START                        (volatile unsigned long *)0xc1108880
#define P_AUDIN_FIFO0_END                          (volatile unsigned long *)0xc1108884
#define P_AUDIN_FIFO0_PTR                          (volatile unsigned long *)0xc1108888
#define P_AUDIN_FIFO0_INTR                         (volatile unsigned long *)0xc110888c
#define P_AUDIN_FIFO0_RDPTR                        (volatile unsigned long *)0xc1108890
#define P_AUDIN_FIFO0_CTRL                         (volatile unsigned long *)0xc1108894
    #define AUDIN_FIFO0_EN       0
    #define AUDIN_FIFO0_RST      1
    #define AUDIN_FIFO0_LOAD     2 
    #define AUDIN_FIFO0_DIN_SEL  3
            // 0     spdifIN
            // 1     i2Sin
            // 2     delsigIN
            // 3     HDMI in
            // 4     DEMODULATOR IN
    #define AUDIN_FIFO0_D32b     6
    #define AUDIN_FIFO0_h24b     7
    #define AUDIN_FIFO0_ENDIAN   8
    #define AUDIN_FIFO0_CHAN     11
    #define AUDIN_FIFO0_UG       15
    #define AUDIN_FIFO0_DEST     16 
               // 0    DDR SDRAM
               // 1    PARSER.
    #define AUDIN_FIFO0_OV_MASK  17 
    #define AUDIN_FIFO0_INT_MASK 18 
    #define AUDIN_FIFO0_HOLD0_EN  19
    #define AUDIN_FIFO0_HOLD1_EN  20
    #define AUDIN_FIFO0_HOLD2_EN  21
    #define AUDIN_FIFO0_HOLD0_SEL 22   // 23:22
    #define AUDIN_FIFO0_HOLD1_SEL 24   // 25:24
    #define AUDIN_FIFO0_HOLD2_SEL 26   // 27:26
    #define AUDIN_FIFO0_HOLD_LVL  28   // 27:26
#define P_AUDIN_FIFO0_LVL0                         (volatile unsigned long *)0xc1108898
#define P_AUDIN_FIFO0_LVL1                         (volatile unsigned long *)0xc110889c
#define P_AUDIN_FIFO0_LVL2                         (volatile unsigned long *)0xc11088a0
#define P_AUDIN_FIFO1_START                        (volatile unsigned long *)0xc11088a4
#define P_AUDIN_FIFO1_END                          (volatile unsigned long *)0xc11088a8
#define P_AUDIN_FIFO1_PTR                          (volatile unsigned long *)0xc11088ac
#define P_AUDIN_FIFO1_INTR                         (volatile unsigned long *)0xc11088b0
#define P_AUDIN_FIFO1_RDPTR                        (volatile unsigned long *)0xc11088b4
#define P_AUDIN_FIFO1_CTRL                         (volatile unsigned long *)0xc11088b8
    #define AUDIN_FIFO1_EN       0
    #define AUDIN_FIFO1_RST      1
    #define AUDIN_FIFO1_LOAD     2 
    #define AUDIN_FIFO1_DIN_SEL  3
    #define AUDIN_FIFO1_D32b     6
    #define AUDIN_FIFO1_h24b     7
    #define AUDIN_FIFO1_ENDIAN   8
    #define AUDIN_FIFO1_CHAN     11
    #define AUDIN_FIFO1_UG       15
    #define AUDIN_FIFO1_DEST     16 
    #define AUDIN_FIFO1_OV_MASK  17 
    #define AUDIN_FIFO1_INT_MASK 18 
#define P_AUDIN_FIFO1_LVL0                         (volatile unsigned long *)0xc11088bc
#define P_AUDIN_FIFO1_LVL1                         (volatile unsigned long *)0xc11088c0
#define P_AUDIN_FIFO1_LVL2                         (volatile unsigned long *)0xc11088c4
#define P_AUDIN_FIFO0_REQID                        (volatile unsigned long *)0xc11088cc
#define P_AUDIN_FIFO1_REQID                        (volatile unsigned long *)0xc11088d0
#define P_AUDIN_FIFO_INT                           (volatile unsigned long *)0xc11088c8
#define P_AUDIN_ADDR_END                           (volatile unsigned long *)0xc11088fc
// ----------------------------
// BT656 (32)
// ----------------------------
#define P_BT_CTRL                                  (volatile unsigned long *)0xc1108900
    #define BT_SOFT_RESET           31      // Soft reset
    #define BT_JPEG_START           30  
    #define BT_JPEG_IGNORE_BYTES    18     //20:18
    #define BT_JPEG_IGNORE_LAST     17
    #define BT_UPDATE_ST_SEL        16 
    #define BT_COLOR_REPEAT         15
    #define BT_VIDEO_MODE           13     // 14:13
    #define BT_AUTO_FMT             12   
    #define BT_PROG_MODE            11
    #define BT_JPEG_MODE            10
    #define BT_XCLK27_EN_BIT        9      // 1 : xclk27 is input.     0 : xclk27 is output.
    #define BT_FID_EN_BIT           8       // 1 : enable use FID port.
    #define BT_CLK27_SEL_BIT        7       // 1 : external xclk27      0 : internal clk27.
    #define BT_CLK27_PHASE_BIT      6       // 1 : no inverted          0 : inverted.
    #define BT_ACE_MODE_BIT         5       // 1 : auto cover error by hardware.
    #define BT_SLICE_MODE_BIT       4       // 1 : no ancillay flag     0 : with ancillay flag.
    #define BT_FMT_MODE_BIT         3       // 1 : ntsc                 0 : pal.
    #define BT_REF_MODE_BIT         2       // 1 : from bit stream.     0 : from ports.
    #define BT_MODE_BIT             1       // 1 : BT656 model          0 : SAA7118 mode.
    #define BT_EN_BIT               0       // 1 : enable.
#define P_BT_VBISTART                              (volatile unsigned long *)0xc1108904
#define P_BT_VBIEND                                (volatile unsigned long *)0xc1108908
#define P_BT_FIELDSADR                             (volatile unsigned long *)0xc110890c
#define P_BT_LINECTRL                              (volatile unsigned long *)0xc1108910
#define P_BT_VIDEOSTART                            (volatile unsigned long *)0xc1108914
#define P_BT_VIDEOEND                              (volatile unsigned long *)0xc1108918
#define P_BT_SLICELINE0                            (volatile unsigned long *)0xc110891c
#define P_BT_SLICELINE1                            (volatile unsigned long *)0xc1108920
#define P_BT_PORT_CTRL                             (volatile unsigned long *)0xc1108924
  #define BT_HSYNC_PHASE      0
  #define BT_VSYNC_PHASE      1
  #define BT_HSYNC_PULSE      2
  #define BT_VSYNC_PULSE      3
  #define BT_FID_PHASE        4
  #define BT_FID_HSVS         5
  #define BT_IDQ_EN           6
  #define BT_IDQ_PHASE        7
  #define BT_D8B              8
  #define BT_10BTO8B          9
  #define BT_FID_DELAY       10    //12:10
  #define BT_VSYNC_DELAY     13    //
  #define BT_HSYNC_DELAY     16
#define P_BT_SWAP_CTRL                             (volatile unsigned long *)0xc1108928
#define P_BT_ANCISADR                              (volatile unsigned long *)0xc110892c
#define P_BT_ANCIEADR                              (volatile unsigned long *)0xc1108930
#define P_BT_AFIFO_CTRL                            (volatile unsigned long *)0xc1108934
#define P_BT_601_CTRL0                             (volatile unsigned long *)0xc1108938
#define P_BT_601_CTRL1                             (volatile unsigned long *)0xc110893c
#define P_BT_601_CTRL2                             (volatile unsigned long *)0xc1108940
#define P_BT_601_CTRL3                             (volatile unsigned long *)0xc1108944
#define P_BT_FIELD_LUMA                            (volatile unsigned long *)0xc1108948
#define P_BT_RAW_CTRL                              (volatile unsigned long *)0xc110894c
#define P_BT_STATUS                                (volatile unsigned long *)0xc1108950
#define P_BT_INT_CTRL                              (volatile unsigned long *)0xc1108954
#define P_BT_ANCI_STATUS                           (volatile unsigned long *)0xc1108958
#define P_BT_VLINE_STATUS                          (volatile unsigned long *)0xc110895c
#define P_BT_AFIFO_PTR                             (volatile unsigned long *)0xc1108960
#define P_BT_JPEGBYTENUM                           (volatile unsigned long *)0xc1108964
#define P_BT_ERR_CNT                               (volatile unsigned long *)0xc1108968
#define P_BT_JPEG_STATUS0                          (volatile unsigned long *)0xc110896c
#define P_BT_JPEG_STATUS1                          (volatile unsigned long *)0xc1108970
#define P_BT656_ADDR_END                           (volatile unsigned long *)0xc110897c
// ----------------------------
// BLKMV (9)
// ----------------------------
#define P_NDMA_CNTL_REG0                           (volatile unsigned long *)0xc11089c0
    #define NDMA_STATUS                 26
    #define NDMA_PERIODIC_INT_DLY_MSB   25
    #define NDMA_PERIODIC_INT_DLY_LSB   16
    #define NDMA_PERIODIC_INT_EN        15
    #define NDMA_ENABLE                 14
    #define NDMA_AHB_DELAY_MSB          13
    #define NDMA_AHB_DELAY_LSB          0
#define P_NDMA_TABLE_ADD_REG                       (volatile unsigned long *)0xc11089c8
#define P_NDMA_TDES_KEY_LO                         (volatile unsigned long *)0xc11089cc
#define P_NDMA_TDES_KEY_HI                         (volatile unsigned long *)0xc11089d0
#define P_NDMA_TDES_CONTROL                        (volatile unsigned long *)0xc11089d4
#define P_NDMA_AES_CONTROL                         (volatile unsigned long *)0xc11089d8
#define P_NDMA_AES_RK_FIFO                         (volatile unsigned long *)0xc11089dc
#define P_NDMA_CRC_OUT                             (volatile unsigned long *)0xc11089e0
#define P_NDMA_THREAD_REG                          (volatile unsigned long *)0xc11089e4
#define P_NDMA_THREAD_TABLE_START0                 (volatile unsigned long *)0xc1108a00
#define P_NDMA_THREAD_TABLE_CURR0                  (volatile unsigned long *)0xc1108a04
#define P_NDMA_THREAD_TABLE_END0                   (volatile unsigned long *)0xc1108a08
#define P_NDMA_THREAD_TABLE_START1                 (volatile unsigned long *)0xc1108a0c
#define P_NDMA_THREAD_TABLE_CURR1                  (volatile unsigned long *)0xc1108a10
#define P_NDMA_THREAD_TABLE_END1                   (volatile unsigned long *)0xc1108a14
#define P_NDMA_THREAD_TABLE_START2                 (volatile unsigned long *)0xc1108a18
#define P_NDMA_THREAD_TABLE_CURR2                  (volatile unsigned long *)0xc1108a1c
#define P_NDMA_THREAD_TABLE_END2                   (volatile unsigned long *)0xc1108a20
#define P_NDMA_THREAD_TABLE_START3                 (volatile unsigned long *)0xc1108a24
#define P_NDMA_THREAD_TABLE_CURR3                  (volatile unsigned long *)0xc1108a28
#define P_NDMA_THREAD_TABLE_END3                   (volatile unsigned long *)0xc1108a2c
#define P_NDMA_CNTL_REG1                           (volatile unsigned long *)0xc1108a30
// -------------------------------------------------------------------
// PSEL Group #3:  0xc00 ~ 0xFFF
// -------------------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS3_CBUS_BASE = 0x23
// -----------------------------------------------
// ---------------------------
// STREAM (8)
// ---------------------------
// bit 31:24 -- event_length
// bit 23:22 -- bus_1st_sel_1  //00-gpio, 01-reserved, 10-addr, 11-data 
// bit 21:20 -- bus_2nd_sel_1
// bit 19:18 -- bus_1st_sel_0
// bit 17:16 -- bus_2nd_sel_0
// bit 15:0 -- set output value (output 1 will read according to external input) 
#define P_STREAM_EVENT_INFO                        (volatile unsigned long *)0xc1108c00
// bit 31    -- force_parity_1
// bit 30    -- LSB_first
// bit 31:20 -- reserved
// bit 19:16 -- toggle point index
// bit 15:8  -- output togle point1
// bit 7:0   -- output togle point0 (0xff means input) 
#define P_STREAM_OUTPUT_CONFIG                     (volatile unsigned long *)0xc1108c04
// bit 31:24 -- clock_divide_ext
// bit 23:20 -- s_bus_start ( sclk, sdataout, sdatain)  // 0 means no s_bus used
// bit 19    -- no_sclk_on_pin // will use internal write clock and read clock (like RS232) 
// bit 18    -- invert_sclk_in
// bit 17    -- sdata_send_busy  // indicate one data is sending -- read only
// bit 16    -- one_sdata_received // set when one sdata is received, can write 0 to clear 
// bit 15    -- sdata_parity  // (write -- 0-even, 1-odd) (read -- received parity check)
// bit 14    -- sdata_send_type  // 0 -- 8 bits  1 -- 32 bits ( for fujitsu only )
// bit 13    -- sdata_receive_type // 0 -- 8 bits only  1 -- 8/32 bits 
// bit 12    -- invert_request_out
// bit 11:8  -- request_out_sel  // 0 means disable output
// bit 7:0   --  stop_request_count 
#define P_C_D_BUS_CONTROL                          (volatile unsigned long *)0xc1108c08
// bit 31:0  -- serial data (write: output one data, read: input data)
#define P_C_DATA                                   (volatile unsigned long *)0xc1108c0c
// bit 31:28 bus_width_1
// bit 27:24 bus_start_pin_1
// bit 23:16 bus_sel_chang_point_1 
// bit 15:12 bus_width_0
// bit 11:08 bus_start_pin_0
// bit 07:00 bus_sel_chang_point_0 
#define P_STREAM_BUS_CONFIG                        (volatile unsigned long *)0xc1108c10
// bit 31:24 clock_divide
// bit 23:20 clock_output_sel  -- 0 means disable clock output
// bit 19 -- inc_event_addr
// bit 18 -- async_fifo_endian
// bit 17 -- send_to_async_fifo
// bit 16 -- data_in_serial_lsb
// bit 15 -- invert_no_wait_condition_0
// bit 14 -- invert_no_wait_condition_1
// bit 13 -- invert_no_wait_condition_2
// bit 12 -- invert_data_bus
// bit 11 -- invert_clock_in
// bit 10 -- event_wait_clk_en
// bit 9 -- data_in_serial
// bit 8 -- invert_data_in_clk 
// bit 7:4  -- data_in_begin
// bit 3:0  -- data_in_clk_sel
#define P_STREAM_DATA_IN_CONFIG                    (volatile unsigned long *)0xc1108c14
// wait condition and irq should not be connected to 0, 0 means disable)
// bit 31:28 -- no_wait_condition_0   (0 means disable this condition)
// bit 27:24 -- no_wait_condition_1   (0 means disable this condition)
// bit 23:20 -- no_wait_condition_2   (0 means disable this condition)
// bit 19:16 -- irq_input_sel         (0 means disable this interrupt)
// bit 15:13 -- interrupt_status (read) clear status (write) (ext 0, ext 1, transfer end)
// bit 12 -- enable_sdata_irq
// bit 11 -- invert_irq_0
// bit 10 -- invert_irq_1
// bit  9 -- enable_transfer_end_irq
// bit  8 -- enable_second_ext_irq
// bit 7:0 -- no_wait_condition_check_point (0xff means no check)
#define P_STREAM_WAIT_IRQ_CONFIG                   (volatile unsigned long *)0xc1108c18
// bit 31:24 -- event address
// bit 23:16 -- event data
// bit 15:1 -- event repeat times  (0 means one time event)
// bit 0  -- Start Event (write) event_busy (read)
#define P_STREAM_EVENT_CTL                         (volatile unsigned long *)0xc1108c1c
// ---------------------------
// SDIO (8)
// ---------------------------
// `define C_SDIO_HIGH16                   8'h00 
// bit 31:0 -- cmd_argument/MS_SHORT_DATA_WRITE
#define P_CMD_ARGUMENT                             (volatile unsigned long *)0xc1108c20
// bit 31:24 -- repeat_package_times/MS_SHORT_DATA_WRITE_NUMBER
// bit 21   -- use_int_window
// bit 20   -- cmd_send_data/MS_HAVE_LONG_DATA_WRITE
// bit 19   -- check_busy_on_dat0 (used for R1b response)
// bit 18   -- response_crc7_from_8
// bit 17   -- response_have_data/MS_HAVE_LONG_DATA_READ
// bit 16   -- response_do_not_have_crc7/MS_SHORT_DATA_DO_NOT_HAVE_CRC16
// bit 15:8 -- cmd_response_bits (00 means no response) /MS_SHORT_DATA_READ_NUMBER
// bit 7:0 -- cmd_command/MS_TPC
#define P_CMD_SEND                                 (volatile unsigned long *)0xc1108c24
// bit 31:29 -- sdio_write_CRC_ok_status
// bit 28:23 -- sdio_write_Nwr
// bit 22:21 -- m_endian
// bit 20    -- bus_width
// bit 19    -- data_latch_at_negedge (normally at posedge)
// bit 18    -- do_not_delay_data (normally delay one clock)
// bit 17:12 -- cmd_argument_bits (before CRC, normally : 39) 
// bit 11 -- cmd_out_at_posedge (normally at negedge)
// bit 10 -- cmd_disable_CRC
// bit 9:0 -- cmd_clk_divide
#define P_SDIO_CONFIG                              (volatile unsigned long *)0xc1108c28
// bit 31:19 -- sdio_timing_out_count
// bit 18 -- arc_timing_out_int_en
// bit 17 -- amrisc_timing_out_int_en
// bit 16 -- sdio_timig_out_int   -- write 1 clear this int bit
// bit 15:12 -- sdio_status_info  -- used for change infor between ARC and Amrisc
// bit 11 -- sdio_set_soft_int -- write 1 to this bit will set sdio_soft_int , read out is m_req_sdio
// bit 10 -- sdio_soft_int   -- write 1 clear this int bit
// bit 9 -- sdio_cmd_int   -- write 1 clear this int bit
// bit 8 -- sdio_if_int   -- write 1 clear this int bit
// bit 7 -- sdio_data_write_crc16_ok -- Read-Only
// bit 6 -- sdio_data_read_crc16_ok  -- Read-Only
// bit 5 -- sdio_response_crc7_ok    -- Read-Only
// bit 4 -- sdio_cmd_busy            -- Read-Only
// bit 3:0 -- sdio_status            -- Read-Only
#define P_SDIO_STATUS_IRQ                          (volatile unsigned long *)0xc1108c2c
// bit 31 -- halt_hole 0 -- 8 bits 1 -- 16 bits
// bit 30 -- force_halt
// bit 29:24 -- sdio_force_data_read (read_only)
// bit 23:22 -- disable_mem_halt (write and read)
// bit 21:16 -- sdio_force_output_en 
// bit 15 -- soft_reset
// bit 14 -- sdio_force_enable
// bit 13:8 -- sdio_force_data/sdio_read_data
// bit 7:6 -- sdio_if_int_config 
// bit 5 -- arc_soft_int_en
// bit 4 -- arc_cmd_int_en
// bit 3 -- arc_if_int_en
// bit 2 -- amrisc_soft_int_en
// bit 1 -- amrisc_cmd_int_en
// bit 0 -- amrisc_if_int_en
#define P_SDIO_IRQ_CONFIG                          (volatile unsigned long *)0xc1108c30
// bit 27:16 -- data_catch_finish_point
// (
// bit 15:12 -- response_read_index  
// bit 9 -- data_catch_readout_en
// bit 8 -- write_read_out_index
// ) this bits only write when write_read_out_index = 1
// bit 11 -- sdio_1_data_swap01 
// bit 10 -- sdio_0_data_on_1 
// bit 7:6 -- data_catch_level 
// bit 5 -- stream_8_bits_mode
// bit 4 -- stream_enable
// bit 3 -- ms_sclk_always
// bit 2 -- ms_enable
// bit 1:0 -- SDIO_port_sel //00-sdio1, 01-sdio2, 02-sdio3
#define P_SDIO_MULT_CONFIG                         (volatile unsigned long *)0xc1108c34
// bit 31:0 -- m_addr_sdio
#define P_SDIO_M_ADDR                              (volatile unsigned long *)0xc1108c38
// bit 31    -- CRC_status_4line
// bit 30    -- data_rw_do_not_have_crc16/MS_LONG_DATA_DO_NOT_HAVE_CRC16
// bit 29:16 -- data_rw_number/MS_LONG_DATA_NUMBER 
// bit 15:0 -- cmd_argument_ext/MS_SHORT_DATA_EXTENSION
#define P_SDIO_EXTENSION                           (volatile unsigned long *)0xc1108c3c
// ----------------------------
// ASYNC FIFO (4)
// ----------------------------
#define P_ASYNC_FIFO_REG0                          (volatile unsigned long *)0xc1108c40
#define P_ASYNC_FIFO_REG1                          (volatile unsigned long *)0xc1108c44
    #define ASYNC_FIFO_FLUSH_STATUS     31
    #define ASYNC_FIFO_ERR              30
    #define ASYNC_FIFO_FIFO_EMPTY       29
    #define ASYNC_FIFO_TO_HIU           24
    #define ASYNC_FIFO_FLUSH            23
    #define ASYNC_FIFO_RESET            22
    #define ASYNC_FIFO_WRAP_EN          21
    #define ASYNC_FIFO_FLUSH_EN         20
    #define ASYNC_FIFO_RESIDUAL_MSB     19
    #define ASYNC_FIFO_RESIDUAL_LSB     15
    #define ASYNC_FIFO_FLUSH_CNT_MSB    14
    #define ASYNC_FIFO_FLUSH_CNT_LSB    0
#define P_ASYNC_FIFO_REG2                          (volatile unsigned long *)0xc1108c48
    #define ASYNC_FIFO_FIFO_FULL        26
    #define ASYNC_FIFO_FILL_STATUS      25
    #define ASYNC_FIFO_SOURCE_MSB       24
    #define ASYNC_FIFO_SOURCE_LSB       23
    #define ASYNC_FIFO_ENDIAN_MSB       22
    #define ASYNC_FIFO_ENDIAN_LSB       21
    #define ASYNC_FIFO_FILL_EN          20
    #define ASYNC_FIFO_FILL_CNT_MSB     19
    #define ASYNC_FIFO_FILL_CNT_LSB     0
#define P_ASYNC_FIFO_REG3                          (volatile unsigned long *)0xc1108c4c
    #define ASYNC_FLUSH_SIZE_IRQ_MSB    15
    #define ASYNC_FLUSH_SIZE_IRQ_LSB    0
// ----------------------------
// ASYNC FIFO (4)
// ----------------------------
#define P_ASYNC_FIFO2_REG0                         (volatile unsigned long *)0xc1108c50
#define P_ASYNC_FIFO2_REG1                         (volatile unsigned long *)0xc1108c54
#define P_ASYNC_FIFO2_REG2                         (volatile unsigned long *)0xc1108c58
#define P_ASYNC_FIFO2_REG3                         (volatile unsigned long *)0xc1108c5c
// ----------------------------
// SPI
// ----------------------------
#define P_SPI_FLASH_CMD                            (volatile unsigned long *)0xc1108c80
    #define SPI_FLASH_READ    31
    #define SPI_FLASH_WREN    30
    #define SPI_FLASH_WRDI    29
    #define SPI_FLASH_RDID    28
    #define SPI_FLASH_RDSR    27
    #define SPI_FLASH_WRSR    26
    #define SPI_FLASH_PP      25
    #define SPI_FLASH_SE      24
    #define SPI_FLASH_BE      23
    #define SPI_FLASH_CE      22
    #define SPI_FLASH_DP      21
    #define SPI_FLASH_RES     20
    #define SPI_HPM           19
    #define SPI_FLASH_USR     18
    #define SPI_FLASH_USR_ADDR 15
    #define SPI_FLASH_USR_DUMMY 14
    #define SPI_FLASH_USR_DIN   13
    #define SPI_FLASH_USR_DOUT   12
    #define SPI_FLASH_USR_DUMMY_BLEN   10
    #define SPI_FLASH_USR_CMD     0
#define P_SPI_FLASH_ADDR                           (volatile unsigned long *)0xc1108c84
    #define SPI_FLASH_BYTES_LEN 24
    #define SPI_FLASH_ADDR_START 0
#define P_SPI_FLASH_CTRL                           (volatile unsigned long *)0xc1108c88
    #define SPI_ENABLE_AHB    17
    #define SPI_SST_AAI       16
    #define SPI_RES_RID       15
    #define SPI_FREAD_DUAL    14
    #define SPI_READ_READ_EN  13
    #define SPI_CLK_DIV0      12
    #define SPI_CLKCNT_N      8
    #define SPI_CLKCNT_H      4
    #define SPI_CLKCNT_L      0
#define P_SPI_FLASH_CTRL1                          (volatile unsigned long *)0xc1108c8c
#define P_SPI_FLASH_STATUS                         (volatile unsigned long *)0xc1108c90
#define P_SPI_FLASH_CTRL2                          (volatile unsigned long *)0xc1108c94
#define P_SPI_FLASH_CLOCK                          (volatile unsigned long *)0xc1108c98
#define P_SPI_FLASH_USER                           (volatile unsigned long *)0xc1108c9c
#define P_SPI_FLASH_USER1                          (volatile unsigned long *)0xc1108ca0
#define P_SPI_FLASH_USER2                          (volatile unsigned long *)0xc1108ca4
#define P_SPI_FLASH_USER3                          (volatile unsigned long *)0xc1108ca8
#define P_SPI_FLASH_USER4                          (volatile unsigned long *)0xc1108cac
#define P_SPI_FLASH_SLAVE                          (volatile unsigned long *)0xc1108cb0
#define P_SPI_FLASH_SLAVE1                         (volatile unsigned long *)0xc1108cb4
#define P_SPI_FLASH_SLAVE2                         (volatile unsigned long *)0xc1108cb8
#define P_SPI_FLASH_SLAVE3                         (volatile unsigned long *)0xc1108cbc
#define P_SPI_FLASH_C0                             (volatile unsigned long *)0xc1108cc0
#define P_SPI_FLASH_C1                             (volatile unsigned long *)0xc1108cc4
#define P_SPI_FLASH_C2                             (volatile unsigned long *)0xc1108cc8
#define P_SPI_FLASH_C3                             (volatile unsigned long *)0xc1108ccc
#define P_SPI_FLASH_C4                             (volatile unsigned long *)0xc1108cd0
#define P_SPI_FLASH_C5                             (volatile unsigned long *)0xc1108cd4
#define P_SPI_FLASH_C6                             (volatile unsigned long *)0xc1108cd8
#define P_SPI_FLASH_C7                             (volatile unsigned long *)0xc1108cdc
#define P_SPI_FLASH_B8                             (volatile unsigned long *)0xc1108ce0
#define P_SPI_FLASH_B9                             (volatile unsigned long *)0xc1108ce4
#define P_SPI_FLASH_B10                            (volatile unsigned long *)0xc1108ce8
#define P_SPI_FLASH_B11                            (volatile unsigned long *)0xc1108cec
#define P_SPI_FLASH_B12                            (volatile unsigned long *)0xc1108cf0
#define P_SPI_FLASH_B13                            (volatile unsigned long *)0xc1108cf4
#define P_SPI_FLASH_B14                            (volatile unsigned long *)0xc1108cf8
#define P_SPI_FLASH_B15                            (volatile unsigned long *)0xc1108cfc
// ----------------------------
// SPI #2
// ----------------------------
#define P_SPI2_FLASH_CMD                           (volatile unsigned long *)0xc1108d80
#define P_SPI2_FLASH_ADDR                          (volatile unsigned long *)0xc1108d84
#define P_SPI2_FLASH_CTRL                          (volatile unsigned long *)0xc1108d88
#define P_SPI2_FLASH_CTRL1                         (volatile unsigned long *)0xc1108d8c
#define P_SPI2_FLASH_STATUS                        (volatile unsigned long *)0xc1108d90
#define P_SPI2_FLASH_CTRL2                         (volatile unsigned long *)0xc1108d94
#define P_SPI2_FLASH_CLOCK                         (volatile unsigned long *)0xc1108d98
#define P_SPI2_FLASH_USER                          (volatile unsigned long *)0xc1108d9c
#define P_SPI2_FLASH_USER1                         (volatile unsigned long *)0xc1108da0
#define P_SPI2_FLASH_USER2                         (volatile unsigned long *)0xc1108da4
#define P_SPI2_FLASH_USER3                         (volatile unsigned long *)0xc1108da8
#define P_SPI2_FLASH_USER4                         (volatile unsigned long *)0xc1108dac
#define P_SPI2_FLASH_SLAVE                         (volatile unsigned long *)0xc1108db0
#define P_SPI2_FLASH_SLAVE1                        (volatile unsigned long *)0xc1108db4
#define P_SPI2_FLASH_SLAVE2                        (volatile unsigned long *)0xc1108db8
#define P_SPI2_FLASH_SLAVE3                        (volatile unsigned long *)0xc1108dbc
#define P_SPI2_FLASH_C0                            (volatile unsigned long *)0xc1108dc0
#define P_SPI2_FLASH_C1                            (volatile unsigned long *)0xc1108dc4
#define P_SPI2_FLASH_C2                            (volatile unsigned long *)0xc1108dc8
#define P_SPI2_FLASH_C3                            (volatile unsigned long *)0xc1108dcc
#define P_SPI2_FLASH_C4                            (volatile unsigned long *)0xc1108dd0
#define P_SPI2_FLASH_C5                            (volatile unsigned long *)0xc1108dd4
#define P_SPI2_FLASH_C6                            (volatile unsigned long *)0xc1108dd8
#define P_SPI2_FLASH_C7                            (volatile unsigned long *)0xc1108ddc
#define P_SPI2_FLASH_B8                            (volatile unsigned long *)0xc1108de0
#define P_SPI2_FLASH_B9                            (volatile unsigned long *)0xc1108de4
#define P_SPI2_FLASH_B10                           (volatile unsigned long *)0xc1108de8
#define P_SPI2_FLASH_B11                           (volatile unsigned long *)0xc1108dec
#define P_SPI2_FLASH_B12                           (volatile unsigned long *)0xc1108df0
#define P_SPI2_FLASH_B13                           (volatile unsigned long *)0xc1108df4
#define P_SPI2_FLASH_B14                           (volatile unsigned long *)0xc1108df8
#define P_SPI2_FLASH_B15                           (volatile unsigned long *)0xc1108dfc
//
// Closing file:  periphs_reg.h
//
//
// Reading file:  isa_reg.h
//
// $isa/rtl/isa_core register defines for the APB bus
// CBUS base slave address
// -----------------------------------------------
// CBUS_BASE:  ISA_CBUS_BASE = 0x26
// -----------------------------------------------
// Up to 256 registers for this base
#define P_ISA_DEBUG_REG0                           (volatile unsigned long *)0xc1109800
#define P_ISA_DEBUG_REG1                           (volatile unsigned long *)0xc1109804
#define P_ISA_DEBUG_REG2                           (volatile unsigned long *)0xc1109808
#define P_ISA_PLL_CLK_SIM0                         (volatile unsigned long *)0xc1109820
#define P_ISA_CNTL_REG0                            (volatile unsigned long *)0xc1109824
// -----------------------------------------------------------
#define P_AUD_ARC_IRQ_IN0_INTR_STAT                (volatile unsigned long *)0xc1109840
#define P_AUD_ARC_IRQ_IN0_INTR_STAT_CLR            (volatile unsigned long *)0xc1109844
#define P_AUD_ARC_IRQ_IN0_INTR_MASK                (volatile unsigned long *)0xc1109848
    #define INT_USB1                   31
    #define INT_USB0                   30
    #define INT_TIMERD                 29
    #define INT_DVIN                   27
    #define INT_UART                   26
    #define INT_ASYNC_FIFO2_FLUSH      25
    #define INT_ASYNC_FIFO2_FILL       24
    #define INT_DEMUX                  23
    #define INT_ENCODER_IF             22
    #define INT_M_I2C_IRQ              21      
    #define INT_BTR656                 20 
    #define INT_ASYNC_FIFO_FLUSH       19
    #define INT_ASYNC_FIFO_FILL        18
    #define INT_ABUF_RD                17
    #define INT_ABUF_WR                16
    #define INT_IR_DEC_IRQ             15	// IR NEC Frame Decoder IRQ
    #define INT_BLKMV                  14
    #define INT_NDMA_IRQ               13	// New DMA Interrupt
    #define INT_IDE                    12
    #define INT_TIMERB                 11
    #define INT_TIMERA                 10
    #define INT_RDS_IRQ                 8      
    #define INT_AUDIN                   7      // AUDIN
    #define INT_TIMERC                  6
    #define INT_VFD_IRQ                 5      
    #define INT_IRQ14                   4
    #define INT_VSYNC                   3
    #define INT_HSYNC                   2
    #define INT_MAILBOX                 1
#define P_AUD_ARC_IRQ_IN0_INTR_FIRQ_SEL            (volatile unsigned long *)0xc110984c
#define P_AUD_ARC_IRQ_IN1_INTR_STAT                (volatile unsigned long *)0xc1109850
#define P_AUD_ARC_IRQ_IN1_INTR_STAT_CLR            (volatile unsigned long *)0xc1109854
#define P_AUD_ARC_IRQ_IN1_INTR_MASK                (volatile unsigned long *)0xc1109858
#define P_AUD_ARC_IRQ_IN1_INTR_FIRQ_SEL            (volatile unsigned long *)0xc110985c
#define P_AUD_ARC_IRQ_IN2_INTR_STAT                (volatile unsigned long *)0xc1109860
#define P_AUD_ARC_IRQ_IN2_INTR_STAT_CLR            (volatile unsigned long *)0xc1109864
#define P_AUD_ARC_IRQ_IN2_INTR_MASK                (volatile unsigned long *)0xc1109868
#define P_AUD_ARC_IRQ_IN2_INTR_FIRQ_SEL            (volatile unsigned long *)0xc110986c
#define P_AUD_ARC_IRQ_IN3_INTR_STAT                (volatile unsigned long *)0xc1109870
#define P_AUD_ARC_IRQ_IN3_INTR_STAT_CLR            (volatile unsigned long *)0xc1109874
#define P_AUD_ARC_IRQ_IN3_INTR_MASK                (volatile unsigned long *)0xc1109878
#define P_AUD_ARC_IRQ_IN3_INTR_FIRQ_SEL            (volatile unsigned long *)0xc110987c
#define P_GPIO_INTR_EDGE_POL                       (volatile unsigned long *)0xc1109880
#define P_GPIO_INTR_GPIO_SEL0                      (volatile unsigned long *)0xc1109884
#define P_GPIO_INTR_GPIO_SEL1                      (volatile unsigned long *)0xc1109888
#define P_GPIO_INTR_FILTER_SEL0                    (volatile unsigned long *)0xc110988c
#define P_GLOBAL_INTR_DISABLE                      (volatile unsigned long *)0xc1109890
// -----------------------------------------------------------
#define P_WATCHDOG_TC                              (volatile unsigned long *)0xc1109900
#define P_WATCHDOG_RESET                           (volatile unsigned long *)0xc1109904
// -----------------------------------------------------------
#define P_AHB_ARBITER_REG                          (volatile unsigned long *)0xc1109908
#define P_AHB_ARBDEC_REG                           (volatile unsigned long *)0xc110990c
// -----------------------------------------------------------
#define P_ISA_BIST_REG0                            (volatile unsigned long *)0xc1109910
#define P_ISA_BIST_REG1                            (volatile unsigned long *)0xc1109914
#define P_ISA_BIST_REG2                            (volatile unsigned long *)0xc1109918
#define P_ISA_BIST_REG3                            (volatile unsigned long *)0xc110991c
#define P_ISA_BIST_REG4                            (volatile unsigned long *)0xc1109920
#define P_ISA_BIST_REG5                            (volatile unsigned long *)0xc1109924
// -----------------------------------------------------------
#define P_ISA_TIMER_MUX                            (volatile unsigned long *)0xc1109940
#define P_ISA_TIMERA                               (volatile unsigned long *)0xc1109944
#define P_ISA_TIMERB                               (volatile unsigned long *)0xc1109948
#define P_ISA_TIMERC                               (volatile unsigned long *)0xc110994c
#define P_ISA_TIMERD                               (volatile unsigned long *)0xc1109950
#define P_ISA_TIMERE                               (volatile unsigned long *)0xc1109954
#define P_FBUF_ADDR                                (volatile unsigned long *)0xc1109958
    #define VIDEO_FRM_BUF_MSB_BIT      23 
    #define VIDEO_FRM_BUF_LSB_BIT       2 
#define P_SDRAM_CTL0                               (volatile unsigned long *)0xc110995c
#define P_SDRAM_CTL2                               (volatile unsigned long *)0xc1109960
#define P_AUD_ARC_CTL                              (volatile unsigned long *)0xc1109964
#define P_SDRAM_CTL4                               (volatile unsigned long *)0xc1109968
#define P_SDRAM_CTL5                               (volatile unsigned long *)0xc110996c
#define P_SDRAM_CTL6                               (volatile unsigned long *)0xc1109970
#define P_SDRAM_CTL7                               (volatile unsigned long *)0xc1109974
#define P_SDRAM_CTL8                               (volatile unsigned long *)0xc1109978
#define P_AHB_MP4_MC_CTL                           (volatile unsigned long *)0xc110997c
#define P_AUD_ARC_PCR                              (volatile unsigned long *)0xc1109980
// ---------------------------------------------
#define P_ABUF_WR_CTL0                             (volatile unsigned long *)0xc11099c0
    #define ABUF_WR_INT_EN	    31
    #define ABUF_WR_INT_POS_MSB      30 
    #define ABUF_WR_INT_POS_LSB      16 
    #define ABUF_WR_BLK_SIZE_MSB     14 
    #define ABUF_WR_BLK_SIZE_LSB      0
#define P_ABUF_WR_CTL1                             (volatile unsigned long *)0xc11099c4
    #define ABUF_WR_INT_EN	    31
    #define ABUF_WR_INT_POS_MSB      30 
    #define ABUF_WR_INT_POS_LSB      16 
    #define ABUF_WR_BLK_SIZE_MSB     14 
    #define ABUF_WR_BLK_SIZE_LSB      0
#define P_ABUF_WR_CTL2                             (volatile unsigned long *)0xc11099c8
    #define ABUF_WR_CUR_FF_CNT_MSB   21
    #define ABUF_WR_CUR_FF_CNT_LSB   16
    #define ABUF_WR_CUR_BLK_MSB      14
    #define ABUF_WR_CUR_BLK_LSB       0   
#define P_ABUF_WR_CTL3                             (volatile unsigned long *)0xc11099cc
    #define ABUF_WR_AHB_RST_PLS       3
    #define ABUF_WR_FF_CLR_PLS        2
    #define ABUF_WR_PLY_RPT_LVL	     1
    #define ABUF_WR_FF_PAUSE_LVL      0
#define P_ABUF_RD_CTL0                             (volatile unsigned long *)0xc11099d0
#define P_ABUF_RD_CTL1                             (volatile unsigned long *)0xc11099d4
    #define ABUF_RD_INT_EN	    31
    #define ABUF_RD_INT_POS_MSB      30 
    #define ABUF_RD_INT_POS_LSB      16 
    #define ABUF_RD_BLK_SIZE_MSB     14 
    #define ABUF_RD_BLK_SIZE_LSB      0   
#define P_ABUF_RD_CTL2                             (volatile unsigned long *)0xc11099d8
    #define ABUF_RD_CUR_FF_CNT_MSB   21
    #define ABUF_RD_CUR_FF_CNT_LSB   16
    #define ABUF_RD_CUR_BLK_MSB      14
    #define ABUF_RD_CUR_BLK_LSB       0   
#define P_ABUF_RD_CTL3                             (volatile unsigned long *)0xc11099dc
    #define ABUF_RD_PLY_ONCE_PLS      4
    #define ABUF_RD_AHB_RST_PLS       3
    #define ABUF_RD_FF_CLR_PLS        2
    #define ABUF_RD_PLY_RPT_LVL	     1
    #define ABUF_RD_FF_PAUSE_LVL      0
#define P_ABUF_ARB_CTL0                            (volatile unsigned long *)0xc11099e0
#define P_ABUF_FIFO_CTL0                           (volatile unsigned long *)0xc11099e4
    #define AIUout_FIFO_THRESHOLD_MSB 11
    #define AIUout_FIFO_THRESHOLD_LSB 6 
    #define AIUin_FIFO_THRESHOLD_MSB  5
    #define AIUin_FIFO_THRESHOLD_LSB  0
// ---------------------------------------------
#define P_AHB_BRIDGE_CNTL_WR                       (volatile unsigned long *)0xc1109a00
#define P_AHB_BRIDGE_REMAP0                        (volatile unsigned long *)0xc1109a04
#define P_AHB_BRIDGE_REMAP1                        (volatile unsigned long *)0xc1109a08
#define P_AHB_BRIDGE_REMAP2                        (volatile unsigned long *)0xc1109a0c
#define P_AHB_BRIDGE_REMAP3                        (volatile unsigned long *)0xc1109a10
#define P_AHB_BRIDGE_CNTL_REG1                     (volatile unsigned long *)0xc1109a14
// ---------------------------------------------
// -----------------------------------------------------------
#define P_A9_0_IRQ_IN0_INTR_STAT                   (volatile unsigned long *)0xc1109a40
#define P_A9_0_IRQ_IN0_INTR_STAT_CLR               (volatile unsigned long *)0xc1109a44
#define P_A9_0_IRQ_IN0_INTR_MASK                   (volatile unsigned long *)0xc1109a48
#define P_A9_0_IRQ_IN0_INTR_FIRQ_SEL               (volatile unsigned long *)0xc1109a4c
#define P_A9_0_IRQ_IN1_INTR_STAT                   (volatile unsigned long *)0xc1109a50
#define P_A9_0_IRQ_IN1_INTR_STAT_CLR               (volatile unsigned long *)0xc1109a54
#define P_A9_0_IRQ_IN1_INTR_MASK                   (volatile unsigned long *)0xc1109a58
#define P_A9_0_IRQ_IN1_INTR_FIRQ_SEL               (volatile unsigned long *)0xc1109a5c
#define P_A9_0_IRQ_IN2_INTR_STAT                   (volatile unsigned long *)0xc1109a60
#define P_A9_0_IRQ_IN2_INTR_STAT_CLR               (volatile unsigned long *)0xc1109a64
#define P_A9_0_IRQ_IN2_INTR_MASK                   (volatile unsigned long *)0xc1109a68
#define P_A9_0_IRQ_IN2_INTR_FIRQ_SEL               (volatile unsigned long *)0xc1109a6c
#define P_A9_0_IRQ_IN3_INTR_STAT                   (volatile unsigned long *)0xc1109a70
#define P_A9_0_IRQ_IN3_INTR_STAT_CLR               (volatile unsigned long *)0xc1109a74
#define P_A9_0_IRQ_IN3_INTR_MASK                   (volatile unsigned long *)0xc1109a78
#define P_A9_0_IRQ_IN3_INTR_FIRQ_SEL               (volatile unsigned long *)0xc1109a7c
// -----------------------------------------------------------
#define P_A9_1_IRQ_IN0_INTR_STAT                   (volatile unsigned long *)0xc1109a80
#define P_A9_1_IRQ_IN0_INTR_STAT_CLR               (volatile unsigned long *)0xc1109a84
#define P_A9_1_IRQ_IN0_INTR_MASK                   (volatile unsigned long *)0xc1109a88
#define P_A9_1_IRQ_IN0_INTR_FIRQ_SEL               (volatile unsigned long *)0xc1109a8c
#define P_A9_1_IRQ_IN1_INTR_STAT                   (volatile unsigned long *)0xc1109a90
#define P_A9_1_IRQ_IN1_INTR_STAT_CLR               (volatile unsigned long *)0xc1109a94
#define P_A9_1_IRQ_IN1_INTR_MASK                   (volatile unsigned long *)0xc1109a98
#define P_A9_1_IRQ_IN1_INTR_FIRQ_SEL               (volatile unsigned long *)0xc1109a9c
#define P_A9_1_IRQ_IN2_INTR_STAT                   (volatile unsigned long *)0xc1109aa0
#define P_A9_1_IRQ_IN2_INTR_STAT_CLR               (volatile unsigned long *)0xc1109aa4
#define P_A9_1_IRQ_IN2_INTR_MASK                   (volatile unsigned long *)0xc1109aa8
#define P_A9_1_IRQ_IN2_INTR_FIRQ_SEL               (volatile unsigned long *)0xc1109aac
#define P_A9_1_IRQ_IN3_INTR_STAT                   (volatile unsigned long *)0xc1109ab0
#define P_A9_1_IRQ_IN3_INTR_STAT_CLR               (volatile unsigned long *)0xc1109ab4
#define P_A9_1_IRQ_IN3_INTR_MASK                   (volatile unsigned long *)0xc1109ab8
#define P_A9_1_IRQ_IN3_INTR_FIRQ_SEL               (volatile unsigned long *)0xc1109abc
//
// Closing file:  isa_reg.h
//
// -----------------------------------------------
// CBUS_BASE:  DDR_CBUS_BASE = 0x13
// -----------------------------------------------
// TEMP DEFINES
// -----------------------------------------------
// CBUS_BASE:  PERIPHS4_CBUS_BASE = 0x24
// -----------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PERIPHS5_CBUS_BASE = 0x25
// -----------------------------------------------
// For iq_om_width change for RealVideo
#define P_IQ_OM_WIDTH                              (volatile unsigned long *)0xc1109440
//`define IQ_OM_WIDTH_12
#define P_DBG_ADDR_START                           (volatile unsigned long *)0xc110bfc0
#define P_DBG_ADDR_END                             (volatile unsigned long *)0xc110bffc
#define P_DBG_CTRL                                 (volatile unsigned long *)0xc110bfc4
#define P_DBG_LED                                  (volatile unsigned long *)0xc110bfc8
#define P_DBG_SWITCH                               (volatile unsigned long *)0xc110bfcc
#define P_DBG_VERSION                              (volatile unsigned long *)0xc110bfd0
//========================================================================
//  Global Control Registers			    (12'h000 - 12'h0ff)
//
//========================================================================
// -----------------------------------------------
// CBUS_BASE:  RESET_CBUS_BASE = 0x11
// -----------------------------------------------
#define P_VERSION_CTRL                             (volatile unsigned long *)0xc1104400
#define P_RESET0_REGISTER                          (volatile unsigned long *)0xc1104404
#define P_RESET1_REGISTER                          (volatile unsigned long *)0xc1104408
#define P_RESET2_REGISTER                          (volatile unsigned long *)0xc110440c
#define P_RESET3_REGISTER                          (volatile unsigned long *)0xc1104410
#define P_RESET4_REGISTER                          (volatile unsigned long *)0xc1104414
//======================================
//  Reset Register Bits	
//
//======================================
    #define HIU_RESET	    0x0001
    #define VLD_RESET	    0x0002
    #define IQIDCT_RESET	0x0004
    #define MC_RESET	    0x0008
    #define DCU_RESET	    0x0010
    #define VIU_RESET	    0x0020
    #define AIU_RESET	    0x0040
    #define CPU_RESET	    0x0080
    #define AC3_RESET	    0x0100
    #define MPEG_RESET	    0x0200
//========================================================================
//  Host uP Interface				    (12'h100 - 12'h2ff)
//
//========================================================================
// -----------------------------------------------
// CBUS_BASE:  HIU_CBUS_BASE = 0x10
// -----------------------------------------------
#define P_SCR_HIU                                  (volatile unsigned long *)0xc110402c
#define P_HPG_TIMER                                (volatile unsigned long *)0xc110403c
#define P_HARM_ASB_MB0                             (volatile unsigned long *)0xc11040c0
#define P_HARM_ASB_MB1                             (volatile unsigned long *)0xc11040c4
#define P_HARM_ASB_MB2                             (volatile unsigned long *)0xc11040c8
#define P_HARM_ASB_MB3                             (volatile unsigned long *)0xc11040cc
#define P_HASB_ARM_MB0                             (volatile unsigned long *)0xc11040d0
#define P_HASB_ARM_MB1                             (volatile unsigned long *)0xc11040d4
#define P_HASB_ARM_MB2                             (volatile unsigned long *)0xc11040d8
#define P_HASB_ARM_MB3                             (volatile unsigned long *)0xc11040dc
#define P_HHI_TIMER90K                             (volatile unsigned long *)0xc11040ec
#define P_HHI_AUD_DAC_CTRL                         (volatile unsigned long *)0xc1104110
#define P_HHI_SYS_PLL_CNTL2                        (volatile unsigned long *)0xc1104134
#define P_HHI_AUD_PLL_CNTL2                        (volatile unsigned long *)0xc1104138
#define P_HHI_VID_PLL_CNTL2                        (volatile unsigned long *)0xc110413c
// Gated clock enables.  There are 64 enables for the MPEG clocks and 32 enables for other clock domains
#define P_HHI_GCLK_MPEG0                           (volatile unsigned long *)0xc1104140
#define P_HHI_GCLK_MPEG1                           (volatile unsigned long *)0xc1104144
#define P_HHI_GCLK_MPEG2                           (volatile unsigned long *)0xc1104148
#define P_HHI_GCLK_OTHER                           (volatile unsigned long *)0xc1104150
// PLL Controls
#define P_HHI_SYS_PLL_CNTL3                        (volatile unsigned long *)0xc1104158
#define P_HHI_AUD_PLL_CNTL3                        (volatile unsigned long *)0xc110415c
#define P_HHI_VID_PLL_CNTL3                        (volatile unsigned long *)0xc1104160
#define P_HHI_VID_CLK_DIV                          (volatile unsigned long *)0xc1104164
#define P_HHI_SYS_PLL_CNTL                         (volatile unsigned long *)0xc1104168
#define P_HHI_AUD_PLL_CNTL                         (volatile unsigned long *)0xc110416c
#define P_HHI_VID_PLL_CNTL                         (volatile unsigned long *)0xc1104170
#define P_HHI_MPEG_CLK_CNTL                        (volatile unsigned long *)0xc1104174
#define P_HHI_AUD_CLK_CNTL                         (volatile unsigned long *)0xc1104178
#define P_HHI_VID_CLK_CNTL                         (volatile unsigned long *)0xc110417c
#define P_HHI_WIFI_CLK_CNTL                        (volatile unsigned long *)0xc1104180
#define P_HHI_WIFI_PLL_CNTL                        (volatile unsigned long *)0xc1104184
#define P_HHI_WIFI_PLL_CNTL2                       (volatile unsigned long *)0xc1104188
#define P_HHI_WIFI_PLL_CNTL3                       (volatile unsigned long *)0xc110418c
#define P_HHI_A9_CLK_CNTL                          (volatile unsigned long *)0xc110419c
#define P_HHI_DDR_PLL_CNTL                         (volatile unsigned long *)0xc11041a0
#define P_HHI_DDR_PLL_CNTL2                        (volatile unsigned long *)0xc11041a4
#define P_HHI_DDR_PLL_CNTL3                        (volatile unsigned long *)0xc11041a8
#define P_HHI_MALI_CLK_CNTL                        (volatile unsigned long *)0xc11041b0
#define P_HHI_DEMOD_PLL_CNTL                       (volatile unsigned long *)0xc11041b4
#define P_HHI_DEMOD_PLL_CNTL2                      (volatile unsigned long *)0xc11041b8
#define P_HHI_DEMOD_PLL_CNTL3                      (volatile unsigned long *)0xc11041bc
#define P_HHI_OTHER_PLL_CNTL                       (volatile unsigned long *)0xc11041c0
#define P_HHI_OTHER_PLL_CNTL2                      (volatile unsigned long *)0xc11041c4
#define P_HHI_OTHER_PLL_CNTL3                      (volatile unsigned long *)0xc11041c8
#define P_HHI_HDMI_CLK_CNTL                        (volatile unsigned long *)0xc11041cc
#define P_HHI_DEMOD_CLK_CNTL                       (volatile unsigned long *)0xc11041d0
#define P_HHI_SATA_CLK_CNTL                        (volatile unsigned long *)0xc11041d4
#define P_HHI_ETH_CLK_CNTL                         (volatile unsigned long *)0xc11041d8
#define P_HHI_A9_AUTO_CLK0                         (volatile unsigned long *)0xc11041e0
#define P_HHI_A9_AUTO_CLK1                         (volatile unsigned long *)0xc11041e4
#define P_HHI_ARC625_AUTO_CLK0                     (volatile unsigned long *)0xc11041e8
#define P_HHI_ARC625_AUTO_CLK1                     (volatile unsigned long *)0xc11041ec
#define P_HHI_HDMI_PLL_CNTL                        (volatile unsigned long *)0xc11041f0
#define P_HHI_HDMI_PLL_CNTL1                       (volatile unsigned long *)0xc11041f4
#define P_HHI_HDMI_PLL_CNTL2                       (volatile unsigned long *)0xc11041f8
#define P_HHI_HDMI_AFC_CNTL                        (volatile unsigned long *)0xc11041fc
#define P_HHI_AUD_PLL_MOD_CNTL0                    (volatile unsigned long *)0xc1104200
#define P_HHI_AUD_PLL_MOD_LOW_TCNT                 (volatile unsigned long *)0xc1104204
#define P_HHI_AUD_PLL_MOD_HIGH_TCNT                (volatile unsigned long *)0xc1104208
#define P_HHI_AUD_PLL_MOD_NOM_TCNT                 (volatile unsigned long *)0xc110420c
#define P_HHI_VID_PLL_MOD_CNTL0                    (volatile unsigned long *)0xc1104210
#define P_HHI_VID_PLL_MOD_LOW_TCNT                 (volatile unsigned long *)0xc1104214
#define P_HHI_VID_PLL_MOD_HIGH_TCNT                (volatile unsigned long *)0xc1104218
#define P_HHI_VID_PLL_MOD_NOM_TCNT                 (volatile unsigned long *)0xc110421c
#define P_HHI_JTAG_CONFIG                          (volatile unsigned long *)0xc1104238
//-----------------------------------------------------------
// PARSER 
//-----------------------------------------------------------
// -----------------------------------------------
// CBUS_BASE:  PARSER_CBUS_BASE = 0x01
// -----------------------------------------------
// bit 31:8 -- es_pack_size
// bit 7:6 -- es_type     00-Video, 01-Audio, 10-Subtitle
// bit 5 -- es_write
// bit 4 -- es_passthrough
// bit 3 -- insert_before_es_write
// bit 2 -- discard_cmd
// bit 1 -- search_cmd
// bit 0 -- Parser Busy
#define P_PARSER_CONTROL                           (volatile unsigned long *)0xc1100580
// Write
//   bit 31:0 begin address for parser fetch
// Read
//   32 bit current fetch address
#define P_PARSER_FETCH_ADDR                        (volatile unsigned long *)0xc1100584
// Write
//   bit 31 circle buffer indicator
//   bit 30 check_buffer_stop_addr
//   bit 29:27 fetch endian 
//   bit 26:0 buffer size ( Bytes )
// Special command:
//   when bit 26:0 == 27'h0
//     then bit 29    -- stream_passthrough_enable
//          bit 28:27 -- stream_passthrough_type
// Read
//   6:5 cmd_rd_ptr 
//   4:3 cmd_wr_ptr 
//   2:0 cmd_number 
#define P_PARSER_FETCH_CMD                         (volatile unsigned long *)0xc1100588
// 31:0 stop_fetch_addr
#define P_PARSER_FETCH_STOP_ADDR                   (volatile unsigned long *)0xc110058c
// 31:0 stop_fetch_addr - current_write_addr  // read only
#define P_PARSER_FETCH_LEVEL                       (volatile unsigned long *)0xc1100590
// bit 31 - fetch_dma_urgent
// bit 30 - stream_dma_urgent
// bit 29 - force_pfifo_ren
// bit 28 - pfifo_peak_enable
// bit 27 - enable_free_clk_parser_reg
// bit 26 -
// bit 25:24 - parser_src_sel (00 - fetch, 01 - aux1, 10 - aux2 11 - aux3)
// bit 23:16 - pfifo_empty_count
// bit 15:12 - max_es_write_cycle (x16x64bits) 
// 11:10 - start code width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )  
// 9:8 - pfifo data access width ( 00-8bits, 01-16bits, 10-24bits, 11-32bits )  
// 7:0 - empty room for fetch data ( max_fetch_cycle ) x64 bits
#define P_PARSER_CONFIG                            (volatile unsigned long *)0xc1100594
// bit 24:16 -- pfifo_level
// bit 9:0 -- point to byte address
#define P_PFIFO_WR_PTR                             (volatile unsigned long *)0xc1100598
// bit 9:0 -- point to byte address
#define P_PFIFO_RD_PTR                             (volatile unsigned long *)0xc110059c
// bit 31:0 -- 8/16/24/32 bits data acording to pfifo_data_width
#define P_PFIFO_DATA                               (volatile unsigned long *)0xc11005a0
// bit 31:0 -- parser search pattern 
#define P_PARSER_SEARCH_PATTERN                    (volatile unsigned long *)0xc11005a4
// bit 31:0 -- parser search mask ( 0 - disable bit match test )
#define P_PARSER_SEARCH_MASK                       (volatile unsigned long *)0xc11005a8
// bit 31:16 -- parser_int_disable_count
// bit 15:8 -- Parser interrupt enable for host cpu 
// bit 7:0 -- Parser interrupt enable for Amrisc 
#define P_PARSER_INT_ENABLE                        (volatile unsigned long *)0xc11005ac
// Bit 7 -- fetch_cmd_finished
// Bit 6:5 -- reserved
// Bit 4 -- parse finished
// Bit 3 -- discard finished
// Bit 2 -- insert zero finished
// Bit 1 -- Action Finished Except Search Start Code
// Bit 0 -- Search match interrupt (StartCode found)
// Read 7:0 int status
// Write will clear (bit based) 
#define P_PARSER_INT_STATUS                        (volatile unsigned long *)0xc11005b0
// 15    - SCR_32_READ_OUT (Read Only)
// 14    - SCR_32_data_valid
// 13    - SCR_32_data
// 12    - SCR_count_en
// 11:0  - SCR90K_DIV
#define P_PARSER_SCR_CTL                           (volatile unsigned long *)0xc11005b4
// bit 31:0 SCR value
#define P_PARSER_SCR                               (volatile unsigned long *)0xc11005b8
// bit 31:24 -- insert_loop_number
// bit 23:21 -- 
// bit 20:16 -- insert_byte_number 
// bit 15:0 -- discard number
#define P_PARSER_PARAMETER                         (volatile unsigned long *)0xc11005bc
// bit 31:0 -- insert data // write only
// write to PARSER_CONTROL will reset the write position
// continous write to this address can write upto 16 bytes 
#define P_PARSER_INSERT_DATA                       (volatile unsigned long *)0xc11005c0
// Bit 31:24 -- Reserved Stream_ID
// Bit 23:16 -- Sub Stream_ID
// Bit 15:8  -- Audio Stream_ID
// Bit 7:0   -- Video Stream_ID
#define P_VAS_STREAM_ID                            (volatile unsigned long *)0xc11005c4
// Bit 31:0 -- VIDEO_DTS
#define P_VIDEO_DTS                                (volatile unsigned long *)0xc11005c8
// Bit 31:0 -- VIDEO_PTS
#define P_VIDEO_PTS                                (volatile unsigned long *)0xc11005cc
// Bit 31:0 -- VIDEO_PTS_DTS_WR_PTR
#define P_VIDEO_PTS_DTS_WR_PTR                     (volatile unsigned long *)0xc11005d0
// Bit 31:0 -- AUDIO_PTS
#define P_AUDIO_PTS                                (volatile unsigned long *)0xc11005d4
// Bit 31:0 -- AUDIO_PTS_WR_PTR
#define P_AUDIO_PTS_WR_PTR                         (volatile unsigned long *)0xc11005d8
// bit 31:20 -- stream_es_count ( Read Only)
// bit 19 -- req_pending ( parser ddr_A_fifo ) (Read Only)
// bit 18 -- stream_es_passthrough_enable
// bit 17:16 -- stream_es_passthrough_type
// bit 15:12 -- reserved
// bit 11:9 -- SUB Ees_write Endian 
// bit 8 -- SUB using manual read point
// bit 7:5 -- AUDIO Ees_write Endian 
// bit 4 -- AUDIO using manual read point
// bit 3:1 -- VIDEO Ees_write Endian 
// bit 0 -- VIDEO using manual read point
#define P_PARSER_ES_CONTROL                        (volatile unsigned long *)0xc11005dc
// Bit 31:0 PFIFO_MONITOR
#define P_PFIFO_MONITOR                            (volatile unsigned long *)0xc11005e0
// --------------------------------------------
// PARSER_VIDEO DDR Interface
// --------------------------------------------
// The PARSER_VIDEO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_VIDEO_START_PTR                   (volatile unsigned long *)0xc1100600
#define P_PARSER_VIDEO_END_PTR                     (volatile unsigned long *)0xc1100604
// --------------------------------------------
// PARSER_VIDEO Buffer Level Manager
// --------------------------------------------
#define P_PARSER_VIDEO_WP                          (volatile unsigned long *)0xc1100608
#define P_PARSER_VIDEO_RP                          (volatile unsigned long *)0xc110060c
#define P_PARSER_VIDEO_HOLE                        (volatile unsigned long *)0xc1100610
// --------------------------------------------
// PARSER_AUDIO DDR Interface
// --------------------------------------------
// The PARSER_AUDIO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_AUDIO_START_PTR                   (volatile unsigned long *)0xc1100614
#define P_PARSER_AUDIO_END_PTR                     (volatile unsigned long *)0xc1100618
// --------------------------------------------
// PARSER_AUDIO Buffer Level Manager
// --------------------------------------------
#define P_PARSER_AUDIO_WP                          (volatile unsigned long *)0xc110061c
#define P_PARSER_AUDIO_RP                          (volatile unsigned long *)0xc1100620
#define P_PARSER_AUDIO_HOLE                        (volatile unsigned long *)0xc1100624
// --------------------------------------------
// PARSER_SUB DDR Interface
// --------------------------------------------
// The PARSER_SUB start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_PARSER_SUB_START_PTR                     (volatile unsigned long *)0xc1100628
#define P_PARSER_SUB_END_PTR                       (volatile unsigned long *)0xc110062c
// --------------------------------------------
// PARSER_SUB Buffer Level Manager
// --------------------------------------------
#define P_PARSER_SUB_WP                            (volatile unsigned long *)0xc1100630
#define P_PARSER_SUB_RP                            (volatile unsigned long *)0xc1100634
#define P_PARSER_SUB_HOLE                          (volatile unsigned long *)0xc1100638
// Bit[31] dma_busy
// Bit[30] cur_fetch_or_es_write
// Bit[29:28] reserved
// Bit[27:24] fetch_status
// Bit[23:0] buffer_cycles_left
#define P_PARSER_FETCH_INFO                        (volatile unsigned long *)0xc110063c
// Bit[31:28] ctl_status
// Bit[27:24] insert_byte_offset
// Bit[23:0] es_pack_left_cycle
#define P_PARSER_STATUS                            (volatile unsigned long *)0xc1100640
// Bit [31:16] AUDIO_wrap_count
// Bit  [15:0] VIDEO_wrap_count
#define P_PARSER_AV_WRAP_COUNT                     (volatile unsigned long *)0xc1100644
// bit[29:24] A_brst_num_parser
// bit[21:16] A_id_parser
// bit[11:0] wrrsp_count_parser
#define P_WRRSP_PARSER                             (volatile unsigned long *)0xc1100648
// `define CSS_cmd             12'h200   // address of css command and indirect register
// `define CSS_cntl            12'h201   // css control register
// `define CSS_data            12'h202   // indirect register
// `define CSS_id1_data  	    12'h203   // ID data for the first and second bytes
// `define CSS_id2_data  	    12'h204   // ID data for the third and fourth bytes
//CPPM registers
// `define CPPM_IFIFO_CTRL		12'h210	  //CPPM input FIFO control
// `define CPPM_C2BC_KEY		12'h211	  //CPPM C2 Block Cipher Key register
// `define CPPM_C2BC_DIN		12'h212	  //CPPM C2 Block Cipher data input register
// `define CPPM_C2BC_DOUT		12'h213   //CPPM C2 Block Cipher data result register
// `define CPPM_CMD			12'h214   //CPPM command and control register
// `define CPPM_CTRL_STATUS	12'h215   //CPPM control status, mainly for debug 
// `define CPPM_IFIFO_DATA		12'h216   //CPPM input FIFO data pop port, just for debug 
// DDR registers
//`define USE_DDR2
//========================================================================
//  DVIN Registers				    (12'h2e0 - 12'h2ef)
//
//========================================================================
// -----------------------------------------------
// CBUS_BASE:  DVIN_CBUS_BASE = 0x12
// -----------------------------------------------
#define P_VDIN_SCALE_COEF_IDX                      (volatile unsigned long *)0xc1104800
#define P_VDIN_SCALE_COEF                          (volatile unsigned long *)0xc1104804
//bit 31,   mpeg_to_vdin_sel, 0: mpeg source to NR directly, 1: mpeg source pass through here
//bit 30,   mpeg_field info which can be written by software
//Bit 29,   force go_field, pulse signal
//Bit 28,   force go_line, pulse signal
//Bit 26:20, hold lines
//Bit 19,   delay go_field function enable
//Bit 18:12, delay go_field line number 
//Bit 11:10, component2 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in 
//Bit 9:8, component1 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in 
//Bit 7:6, component0 output switch, 00: select component0 in, 01: select component1 in, 10: select component2 in 
//Bit 4, enable VDIN common data input, otherwise there will be video data input
//Bit 3:0 vdin selection, 1: mpeg_in from dram, 2: component input, 3: tvdecoder input, 4: hdmi input, otherwise no input
#define P_VDIN_COM_CTRL0                           (volatile unsigned long *)0xc1104808
//Bit 28:16 active_max_pix_cnt, readonly
//Bit 12:0  active_max_pix_cnt_shadow, readonly
#define P_VDIN_ACTIVE_MAX_PIX_CNT_STATUS           (volatile unsigned long *)0xc110480c
//Bit 28:16 go_line_cnt, readonly
//Bit 12:0  active_line_cnt, readonly
#define P_VDIN_LCNT_STATUS                         (volatile unsigned long *)0xc1104810
#define P_VDIN_COM_STATUS0                         (volatile unsigned long *)0xc1104814
#define P_VDIN_COM_STATUS1                         (volatile unsigned long *)0xc1104818
//Bit 28:16 go_line_cnt_shadow, readonly
//Bit 12:0  active_line_cnt_shadow, readonly
#define P_VDIN_LCNT_SHADOW_STATUS                  (volatile unsigned long *)0xc110481c
#define P_VDIN_ASFIFO_CTRL0                        (volatile unsigned long *)0xc1104820
#define P_VDIN_ASFIFO_CTRL1                        (volatile unsigned long *)0xc1104824
//Bit 28:16 input width minus 1
//Bit 12:0  output width minus 1
#define P_VDIN_WIDTHM1I_WIDTHM1O                   (volatile unsigned long *)0xc1104828
//Bit 6, prehsc_en
//Bit 5, hsc_en,
//Bit 4, hsc_nearest_en
//Bit 3, phase0_always_en
//Bit 2:0, hsc_bank_length
#define P_VDIN_SC_MISC_CTRL                        (volatile unsigned long *)0xc110482c
//Bit 28:24, interge portion
//Bit 23:0, fraction portion
#define P_VDIN_HSC_PHASE_STEP                      (volatile unsigned long *)0xc1104830
//Bit 30:29    hscale rpt_p0_num
//Bit 28:24    hscale ini_rcv_num
//Bit 23:0     hscale ini_phase
#define P_VDIN_HSC_INI_CTRL                        (volatile unsigned long *)0xc1104834
//Bit 0    post conversion matrix enable
#define P_VDIN_MATRIX_CTRL                         (volatile unsigned long *)0xc1104840
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_VDIN_MATRIX_COEF00_01                    (volatile unsigned long *)0xc1104844
//Bit 28:16 coef02 
//Bit 12:0  coef10 
#define P_VDIN_MATRIX_COEF02_10                    (volatile unsigned long *)0xc1104848
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_VDIN_MATRIX_COEF11_12                    (volatile unsigned long *)0xc110484c
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_VDIN_MATRIX_COEF20_21                    (volatile unsigned long *)0xc1104850
#define P_VDIN_MATRIX_COEF22                       (volatile unsigned long *)0xc1104854
//Bit 26:16 offset0
//Bit 10:0  offset1
#define P_VDIN_MATRIX_OFFSET0_1                    (volatile unsigned long *)0xc1104858
//Bit 10:0  offset2
#define P_VDIN_MATRIX_OFFSET2                      (volatile unsigned long *)0xc110485c
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define P_VDIN_MATRIX_PRE_OFFSET0_1                (volatile unsigned long *)0xc1104860
//Bit 10:0  pre_offset2
#define P_VDIN_MATRIX_PRE_OFFSET2                  (volatile unsigned long *)0xc1104864
//11:0 lfifo_buf_size
#define P_VDIN_LFIFO_CTRL                          (volatile unsigned long *)0xc1104868
#define P_VDIN_COM_GCLK_CTRL                       (volatile unsigned long *)0xc110486c
#define P_VDIN_WR_CTRL                             (volatile unsigned long *)0xc1104880
//Bit 27:16 start
//Bit 11:0  end
#define P_VDIN_WR_H_START_END                      (volatile unsigned long *)0xc1104884
//Bit 27:16 start
//Bit 11:0  end
#define P_VDIN_WR_V_START_END                      (volatile unsigned long *)0xc1104888
//Bit 6:5   hist_dnlp_low   the real pixels in each bins got by VDIN_DNLP_HISTXX should multiple with 2^(dnlp_low+3)
//Bit 3:2   hist_din_sel    the source used for hist statistics. 2'b00: from MAT; 2'b01: from HSC; 2'b1X: from PREHSC
//Bit 1     hist_win_en     1'b0: hist used for full picture; 1'b1: hist used for pixels within hist window
//Bit 0     hist_spl_en     1'b0: disable hist readback; 1'b1: enable hist readback
#define P_VDIN_HIST_CTRL                           (volatile unsigned long *)0xc11048c0
//Bit 28:16 hist_hstart  horizontal start value to define hist window
//Bit 12:0  hist_hend    horizontal end value to define hist window
#define P_VDIN_HIST_H_START_END                    (volatile unsigned long *)0xc11048c4
//Bit 28:16 hist_vstart  vertical start value to define hist window
//Bit 12:0  hist_vend    vertical end value to define hist window
#define P_VDIN_HIST_V_START_END                    (volatile unsigned long *)0xc11048c8
//Bit 15:8  hist_max    maximum value 
//Bit 7:0   hist_min    minimum value 
//read only
#define P_VDIN_HIST_MAX_MIN                        (volatile unsigned long *)0xc11048cc
//Bit 31:0  hist_spl_rd
//counts for the total luma value 
//read only
#define P_VDIN_HIST_SPL_VAL                        (volatile unsigned long *)0xc11048d0
//Bit 21:0  hist_spl_pixel_count
//counts for the total calculated pixels
//read only
#define P_VDIN_HIST_SPL_PIX_CNT                    (volatile unsigned long *)0xc11048d4
//Bit 31:0  hist_chroma_sum
//counts for the total chroma value 
//read only
#define P_VDIN_HIST_CHROMA_SUM                     (volatile unsigned long *)0xc11048d8
//Bit 31:16 higher hist bin
//Bit 15:0  lower hist bin
//0-255 are splited to 64 bins evenly, and VDIN_DNLP_HISTXX
//are the statistic number of pixels that within each bin.
//VDIN_DNLP_HIST00[15:0]  counts for the first  bin
//VDIN_DNLP_HIST00[31:16] counts for the second bin
//VDIN_DNLP_HIST01[15:0]  counts for the third  bin
//VDIN_DNLP_HIST01[31:16] counts for the fourth bin
//etc...
//read only
#define P_VDIN_DNLP_HIST00                         (volatile unsigned long *)0xc11048dc
#define P_VDIN_DNLP_HIST01                         (volatile unsigned long *)0xc11048e0
#define P_VDIN_DNLP_HIST02                         (volatile unsigned long *)0xc11048e4
#define P_VDIN_DNLP_HIST03                         (volatile unsigned long *)0xc11048e8
#define P_VDIN_DNLP_HIST04                         (volatile unsigned long *)0xc11048ec
#define P_VDIN_DNLP_HIST05                         (volatile unsigned long *)0xc11048f0
#define P_VDIN_DNLP_HIST06                         (volatile unsigned long *)0xc11048f4
#define P_VDIN_DNLP_HIST07                         (volatile unsigned long *)0xc11048f8
#define P_VDIN_DNLP_HIST08                         (volatile unsigned long *)0xc11048fc
#define P_VDIN_DNLP_HIST09                         (volatile unsigned long *)0xc1104900
#define P_VDIN_DNLP_HIST10                         (volatile unsigned long *)0xc1104904
#define P_VDIN_DNLP_HIST11                         (volatile unsigned long *)0xc1104908
#define P_VDIN_DNLP_HIST12                         (volatile unsigned long *)0xc110490c
#define P_VDIN_DNLP_HIST13                         (volatile unsigned long *)0xc1104910
#define P_VDIN_DNLP_HIST14                         (volatile unsigned long *)0xc1104914
#define P_VDIN_DNLP_HIST15                         (volatile unsigned long *)0xc1104918
#define P_VDIN_DNLP_HIST16                         (volatile unsigned long *)0xc110491c
#define P_VDIN_DNLP_HIST17                         (volatile unsigned long *)0xc1104920
#define P_VDIN_DNLP_HIST18                         (volatile unsigned long *)0xc1104924
#define P_VDIN_DNLP_HIST19                         (volatile unsigned long *)0xc1104928
#define P_VDIN_DNLP_HIST20                         (volatile unsigned long *)0xc110492c
#define P_VDIN_DNLP_HIST21                         (volatile unsigned long *)0xc1104930
#define P_VDIN_DNLP_HIST22                         (volatile unsigned long *)0xc1104934
#define P_VDIN_DNLP_HIST23                         (volatile unsigned long *)0xc1104938
#define P_VDIN_DNLP_HIST24                         (volatile unsigned long *)0xc110493c
#define P_VDIN_DNLP_HIST25                         (volatile unsigned long *)0xc1104940
#define P_VDIN_DNLP_HIST26                         (volatile unsigned long *)0xc1104944
#define P_VDIN_DNLP_HIST27                         (volatile unsigned long *)0xc1104948
#define P_VDIN_DNLP_HIST28                         (volatile unsigned long *)0xc110494c
#define P_VDIN_DNLP_HIST29                         (volatile unsigned long *)0xc1104950
#define P_VDIN_DNLP_HIST30                         (volatile unsigned long *)0xc1104954
#define P_VDIN_DNLP_HIST31                         (volatile unsigned long *)0xc1104958
// Bit 31:22 blkbar_black_level    threshold to judge a black point
// Bit 21    Reserved
// Bit 20:8  blkbar_hwidth         left and right region width
// Bit 7:5   blkbar_comp_sel       select yin or uin or vin to be the valid input
// Bit 4     blkbar_sw_statistic_en enable software statistic of each block black points number
// Bit 3     blkbar_det_en         
// Bit 2:1   blkbar_din_sel        
// bit blkbar_det_top_en
#define P_VDIN_BLKBAR_CTRL0                        (volatile unsigned long *)0xc1104980
// Bit 31:29 Reserved
// Bit 28:16 blkbar_hstart.        Left region start
// Bit 15:13 Reserved
// Bit 12:0  blkbar_hend.          Right region end
#define P_VDIN_BLKBAR_H_START_END                  (volatile unsigned long *)0xc1104984
// Bit 31:29 Reserved
// Bit 28:16 blkbar_vstart        
// Bit 15:13 Reserved
// Bit 12:0  blkbar_vend
#define P_VDIN_BLKBAR_V_START_END                  (volatile unsigned long *)0xc1104988
// Bit 31:20 Reserved
// Bit 19:0  blkbar_cnt_threshold. threshold to judge whether a block is totally black  
#define P_VDIN_BLKBAR_CNT_THRESHOLD                (volatile unsigned long *)0xc110498c
// Bit 31:29 Reserved
// Bit 28:16 blkbar_row_th1.       //threshold of the top blackbar
// Bit 15:13 Reserved
// bit 12:0  blkbar_row_th2        //threshold of the bottom blackbar
#define P_VDIN_BLKBAR_ROW_TH1_TH2                  (volatile unsigned long *)0xc1104990
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_ind_left_start. horizontal start of the left region in the current searching
// Bit 15:13 Reserved
// Bit 12:0  blkbar_ind_left_end.   horizontal end of the left region in the current searching
#define P_VDIN_BLKBAR_IND_LEFT_START_END           (volatile unsigned long *)0xc1104994
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_ind_right_start.horizontal start of the right region in the current searching
// Bit 15:13 Reserved
// Bit 12:0  blkbar_ind_right_end.  horizontal end of the right region in the current searching
#define P_VDIN_BLKBAR_IND_RIGHT_START_END          (volatile unsigned long *)0xc1104998
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_left1_cnt.  Black pixel counter. left part of the left region
#define P_VDIN_BLKBAR_IND_LEFT1_CNT                (volatile unsigned long *)0xc110499c
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_left2_cnt.  Black pixel counter. rigth part of the left region
#define P_VDIN_BLKBAR_IND_LEFT2_CNT                (volatile unsigned long *)0xc11049a0
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_right1_cnt. Black pixel counter. left part of the right region
#define P_VDIN_BLKBAR_IND_RIGHT1_CNT               (volatile unsigned long *)0xc11049a4
//Readonly
// Bit 31:20 Reserved
// Bit 19:0  blkbar_ind_right2_cnt. Black pixel counter. right part of the right region
#define P_VDIN_BLKBAR_IND_RIGHT2_CNT               (volatile unsigned long *)0xc11049a8
//Readonly
// Bit 31:30 Resersed
// Bit 29    blkbar_ind_black_det_done. LEFT/RIGHT Black detection done
// Bit 28:16 blkbar_top_pos.            Top black bar position
// Bit 15:13 Reserved.
// Bit 12:0  blkbar_bot_pos.            Bottom black bar position
#define P_VDIN_BLKBAR_STATUS0                      (volatile unsigned long *)0xc11049ac
//Readonly
// Bit 31:29 Reserved
// Bit 28:16 blkbar_left_pos.       Left black bar posiont
// Bit 15:13 Reserved
// Bit 12:0  blkbar_right_pos.      Right black bar position
#define P_VDIN_BLKBAR_STATUS1                      (volatile unsigned long *)0xc11049b0
// Bit 31:11 Reserved
// Bit 10: 9 RW, vs_hs_tim_ctrl
// Bit     8 RW, sample_clk_neg
// Bit     7 RW, mode_422
// Bit  6: 5 RW, de_mode
// Bit     4 RW, ext_field_sel
// Bit     3 RW, field_pol_inv
// Bit     2 RW, de_pol_inv
// Bit     1 RW, vs_pol_inv
// Bit     0 RW, hs_pol_inv
#define P_DVIN_FRONT_END_CTRL                      (volatile unsigned long *)0xc1104b80
// Bit 31:28 Reserved
// Bit 27:16 RW, hs_lead_vs_odd_max
// Bit 15:12 Reserved
// Bit 11: 0 RW, hs_lead_vs_odd_min
#define P_DVIN_HS_LEAD_VS_ODD                      (volatile unsigned long *)0xc1104b84
// Bit 31:28 Reserved
// Bit 27:16 RW, active_start_pix_fo
// Bit 15:12 Reserved
// Bit 11: 0 RW, active_start_pix_fe
#define P_DVIN_ACTIVE_START_PIX                    (volatile unsigned long *)0xc1104b88
// Bit 31:28 Reserved
// Bit 27:16 RW, active_start_line_fo
// Bit 15:12 Reserved
// Bit 11: 0 RW, active_start_line_fe
#define P_DVIN_ACTIVE_START_LINE                   (volatile unsigned long *)0xc1104b8c
// Bit 31:28 Reserved
// Bit 27:16 RW, field_height_m1
// Bit 15:12 Reserved
// Bit 11: 0 RW, line_width_m1
#define P_DVIN_DISPLAY_SIZE                        (volatile unsigned long *)0xc1104b90
// Bit 31:30 Reserved
// Bit    29 R,  multiple_fifo_fend
// Bit    28 R,  fifo_overflow
// Bit 27:16 R,  hs_lead_vs_cnt
// Bit 15: 5 Reserved
// Bit     4 RW, ddr_burst_size -- 0=default,32 per burst; 1=64 per burst
// Bit     3 W,  clear_err (a pulse)
// Bit     2 RW, urgent
// Bit     1 RW, fifo_reset
// Bit     0 RW, dvin_enable
#define P_DVIN_CTRL_STAT                           (volatile unsigned long *)0xc1104b94
// Bit 31: 8 Reserved
// Bit  7: 0 RW, nxt_tbl_addr
#define P_DVIN_VCANV_TBL_ADDR                      (volatile unsigned long *)0xc1104b98
// Bit 31:29 Reserved
// Bit 28:16 RW, nxt_y_start_addr
// Bit 15:12 Reserved
// Bit 11: 0 RW, nxt_x_start_addr
#define P_DVIN_VCANV_XY_START_ADDR                 (volatile unsigned long *)0xc1104b9c
//========================================================================
//  CPU Registers				    (8'h00 - 8'hff)
//
//========================================================================
// CPU1 registers are 8'h0x
// -----------------------------------------------
// CBUS_BASE:  CPU1_CBUS_BASE = 0x03
// -----------------------------------------------
#define P_MSP                                      (volatile unsigned long *)0xc1100c00
#define P_MPSR                                     (volatile unsigned long *)0xc1100c04
#define P_MINT_VEC_BASE                            (volatile unsigned long *)0xc1100c08
#define P_MCPU_INTR_GRP                            (volatile unsigned long *)0xc1100c0c
#define P_MCPU_INTR_MSK                            (volatile unsigned long *)0xc1100c10
#define P_MCPU_INTR_REQ                            (volatile unsigned long *)0xc1100c14
#define P_MPC_P                                    (volatile unsigned long *)0xc1100c18
#define P_MPC_D                                    (volatile unsigned long *)0xc1100c1c
#define P_MPC_E                                    (volatile unsigned long *)0xc1100c20
#define P_MPC_W                                    (volatile unsigned long *)0xc1100c24
#define P_MINDEX0_REG                              (volatile unsigned long *)0xc1100c28
#define P_MINDEX1_REG                              (volatile unsigned long *)0xc1100c2c
#define P_MINDEX2_REG                              (volatile unsigned long *)0xc1100c30
#define P_MINDEX3_REG                              (volatile unsigned long *)0xc1100c34
#define P_MINDEX4_REG                              (volatile unsigned long *)0xc1100c38
#define P_MINDEX5_REG                              (volatile unsigned long *)0xc1100c3c
#define P_MINDEX6_REG                              (volatile unsigned long *)0xc1100c40
#define P_MINDEX7_REG                              (volatile unsigned long *)0xc1100c44
#define P_MMIN_REG                                 (volatile unsigned long *)0xc1100c48
#define P_MMAX_REG                                 (volatile unsigned long *)0xc1100c4c
#define P_MBREAK0_REG                              (volatile unsigned long *)0xc1100c50
#define P_MBREAK1_REG                              (volatile unsigned long *)0xc1100c54
#define P_MBREAK2_REG                              (volatile unsigned long *)0xc1100c58
#define P_MBREAK3_REG                              (volatile unsigned long *)0xc1100c5c
#define P_MBREAK_TYPE                              (volatile unsigned long *)0xc1100c60
#define P_MBREAK_CTRL                              (volatile unsigned long *)0xc1100c64
#define P_MBREAK_STAUTS                            (volatile unsigned long *)0xc1100c68
#define P_MDB_ADDR_REG                             (volatile unsigned long *)0xc1100c6c
#define P_MDB_DATA_REG                             (volatile unsigned long *)0xc1100c70
#define P_MDB_CTRL                                 (volatile unsigned long *)0xc1100c74
#define P_MSFTINT0                                 (volatile unsigned long *)0xc1100c78
#define P_MSFTINT1                                 (volatile unsigned long *)0xc1100c7c
#define P_CSP                                      (volatile unsigned long *)0xc1100c80
#define P_CPSR                                     (volatile unsigned long *)0xc1100c84
#define P_CINT_VEC_BASE                            (volatile unsigned long *)0xc1100c88
#define P_CCPU_INTR_GRP                            (volatile unsigned long *)0xc1100c8c
#define P_CCPU_INTR_MSK                            (volatile unsigned long *)0xc1100c90
#define P_CCPU_INTR_REQ                            (volatile unsigned long *)0xc1100c94
#define P_CPC_P                                    (volatile unsigned long *)0xc1100c98
#define P_CPC_D                                    (volatile unsigned long *)0xc1100c9c
#define P_CPC_E                                    (volatile unsigned long *)0xc1100ca0
#define P_CPC_W                                    (volatile unsigned long *)0xc1100ca4
#define P_CINDEX0_REG                              (volatile unsigned long *)0xc1100ca8
#define P_CINDEX1_REG                              (volatile unsigned long *)0xc1100cac
#define P_CINDEX2_REG                              (volatile unsigned long *)0xc1100cb0
#define P_CINDEX3_REG                              (volatile unsigned long *)0xc1100cb4
#define P_CINDEX4_REG                              (volatile unsigned long *)0xc1100cb8
#define P_CINDEX5_REG                              (volatile unsigned long *)0xc1100cbc
#define P_CINDEX6_REG                              (volatile unsigned long *)0xc1100cc0
#define P_CINDEX7_REG                              (volatile unsigned long *)0xc1100cc4
#define P_CMIN_REG                                 (volatile unsigned long *)0xc1100cc8
#define P_CMAX_REG                                 (volatile unsigned long *)0xc1100ccc
#define P_CBREAK0_REG                              (volatile unsigned long *)0xc1100cd0
#define P_CBREAK1_REG                              (volatile unsigned long *)0xc1100cd4
#define P_CBREAK2_REG                              (volatile unsigned long *)0xc1100cd8
#define P_CBREAK3_REG                              (volatile unsigned long *)0xc1100cdc
#define P_CBREAK_TYPE                              (volatile unsigned long *)0xc1100ce0
#define P_CBREAK_CTRL                              (volatile unsigned long *)0xc1100ce4
#define P_CBREAK_STAUTS                            (volatile unsigned long *)0xc1100ce8
#define P_CDB_ADDR_REG                             (volatile unsigned long *)0xc1100cec
#define P_CDB_DATA_REG                             (volatile unsigned long *)0xc1100cf0
#define P_CDB_CTRL                                 (volatile unsigned long *)0xc1100cf4
#define P_CSFTINT0                                 (volatile unsigned long *)0xc1100cf8
#define P_CSFTINT1                                 (volatile unsigned long *)0xc1100cfc
#define P_IMEM_DMA_CTRL                            (volatile unsigned long *)0xc1100d00
#define P_IMEM_DMA_ADR                             (volatile unsigned long *)0xc1100d04
#define P_IMEM_DMA_COUNT                           (volatile unsigned long *)0xc1100d08
// bit[29:24] A_brst_num_imem
// bit[21:16] A_id_imem
// bit[11:0] wrrsp_count_imem (reserved)
#define P_WRRSP_IMEM                               (volatile unsigned long *)0xc1100d0c
#define P_LMEM_DMA_CTRL                            (volatile unsigned long *)0xc1100d40
#define P_LMEM_DMA_ADR                             (volatile unsigned long *)0xc1100d44
#define P_LMEM_DMA_COUNT                           (volatile unsigned long *)0xc1100d48
// bit[29:24] A_brst_num_lmem
// bit[21:16] A_id_lmem
// bit[11:0] wrrsp_count_lmem 
#define P_WRRSP_LMEM                               (volatile unsigned long *)0xc1100d4c
#define P_MAC_CTRL1                                (volatile unsigned long *)0xc1100d80
#define P_ACC0REG1                                 (volatile unsigned long *)0xc1100d84
#define P_ACC1REG1                                 (volatile unsigned long *)0xc1100d88
#define P_MAC_CTRL2                                (volatile unsigned long *)0xc1100dc0
#define P_ACC0REG2                                 (volatile unsigned long *)0xc1100dc4
#define P_ACC1REG2                                 (volatile unsigned long *)0xc1100dc8
#define P_CPU_TRACE                                (volatile unsigned long *)0xc1100e00
//=======================================================================
// XIF module
// `include "xregs.h"
    #define X_INT_ADR           0x400
    #define GPIO_ADR            0x401
    #define GPIO_ADR_H8         0x402 
    #define WFIFO_DEPTH         8          
    #define WFIFO_PointerWidth  3
    #define WFIFO_WORDSIZE      32
// MAC module
#define P_CLR_ACC_MAC                              (volatile unsigned long *)0xc1101c40
#define P_CLR_ACC_MAC2                             (volatile unsigned long *)0xc1101c44
#define P_ACC_0                                    (volatile unsigned long *)0xc1101c48
#define P_ACC_1                                    (volatile unsigned long *)0xc1101c4c
#define P_ACC_2                                    (volatile unsigned long *)0xc1101c50
#define P_ACC_3                                    (volatile unsigned long *)0xc1101c54
//========================================================================
//  Audio Interface				    (12'h500 - 12'h5ff)
//
//========================================================================
//
// Reading file:  aregs.h
//
//========================================================================
//  Audio Interface                                 (8'h00 - 8'hff)
//  Modified : Xuyun Chen Jan 2001
//========================================================================
// Number of bytes expected per NON-PCM frame, including the header.
// 16 bits.  
// -----------------------------------------------
// CBUS_BASE:  AIU_CBUS_BASE = 0x15
// -----------------------------------------------
#define P_AIU_958_BPF                              (volatile unsigned long *)0xc1105400
// Value of burst_info used in IEC958 preamble for a NON-PCM frame. See
// ATSC AC-3 spec Annex B. 16 bits.
#define P_AIU_958_BRST                             (volatile unsigned long *)0xc1105404
// Value of length_code used in IEC958 preamble for an NON-PCM frame. See
// ATSC AC-3 spec Annex B. 16 bits.
#define P_AIU_958_LENGTH                           (volatile unsigned long *)0xc1105408
// How many subframes to padd around the NON-PCM frame. This will 
// be set to 'd3072 if it is a AC-3 audio stream.
// 16 bits
#define P_AIU_958_PADDSIZE                         (volatile unsigned long *)0xc110540c
// 16'd3072
// Misc. control settings for IEC958 interface
// Bit 15:14 pcm_sample_ctl, 00-pcm_no_sample, 01-pcm_sample_up, 10-pcm_sample_down, 11-pcm_sample_down_drop
// Bit 13: if true, force each audio data to left or right according to the bit attached with the audio data
//         This bit should be used with Register AIU_958_force_left(0x505) together
// Bit 12: if true, the U(user data) is from the stream otherwise it is filled by 
//                   zero while encoding iec958 frame
// Bit 11   : if true big endian(highword,lowword) otherwise little endian(lowword,highword)
//            for 32bit mode 
// Bit 10:8 : shift number for 32 bit mode
// Bit 7  : 32 bit mode turn on while This bit is true and Bit 1 is true 
// Bit 6:5 : Specifies output alignment for 16 bit pcm data.
//          00 : dout = {8'b0, din};
//          01 : dout = {4'b0, din, 4'b0};
//          10 : dout = {      din, 8'b0};
// Bit 4  : True if data should be sent out MSB first. LSB first is the
//          default in the spec.
// Bit 3  : True if msb should be extended (only used with 16 bit pcm data.)
// Bit 2  : True if msb of PCM data should be inverted.
// Bit 1  : True if PCM data is 16 bits wide. False if 24 bit or 32bit mode.
// Bit 0  : True if source data is non-PCM data. False if it is PCM data.
#define P_AIU_958_MISC                             (volatile unsigned long *)0xc1105410
// 14'b0_0_0_000_0_0000001
// A write to this register specifies that the next pcm sample sent out
// of the iec958 interface should go into the _left_ channel.
#define P_AIU_958_FORCE_LEFT                       (volatile unsigned long *)0xc1105414
//Read Only
//bit 6:0  how many data discarded in the last dma after one frame data finish transfering to AIU 
// should used together with register AIU_958_dcu_ff_ctrl
#define P_AIU_958_DISCARD_NUM                      (volatile unsigned long *)0xc1105418
//bit 15:8  : A read from this register indicates the IEC958 FIFO count value 
//bit 7 :  ai_958_req_size if ture, set to 8 bits interface, used to handle odd frame continous read  
//bit 6 :  continue seeking and dont discard the rest data in one dma after frame end
//bit 5 :  if true, byte by byte seeking, otherwise word by word seeking
//bit 4 :  if true, the function for sync head seeking is enabled
//bit 3:2 :	IEC958 interrupt mode
// There are two conditions to generate interrupt. The First condition is that one frame data
// have been finished writing into FIFO. The second condition is at least some data of the current 
// frame have been read out(refer to Register AIU_958_ffrdout_thd)
//			00: interrupt is not generated
//			10:	interrupt is generated if the first condition is true 
//			01:	interrupt is generated if the second condition is true 
//			11:	interrupt is generated if both of the conditions are true 
//bit 1: fifo auto disable, High means after one frame data put into the FIFO, the FIFO
//					will automatically disabled
//bit 0: fifo enable
#define P_AIU_958_DCU_FF_CTRL                      (volatile unsigned long *)0xc110541c
// 'b0_0_1_11_1_0
// channel status registers for Left channel
// chstat_l0[15:0] contains bits 15:0 of the channel status word. Note
// that bit zero of the channel status word is sent out first.
// chstat_l1[15:0] contains bits 31:16 of the channel status word.
#define P_AIU_958_CHSTAT_L0                        (volatile unsigned long *)0xc1105420
#define P_AIU_958_CHSTAT_L1                        (volatile unsigned long *)0xc1105424
// Control register for IEC958 interface
// Bit 9:8 what to do if there is a fifo underrun
//         00 => insert 24'h000000
//         01 => insert mute constant as defined below
//         10 => repeat last l/r samples
// Bit 7:5 mute constant
//         000 => 24'h000000
//         001 => 24'h800000
//         010 => 24'h080000
//         011 => 24'h008000
//         100 => 24'h000001
//         101 => 24'h000010
//         110 => 24'h000100
// Bit 4   mute left speaker
// Bit 3   mute right speaker
// Bit 2:1 swap channels
//         00 : L R => L R
//         01 : L R => L L
//         10 : L R => R R
//         11 : L R => R L
// Bit 0   Set this bit to hold iec958 interface after the current
//         subframe has been completely transmitted.
#define P_AIU_958_CTRL                             (volatile unsigned long *)0xc1105428
// 10'b00_000_00_00_0
// A write operation to this register will cause one of the output samples
// to be repeated. This can be used to switch the left and the right
// channels.
#define P_AIU_958_RPT                              (volatile unsigned long *)0xc110542c
// Channel swap and mute control register.
// Bit 15: Mute extra left channel
// Bit 14: Mute extra right channel
// Bit 13: Mute center
// Bit 12: Mute subwoofer
// Bit 11: Mute surround left
// Bit 10: Mute surround right
// Bit  9: Mute left
// Bit  8: Mute right
// Bit 7:6 Channel swap for xtra dac
// Bit 5:4 Channel swap for sub/center dac
// Bit 3:2 Channel swap for surround dac
// Bit 1:0 Channel swap for main l/r dac
// Channel swap possibilities:
// 00 : L R => L R
// 01 : L R => L L
// 10 : L R => R R
// 11 : L R => R L
#define P_AIU_I2S_MUTE_SWAP                        (volatile unsigned long *)0xc1105430
// 16'b0
// Bit 0 : 0=> single two channel stream
//         1=> four two channel streams
#define P_AIU_I2S_SOURCE_DESC                      (volatile unsigned long *)0xc1105434
// Median filter control register
// Bit 1:  0=> data is offset binary
//         1=> data is signed
// Bit 0:  enable median filter
#define P_AIU_I2S_MED_CTRL                         (volatile unsigned long *)0xc1105438
// 2'b10
// Median filter threshold constant
// 16 bits
#define P_AIU_I2S_MED_THRESH                       (volatile unsigned long *)0xc110543c
// 16'h8000
// Describes dac's connected to I2S interface
// Bit 7:  sign extend sample before downshift.
// Bit 6:4 payload downshift constant
// Bit 3:  mute constant
//         0 => 'h0000000
//         1 => 'h800000
// Bit 2:  send msb first
// Bit 1:0 Size of payload
//         Note that this parameter used to be called "size of dacs"
//         It is now called the payload size since a 24 bit payload can
//         actually be connected to any size of dac. The dac will simply
//         disregard the extra bits.
//         00 => 16 bit, alrclk = aoclk/32 
//         01 => 20 bit, alrclk = aoclk/40 
//         10 => 24 bit, alrclk = aoclk/48 
//		   11 => 24 bit, but alrclk = aoclk/64 
#define P_AIU_I2S_DAC_CFG                          (volatile unsigned long *)0xc1105440
// 8'b0_000_1_1_10
// A write to this register will cause the interface to repeat the current
// sample. Can be used to regain synchronization.
// A read from this register indicates that the next sample to be sent
// out of the interface should go into the _left_ channel of the dac.
#define P_AIU_I2S_SYNC                             (volatile unsigned long *)0xc1105444
// Misc regs
// Bit 4 if true, force each audio data to left or right according to the bit attached with the audio data
//         This bit should be used with Register AIU_i2s_sync(0x511) together
// Bit 3:  Same Audio source for IEC958 and I2s stream 0, both from i2s buffer 
// Bit 2:  Set this bit to put i2s interface in hold mode
// Bit 1:0 How to handle underruns
//         00 => send zeros
//         01 => send 'h800000
//         10 => repeat last samples
#define P_AIU_I2S_MISC                             (volatile unsigned long *)0xc1105448
// 5'b0
// Bit 7:0 Audio output config.
//			2 bits for each dac, 7:6 for dac3, 5:4 for dac2,
//								 3:2 for dac1, 1:0 for dac0
//			For each 2bits: 00: connect channel0-1 to the dac
//							01: connect channel2-3 to the dac
//							10: connect channel4-5 to the dac
//							11: connect channel6-7 to the dac
#define P_AIU_I2S_OUT_CFG                          (volatile unsigned long *)0xc110544c
// 8'b0_000000_0
#define P_AIU_I2S_FF_CTRL                          (volatile unsigned long *)0xc1105450
// A write to this register resets the AIU
//Bit 3 reset slow domain iec958
//Bit 2 soft reset iec958 fast domain
//Bit 1 reset slow domain i2s
//Bit 0 soft reset i2s fast domain
#define P_AIU_RST_SOFT                             (volatile unsigned long *)0xc1105454
// Clock generation control register
// Bit 15: enable_ddr_arb, set low to reset
// Bit 14:13 parser_A_addr_sel  00-A_addr_aififo2, 01-A_addr_iec958, 10-A_addr_aififo, 11-A_addr_i2s
// Bit 12: 958 divisor more, if true, divided by 2, 4, 6, 8
// Bit 11: amclk output divisor
//			0 => dont divide
//			1 => divide by 2		
// Bit 10: clock source selection
//        0 => aiclk from pin
//        1 => ai_pll_clk from pll
// Bit 9:8 alrclk skew
//         00 => alrclk transitions at the same time msb is sent
//         01 => alrclk transitions on the cycle before msb is sent
//         10 => alrclk transitions on the cycle after msb is sent
// Bit 7: invert alrclk
// Bit 6: invert aoclk
// Bit 5:4 958 divisor
//        00 => divide by 1
//        01 => divide by 2
//		  10 => divide by 3
//		  11 => divide by 4
// Bit 3:2 i2s divisor. NOTE: this value is ignored if AIU_clk_ctrl_more[3:0] != 0 
//         00 => divide by 1
//         01 => divide by 2
//         10 => divide by 4
//         11 => divide by 8
// Bit 1: enable 958 divider
// Bit 0: enable i2s divider
#define P_AIU_CLK_CTRL                             (volatile unsigned long *)0xc1105458
// 13'b0_0_1_01_1_1_10_11_0_0
// Misc settings that determine the type of adc that is
// connected to the AIU. Reverb mode is deleted.
// Bit 12:  selects adc input
// Bit 11:10 adc size
//           00 => 16 bits
//           01 => 18 bits
//           10 => 20 bits
//           11 => 24 bits
// Bit 9:8   adc l/r swap mode
//           00 => stereo
//           01 => send the right adc input to both l and r speakers
//           01 => send the left adc input to both l and r speakers
//           11 => sum the left and right inputs and forward to
//                both speakers
// Bit 7:5 adata/lrclk skew mode
// Bit 4   1=>invert the adc's lrclk (This is the lrclk going _out_
//         of the chip.
// Bit 3   1=>Latch the data on the positive edge of the _internal_
//         aoclk.
// Bit 2   1=>adc data is in signed 2's complement mode
#define P_AIU_MIX_ADCCFG                           (volatile unsigned long *)0xc110545c
// 12'b01_00_001_1_0_1_00
// Control register that can be changed dynamically. These control
// signals are synchronized internally.
// Bit 12:  if true, toggle each mixed audio data to left or right channel
// Bit 11:  abuf din left selection, if true, select bit 24 of the data from abuf
//		    otherwise select bit 25 of the data from abuf
// Bit 10:9  mix sync select, when music, mic and abuf are mixed togather, the main
//			 sync source can be selected
//     00: not sync source
//	   01: music data is the main sync source
//	   10: abuf input data is the main sync source
//	   11: music and abuf togather as the sync source
// Bit 8:  0=> data from abuf is offset binary
//         1=> data from abuf is signed
// Bit 7:6 the source for data from aiu to abuf 
//           00 => mic
//           01 => mic saled + abuf scaled 
//           10 => mic scaled + abuf scaled + music scaled
//			 11 => music
// Bit 5   channel from aiu to abuf is on
// Bit 4   channel from abuf to aiu is on
// Bit 3   mic is on
// Bit 2   music is on
// Bit 1   if true the mixed data are outputed to i2s dac channel,
//			otherwise the mixed data are outputed to IEC958 output 
// Bit 0   if true music source for mixing is from i2s buffer, 
//			otherwise music source is from iec958 buffer
#define P_AIU_MIX_CTRL                             (volatile unsigned long *)0xc1105460
// 11'b01_1_01_0_0_0_1_1_1
// Bit 3:0 More control on i2s divisor. For backward compatiblity, this value is ignored if is 0,
//         if non-zero, it takes effect over AIU_clk_ctrl[3:2].
//         0=i2s divisor will use the old value in AIU_clk_ctrl[3:2] (divide by 1/2/4/8)
//         1=divide by 2;
//         2=divide by 3;
//         3=divide by 4;
//         ... and so on ...
//         15=divide by 16.
#define P_AIU_CLK_CTRL_MORE                        (volatile unsigned long *)0xc1105464
// A read from this register pops 16 bits of data off the 958
// fifo. A write has no effect.
#define P_AIU_958_POP                              (volatile unsigned long *)0xc1105468
//gain register for mixing
// for each gain, 
//			 00000: x 0
//			 00001: x 1
//			 00010: x 2
//           00011: x 3
//			 00100: x 4
//			 00101: x 5
//			 00110: x 6
//			......
//           01110: x14
//           01111: x15
//           10000: x 0
//           10001: x 1/16
//           10010: x 2/16
//           10011: x 3/16
//           10100: x 4/16
//			......
//           11110: x 14/16
//           11111: x 15/16
//Bit 14:10 mic gain
//Bit 9:5 	abuf gain
//Bit 4:0 music gain
#define P_AIU_MIX_GAIN                             (volatile unsigned long *)0xc110546c
// 15'b00001_00001_00001
//sync head seeking is supported. The  maxinium length of sync head is
//48-bit-wide.(in byte by byte seeking mode, the maximium is 44-bit-wide).
//It is consisted of 3 words (synword1_synword2_syncword3).
//You can configure the sync head pattern by using sync mask(mask1_mask2_mask3).  
//For example. AC-3 sync head is a 16-bit word(0b77), so syncword1 is set as 0b77, 
//mask1 is 0000(not set), mask2 and mask3 is all masked.
#define P_AIU_958_SYNWORD1                         (volatile unsigned long *)0xc1105470
//16'h0b77  //ac-3 sync head
#define P_AIU_958_SYNWORD2                         (volatile unsigned long *)0xc1105474
//16'h0000  
#define P_AIU_958_SYNWORD3                         (volatile unsigned long *)0xc1105478
//16'h0000
#define P_AIU_958_SYNWORD1_MASK                    (volatile unsigned long *)0xc110547c
//16'h0000 //16-bit ac-3 sync_head
#define P_AIU_958_SYNWORD2_MASK                    (volatile unsigned long *)0xc1105480
//16'hffff
#define P_AIU_958_SYNWORD3_MASK                    (volatile unsigned long *)0xc1105484
//16'hffff
//fifo read-out threshold, one condition to generate interrupt is met after fifo readout counter
//reach this value in a frame, please refer to register AIU_958_dcu_ff_ctrl
#define P_AIU_958_FFRDOUT_THD                      (volatile unsigned long *)0xc1105488
//'h0004
//For pause burst sequence adding, one pause burst sequence is consist of a serious
// pause burst.
//This register defines the length of each pause burst in a pause burst sequence. The size of the
//preamble(Pa, Pb, Pc, Pd) is not counted, but the size of stuff data is counted.
#define P_AIU_958_LENGTH_PER_PAUSE                 (volatile unsigned long *)0xc110548c
//'h0000
//This reigster defines the number of pause burst in a pause burst sequence.
//Bit 15  if true, one pause burst sequence will be added 
//Bit 14:0 the number of pause burst in a pause burst sequence
#define P_AIU_958_PAUSE_NUM                        (volatile unsigned long *)0xc1105490
//'h0000
//The first 16-bit in the payload of pause burst sequence (gap_length)
#define P_AIU_958_PAUSE_PAYLOAD                    (volatile unsigned long *)0xc1105494
//'h0000
//For auto pause function, when enabled, pause burst sequence will be automatically added if the data in
// 958 fifo is less than auto_pause threshold and if fifo is disabled.
//Bit 15   if true, auto pause function enable
//Bit 14   pause pack option, just for debugging and adding one option
//Bit 7:0  auto_pause threshold
#define P_AIU_958_AUTO_PAUSE                       (volatile unsigned long *)0xc1105498
//'h0000
//pause burst sequence payload length( = AIU_958_pause_num * AIU_958_length_per_pause)
#define P_AIU_958_PAUSE_PD_LENGTH                  (volatile unsigned long *)0xc110549c
//'h0000
// channel status registers for right channel
// chstat_r0[15:0] contains bits 15:0 of the channel status word. Note
// that bit zero of the channel status word is sent out first.
// chstat_r1[15:0] contains bits 31:16 of the channel status word.
#define P_AIU_958_CHSTAT_R0                        (volatile unsigned long *)0xc11054c0
#define P_AIU_958_CHSTAT_R1                        (volatile unsigned long *)0xc11054c4
//Bit 1 	if true, turn on Digital output Valid control
//Bit 0		0: output 0, 1: output 1 to the valid bit in audio digital output when Bit 1 is true
#define P_AIU_958_VALID_CTRL                       (volatile unsigned long *)0xc11054c8
//-----------------------------------------------------------------------------
// Audio Amplifier controls
//-----------------------------------------------------------------------------
#define P_AIU_AUDIO_AMP_REG0                       (volatile unsigned long *)0xc11054f0
#define P_AIU_AUDIO_AMP_REG1                       (volatile unsigned long *)0xc11054f4
#define P_AIU_AUDIO_AMP_REG2                       (volatile unsigned long *)0xc11054f8
#define P_AIU_AUDIO_AMP_REG3                       (volatile unsigned long *)0xc11054fc
//-----------------------------------------------------------------------------
//add for AIFIFO2 channel
//-----------------------------------------------------------------------------
//Bit 3 	CRC pop aififo2 enable
//Bit 2		writing to this bit to 1 causes CRC module reset
//Bit 1		unused
//Bit 0		writing to this bit to 1 causes AIFIFO2 soft reset
#define P_AIU_AIFIFO2_CTRL                         (volatile unsigned long *)0xc1105500
//'h0000
//AIFIFO2 status register
//Bit 4:0		//how many bits left in the first pop register
#define P_AIU_AIFIFO2_STATUS                       (volatile unsigned long *)0xc1105504
//Same fucntion as the AIGBIT of AIFIFO in CDROM module
//write to this register how many bits wanna pop, 
//and reading this register gets the corresponding bits data
#define P_AIU_AIFIFO2_GBIT                         (volatile unsigned long *)0xc1105508
//Same function as the AICLB of AIFIFO in CDROM module
//return the leading zeros by reading this registers
#define P_AIU_AIFIFO2_CLB                          (volatile unsigned long *)0xc110550c
//CRC control register, read/write
//Bit 0		CRC caculation start
//Bit 1		CRC core soft reset
//Bit 2		CRC input register clear
//Bit 3		CRC pop data from FIFO enable
//Bit 13:8	CRC polynomial equation order, between 1 to 32
#define P_AIU_CRC_CTRL                             (volatile unsigned long *)0xc1105510
//16'h1000
//CRC status register, read only
//Bit 7:4	CRC internal shift register bit select, just for debug purpose
//Bit 3		CRC internal shift register data valid, just for debug purpose
//Bit 2		CRC input register data valid
//Bit 1		CRC result, 1: CRC not correct, 0: CRC correct
//Bit 0		CRC state,  1: CRC busy, 0: CRC idle
#define P_AIU_CRC_STATUS                           (volatile unsigned long *)0xc1105514
//CRC internal shift register, read only, for debug purpose
#define P_AIU_CRC_SHIFT_REG                        (volatile unsigned long *)0xc1105518
//CRC data input register, read/write
#define P_AIU_CRC_IREG                             (volatile unsigned long *)0xc110551c
//16'h0000
//CRC calculation register high-bit part [31:16], read/write
#define P_AIU_CRC_CAL_REG1                         (volatile unsigned long *)0xc1105520
//CRC calculation register low-bit part [15:0], read/write
#define P_AIU_CRC_CAL_REG0                         (volatile unsigned long *)0xc1105524
//32'h00000000
//CRC polynomial coefficient high-bit part [31:16], read/write
#define P_AIU_CRC_POLY_COEF1                       (volatile unsigned long *)0xc1105528
//CRC polynomial coefficient low-bit part [15:0], read/write
#define P_AIU_CRC_POLY_COEF0                       (volatile unsigned long *)0xc110552c
//32'h80050000			default CRC-16
//CRC frame size, high-bit part [19:16], read/write
#define P_AIU_CRC_BIT_SIZE1                        (volatile unsigned long *)0xc1105530
//CRC frame size, low-bit part [15:0],	 read/write
#define P_AIU_CRC_BIT_SIZE0                        (volatile unsigned long *)0xc1105534
//20'hfffff
//how many bits have been processed right now in the current frame, read only
//high-bit part [19:16]
#define P_AIU_CRC_BIT_CNT1                         (volatile unsigned long *)0xc1105538
//low-bit part [15:0]
#define P_AIU_CRC_BIT_CNT0                         (volatile unsigned long *)0xc110553c
// -------------------------------------
// AMCLK Measurement
// -------------------------------------
// Used to measure the amclk frequency
#define P_AIU_AMCLK_GATE_HI                        (volatile unsigned long *)0xc1105540
#define P_AIU_AMCLK_GATE_LO                        (volatile unsigned long *)0xc1105544
#define P_AIU_AMCLK_MSR                            (volatile unsigned long *)0xc1105548
#define P_AIU_AUDAC_CTRL0                          (volatile unsigned long *)0xc110554c
#define P_AIU_AUDAC_CTRL1                          (volatile unsigned long *)0xc1105550
// -------------------------------------
// Super Simple Delta Sigma DAC
// -------------------------------------
// bit 15   1 = invert the clock to the analog filter
// bit 14   1 = digital mute
// bit 13   1 = enable analog mute (in the analog block)
// bit 12   1 = enable Right channel 3 in the analog block
// bit 11   1 = enable Left  channel 3 in the analog block
// bit 10   1 = enable Right channel 2 in the analog block
// bit  9   1 = enable Left  channel 2 in the analog block
// bit  8   1 = enable Right channel 1 in the analog block
// bit  7   1 = enable Left  channel 1 in the analog block
// bit  6   1 = enable Right channel 0 in the analog block
// bit  5   1 = enable Left  channel 0 in the analog block
// bit  4:  bit select for serial input data
// bit  3:  invert alrclk used by the delta-sigma DAC
// bit  2:  1 = use serial I2S data.  0 = use parallel audio data
// bits 1:0 Which data to send to the delta-sigma DAC
//              11 = use channel 3 data
//              10 = use channel 2 data
//              01 = use channel 1 data
//              00 = use channel 0 data
#define P_AIU_DELTA_SIGMA0                         (volatile unsigned long *)0xc1105554
// Delta Sigma MUTE Value
#define P_AIU_DELTA_SIGMA1                         (volatile unsigned long *)0xc1105558
// Additional Audio filter controls
#define P_AIU_DELTA_SIGMA2                         (volatile unsigned long *)0xc110555c
//Bit 14, left channel Delta Sigma modulator soft reset
//Bit 13, right channel Delta Sigma modulator soft reset
//Bit 12, left channel Delta Sigma modulator internal state clear enable when it is unstable
//Bit 11, right channel Delta Sigma modulator internal state clear enable when it is unstable
//Bit 10, left channel Delta Sigma detect unstable state enable
//Bit  9, right channel Delta Sigma detect unstable state enable
//Bit  8, dither high pass filter enable in the Delta Sigma loop
//Bit 7:6, reserved
//Bit 5:0, Delta Sigma input data gain  0/32 ~ 63/32
//default: 16'h3
#define P_AIU_DELTA_SIGMA3                         (volatile unsigned long *)0xc1105560
//15:8, Added Delta Sigma DC level, range:+-1/2, minimium: +-1/128 (assume max is -1 ~ +1)
//7:0, max same sequence number, used for unstable detection
//default: 16'h0
#define P_AIU_DELTA_SIGMA4                         (volatile unsigned long *)0xc1105564
//Bit 15:8, square wave divide num
//Bit 7:0, square wave amplitude, -1/4 ~ 1/4, minimium: +-1/1024
//default: 16'h0
#define P_AIU_DELTA_SIGMA5                         (volatile unsigned long *)0xc1105568
//Bit 11:8, loop dither amplitude2, 0/32 ~ 15/32
//Bit 7:4,  loop dither amplitude1, 0/32 ~ 15/32
//Bit 3:0,  loop dither amplitude0, 0/32 ~ 15/32
//default: 16'h0
#define P_AIU_DELTA_SIGMA6                         (volatile unsigned long *)0xc110556c
//Bit 15:8, loop dithering threshold1   0, 1/512, 2/512 ... 1/2
//Bit 7:0,  loop dithering threshold0   0, 1/512, 2/512 ... 1/2
//default: 16'h0
#define P_AIU_DELTA_SIGMA7                         (volatile unsigned long *)0xc1105570
//read only
//Bit 15:8  left channel Delta Sigma clear counter number, how many times Delta Sigma has been reseted
//          It will saturate to 255, if more than 255 time
//Bit 7:0   left channel max same sequence number
#define P_AIU_DELTA_SIGMA_LCNTS                    (volatile unsigned long *)0xc1105574
//read only
//Bit 15:8  right channel Delta Sigma clear counter number, how many times Delta Sigma has been reseted
//          It will saturate to 255, if more than 255 time
//Bit 7:0   right channel max same sequence number
#define P_AIU_DELTA_SIGMA_RCNTS                    (volatile unsigned long *)0xc1105578
// --------------------------------------------
// I2S DDR Interface
// --------------------------------------------
// The I2S start pointer into DDR memory is a 32-bit number
#define P_AIU_MEM_I2S_START_PTR                    (volatile unsigned long *)0xc1105580
#define P_AIU_MEM_I2S_RD_PTR                       (volatile unsigned long *)0xc1105584
#define P_AIU_MEM_I2S_END_PTR                      (volatile unsigned long *)0xc1105588
// There are two masks that control how data is read:
// [31:16] IRQ block.
// [15:8] chan_mem_mask.  Each bit indicates which channels exist in memory
// [7:0]  chan_rd_mask.   Each bit indicates which channels are READ from memory
#define P_AIU_MEM_I2S_MASKS                        (volatile unsigned long *)0xc110558c
// I2S FIFO Control
// bits [11:10] Select which hardware pointer to use to control the buffer
//              level:
//                  00 = parser 
//                  01 = audin_fifo0_wrpt 
//                  1x = audin_fifo1_wrpt 
// bit  [9]     Use level control: 1 = use buffer level control
// bit  [8]     Read Only.  This bit is 1 when there is data available for reading
// bit  [7]     Read only.  This bit will be high when we're fetching data from the DDR memory
//              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
//              After that you can pulse cntl_init to start over
// bit  [6]     cntl_mode_16bit:Set to 1 for 16 bit storage format in DDR
// bits [5:3]   endian:  see $lib/rtl/ddr_endian.v
// bit  [2]     cntl_empty_en   Set to 1 to enable reading data from the FIFO
// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
//                              and read masks, set this bit to 1 and then to 0
#define P_AIU_MEM_I2S_CONTROL                      (volatile unsigned long *)0xc1105590
// --------------------------------------------
// IEC958 DDR Interface
// --------------------------------------------
// The IEC958 start pointer into DDR memory is a 32-bit number
#define P_AIU_MEM_IEC958_START_PTR                 (volatile unsigned long *)0xc1105594
#define P_AIU_MEM_IEC958_RD_PTR                    (volatile unsigned long *)0xc1105598
#define P_AIU_MEM_IEC958_END_PTR                   (volatile unsigned long *)0xc110559c
// There are two masks that control how data is read:
// [15:8] chan_mem_mask.  Each bit indicates which channels exist in memory
// [7:0]  chan_rd_mask.   Each bit indicates which channels are READ from memory
#define P_AIU_MEM_IEC958_MASKS                     (volatile unsigned long *)0xc11055a0
// IEC958 FIFO Control
// bit  [31]    A_urgent
// bit  [30]    ch_always_8
// bit  [29:24] rdata_rd_base_begin ( used for select from different channel ) 
// bit  [23:14] reserved
// bit  [13]    cntl_sim_en
// bit  [12]    cntl_use_level
// bit  [11]    Read only.      This bit will be set to 1 when there is data in the FIFO to process
// bit  [10]    Read only.  This bit will be high when we're fetching data from the DDR memory
//              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
//              After that you can pulse cntl_init to start over
// bit  [9]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
//                              the FIFO to the rest of the IEC958 logic
// bit  [8]     mode_raw:       Set this bit to 1 to tell the IEC958 FIFO to read
//                              and process data linearly for raw data.  
// bit  [7]     cntl_mode_16bit:Set to 1 for 16 bit storage format in DDR.  Only valid when mode_raw = 0
// bit  [6]     cntl_rd_ddr     Set this bit to read if you want AIU_MEM_IEC958_RD_PTR and
//                              AIU_MEM_IEC958_RD_PTR_HIGH to refer to the pointer into DDR memory.
//                              Otherwise, the curr_ptr registers refer to the byte address of the data
//                              at the output of the FIFO to the rest of the IEC958 logic
// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
//                              and read masks, set this bit to 1 and then to 0
#define P_AIU_MEM_IEC958_CONTROL                   (volatile unsigned long *)0xc11055a4
// --------------------------------------------
// AIFIFO2 DDR Interface
// --------------------------------------------
// The AIFIFO2 start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_AIU_MEM_AIFIFO2_START_PTR                (volatile unsigned long *)0xc11055a8
// The current pointer points so some location between the START and END 
// pointers.  The current pointer is a BYTE pointer.  That is, you can 
// point to any BYTE address within the START/END range
#define P_AIU_MEM_AIFIFO2_CURR_PTR                 (volatile unsigned long *)0xc11055ac
#define P_AIU_MEM_AIFIFO2_END_PTR                  (volatile unsigned long *)0xc11055b0
#define P_AIU_MEM_AIFIFO2_BYTES_AVAIL              (volatile unsigned long *)0xc11055b4
// AIFIFO2 FIFO Control
// bit  [15:11] unused
// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
// bit  [9]     Data Ready.     This bit is set when data can be popped
// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
//                              After that you can pulse cntl_init to start over
// bit  [7]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
//                              the FIFO to getbit
// bit  [6]     unused  
// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
//                              and read masks, set this bit to 1 and then to 0
//                              NOTE:  You don't need to pulse cntl_init if only the start address is
//                              being changed
#define P_AIU_MEM_AIFIFO2_CONTROL                  (volatile unsigned long *)0xc11055b8
// --------------------------------------------
// AIFIFO2 Buffer Level Manager
// --------------------------------------------
#define P_AIU_MEM_AIFIFO2_MAN_WP                   (volatile unsigned long *)0xc11055bc
#define P_AIU_MEM_AIFIFO2_MAN_RP                   (volatile unsigned long *)0xc11055c0
#define P_AIU_MEM_AIFIFO2_LEVEL                    (volatile unsigned long *)0xc11055c4
//
// bit  [1]     manual mode     Set to 1 for manual write pointer mode
// bit  [0]     Init            Set high then low after everything has been initialized
#define P_AIU_MEM_AIFIFO2_BUF_CNTL                 (volatile unsigned long *)0xc11055c8
// --------------------------------------------
// I2S Buffer Level Manager
// --------------------------------------------
#define P_AIU_MEM_I2S_MAN_WP                       (volatile unsigned long *)0xc11055cc
#define P_AIU_MEM_I2S_MAN_RP                       (volatile unsigned long *)0xc11055d0
#define P_AIU_MEM_I2S_LEVEL                        (volatile unsigned long *)0xc11055d4
//
// bit  [1]     mode            0 = parser (or audin_fifo0 or audin_fifo1), 
//                              1 for manual write pointer 
// bit  [0]     Init            Set high then low after everything has been initialized
#define P_AIU_MEM_I2S_BUF_CNTL                     (volatile unsigned long *)0xc11055d8
#define P_AIU_MEM_I2S_BUF_WRAP_COUNT               (volatile unsigned long *)0xc11055dc
// bit 29:24 A_brst_num
// bit 21:16 A_id
// bit 15:0 level_hold 
#define P_AIU_MEM_I2S_MEM_CTL                      (volatile unsigned long *)0xc11055e0
//-----------------------------------------------------------------------------
// Additional IEC958 registers (new feature)
//-----------------------------------------------------------------------------
// bit 29:24 A_brst_num
// bit 21:16 A_id
// bit 15:0 level_hold 
#define P_AIU_MEM_IEC958_MEM_CTL                   (volatile unsigned long *)0xc11055e4
#define P_AIU_MEM_IEC958_WRAP_COUNT                (volatile unsigned long *)0xc11055e8
#define P_AIU_MEM_IEC958_IRQ_LEVEL                 (volatile unsigned long *)0xc11055ec
#define P_AIU_MEM_IEC958_MAN_WP                    (volatile unsigned long *)0xc11055f0
#define P_AIU_MEM_IEC958_MAN_RP                    (volatile unsigned long *)0xc11055f4
#define P_AIU_MEM_IEC958_LEVEL                     (volatile unsigned long *)0xc11055f8
#define P_AIU_MEM_IEC958_BUF_CNTL                  (volatile unsigned long *)0xc11055fc
//-----------------------------------------------------------------------------
// add for AIFIFO channel (old $cdrom/rtl/cdr_top/getbit)
//-----------------------------------------------------------------------------
// Bit 3 	CRC pop aififo enable
// Bit 2		writing to this bit to 1 causes CRC module reset
// Bit 1		enable aififo
// Bit 0		writing to this bit to 1 causes aififo soft reset
#define P_AIU_AIFIFO_CTRL                          (volatile unsigned long *)0xc1105600
//'h0000
// AIFIFO status register
// Bit 13		//aififo request to dcu status
// Bit 12		//dcu select status
// Bit 11:5		//aififo word counter number 
// Bit 4:0		//how many bits left in the first pop register
#define P_AIU_AIFIFO_STATUS                        (volatile unsigned long *)0xc1105604
// Same fucntion as the AIGBIT of AIFIFO in CDROM module
// write to this register how many bits wanna pop, 
// and reading this register gets the corresponding bits data
#define P_AIU_AIFIFO_GBIT                          (volatile unsigned long *)0xc1105608
// Same function as the AICLB of AIFIFO in CDROM module
// return the leading zeros by reading this registers
#define P_AIU_AIFIFO_CLB                           (volatile unsigned long *)0xc110560c
// --------------------------------------------
// AIFIFO DDR Interface
// --------------------------------------------
// The AIFIFO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_AIU_MEM_AIFIFO_START_PTR                 (volatile unsigned long *)0xc1105610
// The current pointer points so some location between the START and END 
// pointers.  The current pointer is a BYTE pointer.  That is, you can 
// point to any BYTE address within the START/END range
#define P_AIU_MEM_AIFIFO_CURR_PTR                  (volatile unsigned long *)0xc1105614
#define P_AIU_MEM_AIFIFO_END_PTR                   (volatile unsigned long *)0xc1105618
#define P_AIU_MEM_AIFIFO_BYTES_AVAIL               (volatile unsigned long *)0xc110561c
// AIFIFO FIFO Control
// bit  [15:11] unused
// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
// bit  [9]     Data Ready.     This bit is set when data can be popped
// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
//                              After that you can pulse cntl_init to start over
// bit  [7]     cntl_endian_jic Just in case endian.  last minute byte swap of the data out of
//                              the FIFO to getbit
// bit  [6]     unused  
// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO and filling the pipeline to get-bit
//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
//                              and read masks, set this bit to 1 and then to 0
//                              NOTE:  You don't need to pulse cntl_init if only the start address is
//                              being changed
#define P_AIU_MEM_AIFIFO_CONTROL                   (volatile unsigned long *)0xc1105620
// --------------------------------------------
// AIFIFO Buffer Level Manager
// --------------------------------------------
#define P_AIU_MEM_AIFIFO_MAN_WP                    (volatile unsigned long *)0xc1105624
#define P_AIU_MEM_AIFIFO_MAN_RP                    (volatile unsigned long *)0xc1105628
#define P_AIU_MEM_AIFIFO_LEVEL                     (volatile unsigned long *)0xc110562c
//
// bit  [1]     manual mode     Set to 1 for manual write pointer mode
// bit  [0]     Init            Set high then low after everything has been initialized
#define P_AIU_MEM_AIFIFO_BUF_CNTL                  (volatile unsigned long *)0xc1105630
#define P_AIU_MEM_AIFIFO_BUF_WRAP_COUNT            (volatile unsigned long *)0xc1105634
#define P_AIU_MEM_AIFIFO2_BUF_WRAP_COUNT           (volatile unsigned long *)0xc1105638
// bit 29:24 A_brst_num
// bit 21:16 A_id
// bit 15:0 level_hold 
#define P_AIU_MEM_AIFIFO_MEM_CTL                   (volatile unsigned long *)0xc110563c
// bit 31:16 -- drop_bytes
// bit 15:14 -- drop_status (Read-Only)
// bit 13:12 -- sync_match_position (Read-Only)
// bit 11:6 -- reserved
// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
// bit 3 -- stamp_soft_reset
// bit 2 -- TIME_STAMP_length_enable
// bit 1 -- TIME_STAMP_sync64_enable
// bit 0 -- TIME_STAMP_enable
#define P_AIFIFO_TIME_STAMP_CNTL                   (volatile unsigned long *)0xc1105640
// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
#define P_AIFIFO_TIME_STAMP_SYNC_0                 (volatile unsigned long *)0xc1105644
// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
#define P_AIFIFO_TIME_STAMP_SYNC_1                 (volatile unsigned long *)0xc1105648
// bit 31:0 TIME_STAMP_0
#define P_AIFIFO_TIME_STAMP_0                      (volatile unsigned long *)0xc110564c
// bit 31:0 TIME_STAMP_1
#define P_AIFIFO_TIME_STAMP_1                      (volatile unsigned long *)0xc1105650
// bit 31:0 TIME_STAMP_2
#define P_AIFIFO_TIME_STAMP_2                      (volatile unsigned long *)0xc1105654
// bit 31:0 TIME_STAMP_3
#define P_AIFIFO_TIME_STAMP_3                      (volatile unsigned long *)0xc1105658
// bit 31:0 TIME_STAMP_LENGTH
#define P_AIFIFO_TIME_STAMP_LENGTH                 (volatile unsigned long *)0xc110565c
// bit 31:16 -- drop_bytes
// bit 15:14 -- drop_status (Read-Only)
// bit 13:12 -- sync_match_position (Read-Only)
// bit 11:6 -- reserved
// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
// bit 3 -- stamp_soft_reset
// bit 2 -- TIME_STAMP_length_enable
// bit 1 -- TIME_STAMP_sync64_enable
// bit 0 -- TIME_STAMP_enable
#define P_AIFIFO2_TIME_STAMP_CNTL                  (volatile unsigned long *)0xc1105660
// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
#define P_AIFIFO2_TIME_STAMP_SYNC_0                (volatile unsigned long *)0xc1105664
// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
#define P_AIFIFO2_TIME_STAMP_SYNC_1                (volatile unsigned long *)0xc1105668
// bit 31:0 TIME_STAMP_0
#define P_AIFIFO2_TIME_STAMP_0                     (volatile unsigned long *)0xc110566c
// bit 31:0 TIME_STAMP_1
#define P_AIFIFO2_TIME_STAMP_1                     (volatile unsigned long *)0xc1105670
// bit 31:0 TIME_STAMP_2
#define P_AIFIFO2_TIME_STAMP_2                     (volatile unsigned long *)0xc1105674
// bit 31:0 TIME_STAMP_3
#define P_AIFIFO2_TIME_STAMP_3                     (volatile unsigned long *)0xc1105678
// bit 31:0 TIME_STAMP_LENGTH
#define P_AIFIFO2_TIME_STAMP_LENGTH                (volatile unsigned long *)0xc110567c
// bit 31:16 -- drop_bytes
// bit 15:14 -- drop_status (Read-Only)
// bit 13:12 -- sync_match_position (Read-Only)
// bit 11:6 -- reserved
// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
// bit 3 -- stamp_soft_reset
// bit 2 -- TIME_STAMP_length_enable
// bit 1 -- TIME_STAMP_sync64_enable
// bit 0 -- TIME_STAMP_enable
#define P_IEC958_TIME_STAMP_CNTL                   (volatile unsigned long *)0xc1105680
// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
#define P_IEC958_TIME_STAMP_SYNC_0                 (volatile unsigned long *)0xc1105684
// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
#define P_IEC958_TIME_STAMP_SYNC_1                 (volatile unsigned long *)0xc1105688
// bit 31:0 TIME_STAMP_0
#define P_IEC958_TIME_STAMP_0                      (volatile unsigned long *)0xc110568c
// bit 31:0 TIME_STAMP_1
#define P_IEC958_TIME_STAMP_1                      (volatile unsigned long *)0xc1105690
// bit 31:0 TIME_STAMP_2
#define P_IEC958_TIME_STAMP_2                      (volatile unsigned long *)0xc1105694
// bit 31:0 TIME_STAMP_3
#define P_IEC958_TIME_STAMP_3                      (volatile unsigned long *)0xc1105698
// bit 31:0 TIME_STAMP_LENGTH
#define P_IEC958_TIME_STAMP_LENGTH                 (volatile unsigned long *)0xc110569c
// bit 29:24 A_brst_num
// bit 21:16 A_id
// bit 15:0 level_hold 
#define P_AIU_MEM_AIFIFO2_MEM_CTL                  (volatile unsigned long *)0xc11056a0
//
// Closing file:  aregs.h
//
//========================================================================
//  CDROM Interface                                 (12'h600 - 12'h6ff)
//
//========================================================================
#define P_AIADR                                    (volatile unsigned long *)0xc1105ce0
#define P_AICSR                                    (volatile unsigned long *)0xc1105ce4
#define P_AIDAT                                    (volatile unsigned long *)0xc1105ce8
#define P_AIGBIT                                   (volatile unsigned long *)0xc1105cec
#define P_AICLB                                    (volatile unsigned long *)0xc1105cf0
//========================================================================
// SDIO interface
//========================================================================
#define P_HD0                                      (volatile unsigned long *)0xc1105e00
#define P_HD1                                      (volatile unsigned long *)0xc1105e04
#define P_SHD0                                     (volatile unsigned long *)0xc1105e08
#define P_SHD1                                     (volatile unsigned long *)0xc1105e0c
#define P_SYND                                     (volatile unsigned long *)0xc1105e10
#define P_ECDCT                                    (volatile unsigned long *)0xc1105e14
#define P_ECDSTAT                                  (volatile unsigned long *)0xc1105e18
#define P_CTR0                                     (volatile unsigned long *)0xc1105e1c
#define P_CTR1                                     (volatile unsigned long *)0xc1105e20
#define P_CTR2                                     (volatile unsigned long *)0xc1105e24
#define P_STAT0                                    (volatile unsigned long *)0xc1105e28
#define P_INT                                      (volatile unsigned long *)0xc1105e2c
#define P_TCTR0                                    (volatile unsigned long *)0xc1105e30
#define P_TSTAT0                                   (volatile unsigned long *)0xc1105e34
#define P_TSTAT1                                   (volatile unsigned long *)0xc1105e38
//========================================================================
//	registers for video postprocessing (12'h800 - 12'h87f)
//========================================================================
//
// Reading file:  vpp_regs.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// CBUS_BASE:  VPP_CBUS_BASE = 0x1d
// -----------------------------------------------
//===========================================================================
// Video postprocesing Registers 
//===========================================================================
// dummy data used in the VPP preblend and scaler
// Bit 23:16    Y
// Bit 15:8     CB
// Bit 7:0      CR 
#define P_VPP_DUMMY_DATA                           (volatile unsigned long *)0xc1107400
//input line length used in VPP
#define P_VPP_LINE_IN_LENGTH                       (volatile unsigned long *)0xc1107404
//input Picture height used in VPP
#define P_VPP_PIC_IN_HEIGHT                        (volatile unsigned long *)0xc1107408
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients 
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8	    type of index, 0: vertical coef
//						   1: horizontal coef
//Bit 6:0 	coef index
#define P_VPP_SCALE_COEF_IDX                       (volatile unsigned long *)0xc110740c
//coefficients for vertical filter and horizontal filter
#define P_VPP_SCALE_COEF                           (volatile unsigned long *)0xc1107410
//these following registers are the absolute line address pointer for output divided screen
//The output divided screen is shown in the following:
//
//  --------------------------   <------ line zero
//		. 
//		.
//		.		    region0        <---------- nonlinear region or nonscaling region	
//		.
//  ---------------------------  
//  ---------------------------  <------ region1_startp 
//		.
//		.           region1         <---------- nonlinear region
//		.
//		.
//  ---------------------------  
//  ---------------------------  <------ region2_startp
//		.
//		.           region2         <---------- linear region
//		.
//		.
//  ---------------------------  
//  ---------------------------  <------ region3_startp
//		.
//		.           region3         <---------- nonlinear region
//		.
//		.
//  ---------------------------  
//  ---------------------------  <------ region4_startp
//		.
//		.           region4         <---------- nonlinear region or nonoscaling region
//		.
//		.
//  ---------------------------  <------ region4_endp
//Bit 27:16 region1 startp
//Bit 11:0 region2 startp
#define P_VPP_VSC_REGION12_STARTP                  (volatile unsigned long *)0xc1107414
//Bit 27:16 region3 startp
//Bit 11:0 region4 startp
#define P_VPP_VSC_REGION34_STARTP                  (volatile unsigned long *)0xc1107418
#define P_VPP_VSC_REGION4_ENDP                     (volatile unsigned long *)0xc110741c
//vertical start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part 
//Bit 23:0	fraction part
#define P_VPP_VSC_START_PHASE_STEP                 (volatile unsigned long *)0xc1107420
//vertical scaler region0 phase slope, Bit24 signed bit
#define P_VPP_VSC_REGION0_PHASE_SLOPE              (volatile unsigned long *)0xc1107424
//vertical scaler region1 phase slope, Bit24 signed bit
#define P_VPP_VSC_REGION1_PHASE_SLOPE              (volatile unsigned long *)0xc1107428
//vertical scaler region3 phase slope, Bit24 signed bit
#define P_VPP_VSC_REGION3_PHASE_SLOPE              (volatile unsigned long *)0xc110742c
//vertical scaler region4 phase slope, Bit24 signed bit
#define P_VPP_VSC_REGION4_PHASE_SLOPE              (volatile unsigned long *)0xc1107430
//Bit 16     0: progressive output, 1: interlace output
//Bit 15     vertical scaler output line0 in advance or not for bottom field
//Bit 14:13  vertical scaler initial repeat line0 number for bottom field
//Bit 11:8   vertical scaler initial receiving  number for bottom field   
//Bit 7      vertical scaler output line0 in advance or not for top field
//Bit 6:5    vertical scaler initial repeat line0 number for top field
//Bit 3:0    vertical scaler initial receiving  number for top field   
#define P_VPP_VSC_PHASE_CTRL                       (volatile unsigned long *)0xc1107434
//Bit 31:16  vertical scaler field initial phase for bottom field
//Bit 15:0  vertical scaler field initial phase for top field
#define P_VPP_VSC_INI_PHASE                        (volatile unsigned long *)0xc1107438
//Bit 27:16 region1 startp
//Bit 11:0 region2 startp
#define P_VPP_HSC_REGION12_STARTP                  (volatile unsigned long *)0xc1107440
//Bit 27:16 region3 startp
//Bit 11:0 region4 startp
#define P_VPP_HSC_REGION34_STARTP                  (volatile unsigned long *)0xc1107444
#define P_VPP_HSC_REGION4_ENDP                     (volatile unsigned long *)0xc1107448
//horizontal start phase step, (source/dest)*(2^24)
//Bit 27:24 integer part 
//Bit 23:0	fraction part
#define P_VPP_HSC_START_PHASE_STEP                 (volatile unsigned long *)0xc110744c
//horizontal scaler region0 phase slope, Bit24 signed bit
#define P_VPP_HSC_REGION0_PHASE_SLOPE              (volatile unsigned long *)0xc1107450
//horizontal scaler region1 phase slope, Bit24 signed bit
#define P_VPP_HSC_REGION1_PHASE_SLOPE              (volatile unsigned long *)0xc1107454
//horizontal scaler region3 phase slope, Bit24 signed bit
#define P_VPP_HSC_REGION3_PHASE_SLOPE              (volatile unsigned long *)0xc1107458
//horizontal scaler region4 phase slope, Bit24 signed bit
#define P_VPP_HSC_REGION4_PHASE_SLOPE              (volatile unsigned long *)0xc110745c
//Bit 22:21   horizontal scaler initial repeat pixel0 number
//Bit 19:16   horizontal scaler initial receiving number   
//Bit 15:0    horizontal scaler top field initial phase
#define P_VPP_HSC_PHASE_CTRL                       (volatile unsigned long *)0xc1107460
// Bit 20 prehsc_en
// Bit 19 prevsc_en
// Bit 18 vsc_en
// Bit 17 hsc_en
// Bit 16 scale_top_en
// Bit 15 video1 scale out enable
// Bit 12 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for horizontal scaler 
// Bit 10:8 horizontal scaler bank length
// Bit 5, vertical scaler phase field mode, if true, disable the opposite parity line output, more bandwith needed if output 1080i
// Bit 4 if true, region0,region4 are nonlinear regions, otherwise they are not scaling regions, for vertical scaler 
// Bit 2:0 vertical scaler bank length
#define P_VPP_SC_MISC                              (volatile unsigned long *)0xc1107464
// preblend video1 horizontal start and end
//Bit 27:16 start
//Bit 11:0 end
#define P_VPP_PREBLEND_VD1_H_START_END             (volatile unsigned long *)0xc1107468
// preblend video1 vertical start and end
//Bit 27:16 start
//Bit 11:0 end
#define P_VPP_PREBLEND_VD1_V_START_END             (volatile unsigned long *)0xc110746c
// postblend video1 horizontal start and end
//Bit 27:16 start
//Bit 11:0 end
#define P_VPP_POSTBLEND_VD1_H_START_END            (volatile unsigned long *)0xc1107470
// postblend video1 vertical start and end
//Bit 27:16 start
//Bit 11:0 end
#define P_VPP_POSTBLEND_VD1_V_START_END            (volatile unsigned long *)0xc1107474
// preblend/postblend video2 horizontal start and end
//Bit 27:16 start
//Bit 11:0 end
#define P_VPP_BLEND_VD2_H_START_END                (volatile unsigned long *)0xc1107478
// preblend/postblend video2 vertical start and end
//Bit 27:16 start
//Bit 11:0 end
#define P_VPP_BLEND_VD2_V_START_END                (volatile unsigned long *)0xc110747c
// preblend horizontal size
#define P_VPP_PREBLEND_H_SIZE                      (volatile unsigned long *)0xc1107480
// postblend horizontal size
#define P_VPP_POSTBLEND_H_SIZE                     (volatile unsigned long *)0xc1107484
//VPP hold lines
//Bit 29:24
//Bit 21:16
//Bit 13:8     preblend hold lines
//Bit 5:0      postblend hold lines
#define P_VPP_HOLD_LINES                           (volatile unsigned long *)0xc1107488
//Bit 25   if true, change screen to one color value for preblender
//Bit 24   if true, change screen to one color value for postblender
// Bit 23:16 one color Y
// Bit 15:8 one color Cb
// Bit  7:0 one color  Cr
#define P_VPP_BLEND_ONECOLOR_CTRL                  (volatile unsigned long *)0xc110748c
//Read Only, VPP preblend current_x, current_y
//Bit 27:16 current_x
//Bit 11:0 current_y
#define P_VPP_PREBLEND_CURRENT_XY                  (volatile unsigned long *)0xc1107490
//Read Only, VPP postblend current_x, current_y
//Bit 27:16 current_x
//Bit 11:0 current_y
#define P_VPP_POSTBLEND_CURRENT_XY                 (volatile unsigned long *)0xc1107494
// bit 28   color management enable
// Bit 26:18, vd2 alpha
// Bit 17, osd2 enable for preblend
// Bit 16, osd1 enable for preblend
// Bit 15, vd2 enable for preblend
// Bit 14, vd1 enable for preblend
// Bit 13, osd2 enable for postblend
// Bit 12, osd1 enable for postblend
// Bit 11, vd2 enable for postblend
// Bit 10, vd1 enable for postblend
// Bit 9,  if true, osd1 is alpha premultipiled 
// Bit 8,  if true, osd2 is alpha premultipiled 
// Bit 7,  postblend module enable
// Bit 6,  preblend module enable
// Bit 5,  if true, osd2 foreground compared with osd1 in preblend
// Bit 4,  if true, osd2 foreground compared with osd1 in postblend
// Bit 3,  
// Bit 2,  if true, disable resetting async fifo every vsync, otherwise every vsync
//			 the aync fifo will be reseted.
// Bit 1,	  
// Bit 0	if true, the output result of VPP is saturated
#define P_VPP_MISC                                 (volatile unsigned long *)0xc1107498
//Bit 31:20 ofifo line length minus 1
//Bit 19  if true invert input vs
//Bit 18  if true invert input hs
//Bit 17  force top/bottom field, enable
//Bit 16  force top/bottom field, 0: top, 1: bottom
//Bit 15  force one go_field, one pluse, write only
//Bit 14  force one go_line, one pluse, write only
//Bit 11:0 ofifo size (actually only bit 9:1 is valid), always even number
#define P_VPP_OFIFO_SIZE                           (volatile unsigned long *)0xc110749c
//Read only
//Bit 26:17 current scale out fifo counter
//Bit 16:12 current afifo counter
//Bit 11:0 current ofifo counter
#define P_VPP_FIFO_STATUS                          (volatile unsigned long *)0xc11074a0
// Bit 5 SMOKE3 postblend enable only when postblend vd2 is not enable 
// Bit 4 SMOKE3 preblend enable only when preblend vd2 is not enable 
// Bit 3 SMOKE2 postblend enable only when postblend osd2 is not enable 
// Bit 2 SMOKE2 preblend enable only when preblend osd2 is not enable 
// Bit 1 SMOKE1 postblend enable only when postblend osd1 is not enable 
// Bit 0 SMOKE1 preblend enable only when preblend osd1 is not enable 
#define P_VPP_SMOKE_CTRL                           (volatile unsigned long *)0xc11074a4
//smoke can be used only when that blending is disable and then be used as smoke function
//smoke1 for OSD1 chanel
//smoke2 for OSD2 chanel
//smoke3 for VD2 chanel
//31:24 Y
//23:16 Cb
//15:8 Cr
//7:0 Alpha
#define P_VPP_SMOKE1_VAL                           (volatile unsigned long *)0xc11074a8
#define P_VPP_SMOKE2_VAL                           (volatile unsigned long *)0xc11074ac
#define P_VPP_SMOKE3_VAL                           (volatile unsigned long *)0xc11074b0
//Bit 27:16 start
//Bit 11:0 end
#define P_VPP_SMOKE1_H_START_END                   (volatile unsigned long *)0xc11074b4
//Bit 27:16 start
//Bit 11:0 end
#define P_VPP_SMOKE1_V_START_END                   (volatile unsigned long *)0xc11074b8
//Bit 27:16 start
//Bit 11:0 end
#define P_VPP_SMOKE2_H_START_END                   (volatile unsigned long *)0xc11074bc
//Bit 27:16 start
//Bit 11:0 end
#define P_VPP_SMOKE2_V_START_END                   (volatile unsigned long *)0xc11074c0
//Bit 27:16 start
//Bit 11:0 end
#define P_VPP_SMOKE3_H_START_END                   (volatile unsigned long *)0xc11074c4
//Bit 27:16 start
//Bit 11:0 end
#define P_VPP_SMOKE3_V_START_END                   (volatile unsigned long *)0xc11074c8
//Bit 27:16 scale out fifo line length minus 1
//Bit 9:0 scale out fifo size (actually only bit 9:1 is valid), always even number
#define P_VPP_SCO_FIFO_CTRL                        (volatile unsigned long *)0xc11074cc
//Bit 3			minus black level enable for vadj2
//Bit 2			Video adjustment enable for vadj2
//Bit 1			minus black level enable for vadj1
//Bit 0			Video adjustment enable for vadj1
#define P_VPP_VADJ_CTRL                            (volatile unsigned long *)0xc1107500
//Bit 16:8  brightness, signed value
//Bit 7:0	contrast, unsigned value, contrast from  0 <= contrast <2
#define P_VPP_VADJ1_Y                              (volatile unsigned long *)0xc1107504
//cb' = cb*ma + cr*mb
//cr' = cb*mc + cr*md
//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
#define P_VPP_VADJ1_MA_MB                          (volatile unsigned long *)0xc1107508
#define P_VPP_VADJ1_MC_MD                          (volatile unsigned long *)0xc110750c
//Bit 16:8  brightness, signed value
//Bit 7:0	contrast, unsigned value, contrast from  0 <= contrast <2
#define P_VPP_VADJ2_Y                              (volatile unsigned long *)0xc1107510
//cb' = cb*ma + cr*mb
//cr' = cb*mc + cr*md
//all are bit 9:0, signed value, -2 < ma/mb/mc/md < 2
#define P_VPP_VADJ2_MA_MB                          (volatile unsigned long *)0xc1107514
#define P_VPP_VADJ2_MC_MD                          (volatile unsigned long *)0xc1107518
//Bit 2 horizontal chroma sharp/blur selection, 0:sharp, 1: blur  
//Bit 1 horizontal luma sharp/blur selection, 0:sharp, 1: blur  
//Bit 0 horizontal sharpness enable
#define P_VPP_HSHARP_CTRL                          (volatile unsigned long *)0xc1107540
//{1'b0,threhsold} < diff
//Bit 26:16  luma threshold0
//Bit 10:0   luma threshold1    
#define P_VPP_HSHARP_LUMA_THRESH01                 (volatile unsigned long *)0xc1107544
//
//Bit 26:16  luma threshold2
//Bit 10:0   luma threshold3    
#define P_VPP_HSHARP_LUMA_THRESH23                 (volatile unsigned long *)0xc1107548
//Bit 26:16  chroma threshold0
//Bit 10:0   chroma threshold1    
#define P_VPP_HSHARP_CHROMA_THRESH01               (volatile unsigned long *)0xc110754c
//Bit 26:16  chroma threshold2
//Bit 10:0   chroma threshold3    
#define P_VPP_HSHARP_CHROMA_THRESH23               (volatile unsigned long *)0xc1107550
//Bit 23:16 luma gain2
//Bit 15:8  luma gain1
//Bit 7:0   luma gain0
#define P_VPP_HSHARP_LUMA_GAIN                     (volatile unsigned long *)0xc1107554
//
//Bit 23:16 chroma gain2
//Bit 15:8  chroma gain1
//Bit 7:0   chroma gain0
#define P_VPP_HSHARP_CHROMA_GAIN                   (volatile unsigned long *)0xc1107558
//Bit 9:8  matrix coef idx selection, 00: select post matrix, 01: select vd1 matrix, 10: select vd2 matrix
//Bit 5    vd1 conversion matrix enable
//Bit 4    vd2 conversion matrix enable
//Bit 2    output y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
//Bit 1    input y/cb/cr saturation enable, only for post matrix (y saturate to 16-235, cb/cr saturate to 16-240)
//Bit 0    post conversion matrix enable
#define P_VPP_MATRIX_CTRL                          (volatile unsigned long *)0xc110757c
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_VPP_MATRIX_COEF00_01                     (volatile unsigned long *)0xc1107580
//Bit 28:16 coef02 
//Bit 12:0  coef10 
#define P_VPP_MATRIX_COEF02_10                     (volatile unsigned long *)0xc1107584
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_VPP_MATRIX_COEF11_12                     (volatile unsigned long *)0xc1107588
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_VPP_MATRIX_COEF20_21                     (volatile unsigned long *)0xc110758c
#define P_VPP_MATRIX_COEF22                        (volatile unsigned long *)0xc1107590
//Bit 26:16 offset0
//Bit 10:0  offset1
#define P_VPP_MATRIX_OFFSET0_1                     (volatile unsigned long *)0xc1107594
//Bit 10:0  offset2
#define P_VPP_MATRIX_OFFSET2                       (volatile unsigned long *)0xc1107598
//Bit 26:16 pre_offset0
//Bit 10:0  pre_offset1
#define P_VPP_MATRIX_PRE_OFFSET0_1                 (volatile unsigned long *)0xc110759c
//Bit 10:0  pre_offset2
#define P_VPP_MATRIX_PRE_OFFSET2                   (volatile unsigned long *)0xc11075a0
// dummy data used in the VPP postblend
// Bit 23:16    Y
// Bit 15:8     CB
// Bit 7:0      CR 
#define P_VPP_DUMMY_DATA1                          (volatile unsigned long *)0xc11075a4
//Bit 31 gainoff module enable
//Bit 26:16 gain0, 1.10 unsigned data
//Bit 10:0  gain1, 1.10 unsigned dat
#define P_VPP_GAINOFF_CTRL0                        (volatile unsigned long *)0xc11075a8
//Bit 26:16 gain2, 1.10 unsigned data
//Bit 10:0, offset0, signed data
#define P_VPP_GAINOFF_CTRL1                        (volatile unsigned long *)0xc11075ac
//Bit 26:16, offset1, signed data
//Bit 10:0, offset2, signed data
#define P_VPP_GAINOFF_CTRL2                        (volatile unsigned long *)0xc11075b0
//Bit 26:16, pre_offset0, signed data 
//Bit 10:0, pre_offset1, signed data 
#define P_VPP_GAINOFF_CTRL3                        (volatile unsigned long *)0xc11075b4
//Bit 10:0, pre_offset2, signed data 
#define P_VPP_GAINOFF_CTRL4                        (volatile unsigned long *)0xc11075b8
//only two registers used in the color management, which are defined in the chroma_reg.h
//`define VPP_CHROMA_ADDR_PORT    8'h70
//`define VPP_CHROMA_DATA_PORT    8'h71
//
// Reading file:  chroma_reg.h
//
//**********************************************************************************
//* Copyright (c) 2008, AMLOGIC Inc.
//* All rights reserved
//**********************************************************************************
//* File :  chroma_reg.v
//* Author : Terrence Wang
//* Date : Dec 2008
//* Description :  
//*
//********************************************************************************** 
//* Modification History:
//* Date    Modified By         Reason
//**********************************************************************************
// synopsys translate_off
// synopsys translate_on
#define P_VPP_CHROMA_ADDR_PORT                     (volatile unsigned long *)0xc11075c0
#define P_VPP_CHROMA_DATA_PORT                     (volatile unsigned long *)0xc11075c4
//`define CHROMA_ADDR_PORT        8'h67
//`define CHROMA_DATA_PORT        8'h68

//  CHROMA_GAIN_REG_XX(00-07)
//  hue gain, sat gain function control
//  Bit 31      reg_sat_en                  enable sat adjustment in current region
//  Bit 27      reg_sat_increase            sat adjustment increase or decrease
//                                          1'b1: increase  1'b0: decrease
//  Bit 26:25   reg_sat_central_en          sat adjustment with central biggest or one side biggest
//                                          2'b01 central biggest   2'b00 one side biggest
//  Bit 24      reg_sat_shape               when sat adjustment one side biggest, define left or right
//                                          1'b1: left side biggest 1'b0 right side biggest  
//  Bit 23:16   reg_sat_gain                define the sat gain when sat adjustment
//                                          0x00-0xff
//  Bit 15      reg_hue_en                  enable hue adjustment in current region
//  Bit 11      reg_hue_clockwise           hue adjustment clockwise or anti-clockwise
//                                          1'b1: clockwise 1'b0: anti-clockwise
//  Bit 10:9    reg_hue_central_en          when hue adjustment, parabola curve or non-symmetry curve
//                                          1'b1: parabola curve    1'b0: non-symmetry curve
//  Bit 8       reg_hue_shape               when non-symmetry curve, define which side change more
//                                          1'b1: right side change more    1'b0: left side change more
//  Bit 7:0     reg_hue_gain                define the hue gain when hue adjustment
//                                          0x00-0x80, note: should be no bigger than 0x80

    #define CHROMA_GAIN_REG00       0x00


//  HUE_HUE_RANGE_REG_XX(00-07)
//  hue range select
//  Bit 31:24   no use now
//  Bit 23:16   reg_hue_shift_range         define the angle of target region
//                                          0x00-0xff,(0x100 means 120 degree though it can not be set)
//                                          must be greater or equal than 8'd8
//  Bit 15      reg_symmetry_en             this is used for create one symmetry region
//                                          the symmetry region hue_shift_start = reg_hue_hue_shift_start + reg_hue_shift_range<<5
//                                          the symmetry region hue_shift_range = reg_hue_shift_range
//                                          in symmetry region, all the sat and hue setting will be same with original region, 
//                                          except reg_hue_shape, reg_sat_shape, reg_hue_clockwise will be reversed
//  Bit 14:0    reg_hue_hue_shift_start     define the start angle of target region
//                                          0x6000 means 360 degree
//                                          only region 0 and 1 can exceed 360 degrees.

    #define HUE_HUE_RANGE_REG00     0x01


//  HUE_RANGE_INV_REG_XX
//  Calculation should be follow
//  HUE_RANGE_INV_REG0X[15:0] = ((1<<20)/HUE_HUE_RANGE_REG0X[23:16]+1)>>1
//  HUE_RANGE_INV_REG_XX is to used to save divider

    #define HUE_RANGE_INV_REG00     0x02



//  for belowing each low, high, low_slope, high_slope group:
//            a_____________b
//            /             \               a = low  + 2^low_slope
//           /               \              b = high - 2^high_slope
//          /                 \             low_slope <= 7; high_slope <= 7
//         /                   \            b >= a
//  ______/_____________________\________
//       low                    high
//
//
//  HUE_LUM_RANGE_REG_XX(00-07)
//  luma range selection for hue adjustment
//  Bit 31:24   reg_sat_lum_low             define the low level of luma value for sat adjustment
//                                          0x00-0xff
//  Bit 23:20   reg_hue_lum_high_slope      define the slope area below high level of luma value for hue adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_hue_lum_low_slope       define the slope area above low  level of luma value for hue adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_hue_lum_high            define the high level of luma value for hue adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_hue_lum_low             define the low  level of luma value for hue adjustment
//                                          0x00-0xff

    #define HUE_LUM_RANGE_REG00     0x03

//  HUE_SAT_RANGE_REG_XX(00-07)
//  sat range selection for hue adjustment
//  Bit 31:24   reg_sat_lum_high            define the high level of luma value for sat adjustment
//                                          0x00-0xff
//  Bit 23:20   reg_hue_sat_high_slope      define the slope area below high level of sat value for hue adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_hue_sat_low_slope       define the slope area above low  level of sat value for hue adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_hue_sat_high            define the high level of sat value for hue adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_hue_sat_low             define the low  level of sat value for hue adjustment
//                                          0x00-0xff

    #define HUE_SAT_RANGE_REG00     0x04

//  SAT_SAT_RANGE_REG_XX(00-07)
//  sat range selection for hue adjustment
//  Bit 31:28   reg_sat_lum_high_slope      define the slope area below high level of luma value for sat adjustment
//                                          0x00-0x07
//  Bit 27:24   reg_sat_lum_low_slope       define the slope area above low  level of luma value for sat adjustment
//                                          0x00-0x07
//  Bit 23:20   reg_sat_sat_high_slope      define the slope area below high level of sat value for sat adjustment
//                                          0x00-0x07
//  Bit 19:16   reg_sat_sat_low_slope       define the slope area above low  level of sat value for sat adjustment
//                                          0x00-0x07
//  Bit 15:8    reg_sat_sat_high            define the high level of sat value for sat adjustment
//                                          0x00-0xff
//  Bit 7:0     reg_sat_sat_low             define the low  level of sat value for sat adjustment
//                                          0x00-0xff

    #define SAT_SAT_RANGE_REG00     0x05


    #define CHROMA_GAIN_REG01       0x06
    #define HUE_HUE_RANGE_REG01     0x07
    #define HUE_RANGE_INV_REG01     0x08
    #define HUE_LUM_RANGE_REG01     0x09
    #define HUE_SAT_RANGE_REG01     0x0a
    #define SAT_SAT_RANGE_REG01     0x0b

    #define CHROMA_GAIN_REG02       0x0c
    #define HUE_HUE_RANGE_REG02     0x0d
    #define HUE_RANGE_INV_REG02     0x0e
    #define HUE_LUM_RANGE_REG02     0x0f
    #define HUE_SAT_RANGE_REG02     0x10
    #define SAT_SAT_RANGE_REG02     0x11


    #define CHROMA_GAIN_REG03       0x12
    #define HUE_HUE_RANGE_REG03     0x13
    #define HUE_RANGE_INV_REG03     0x14
    #define HUE_LUM_RANGE_REG03     0x15
    #define HUE_SAT_RANGE_REG03     0x16
    #define SAT_SAT_RANGE_REG03     0x17

    #define CHROMA_GAIN_REG04       0x18
    #define HUE_HUE_RANGE_REG04     0x19
    #define HUE_RANGE_INV_REG04     0x1a
    #define HUE_LUM_RANGE_REG04     0x1b
    #define HUE_SAT_RANGE_REG04     0x1c
    #define SAT_SAT_RANGE_REG04     0x1d

    #define CHROMA_GAIN_REG05       0x1e
    #define HUE_HUE_RANGE_REG05     0x1f
    #define HUE_RANGE_INV_REG05     0x20
    #define HUE_LUM_RANGE_REG05     0x21
    #define HUE_SAT_RANGE_REG05     0x22
    #define SAT_SAT_RANGE_REG05     0x23

    #define CHROMA_GAIN_REG06       0x24
    #define HUE_HUE_RANGE_REG06     0x25
    #define HUE_RANGE_INV_REG06     0x26
    #define HUE_LUM_RANGE_REG06     0x27
    #define HUE_SAT_RANGE_REG06     0x28
    #define SAT_SAT_RANGE_REG06     0x29

    #define CHROMA_GAIN_REG07       0x2a
    #define HUE_HUE_RANGE_REG07     0x2b
    #define HUE_RANGE_INV_REG07     0x2c
    #define HUE_LUM_RANGE_REG07     0x2d
    #define HUE_SAT_RANGE_REG07     0x2e
    #define SAT_SAT_RANGE_REG07     0x2f

//  REG_CHROMA_CONTROL
//  Bit 31      reg_chroma_en               enable color manage function
//                                          1'b1: enable    1'b0: bypass
//  Bit 22      demo_adjust_on_left         1'b1: demo adjust on left, 1'b0: demo adjust on right
//  Bit 21      demo_highlight_adjusted     1'b1: hightlight the adjusted region, 1'b0: disable hightlight
//  Bit 20      demo_enable                 1'b1: demo mode enable, 1'b0, demo mode disable
//  Bit 19:8    demo_left_screen_width      left screen width in demo mode
//  Bit 6       sat_sel                     uv_max or u^2+v^2 selected as sat for reference
//                                          1'b1: uv_max(default)   1'b0: u^2+v^2
//  Bit 5       uv_adj_en                   final uv_adjust enable
//                                          1'b1: enable    1'b0: bypass
//  Bit 2       hue_en                      rgb to hue enable
//                                          1'b1: enable(default)   1'b0: bypass
//  Bit 1:0     csc_sel                     define input YUV with different color type
//                                          2'b00: 601(16-235)  2'b01: 709(16-235)
//                                          2'b10: 601(0-255)   2'b11: 709(0-255)
    #define REG_CHROMA_CONTROL      0x30   // default 32h'80000024


/* Constraints 
0)
  there are 16 regions totally. 8 regions are for hue adjustment, 8 regions are for sat adjustment.
  the hue range of the 16 regions can be set to overlap, but if overlap, the hue range(start and end) must be same.
  the 8 regions for hue adjustment should not overlap. if corresponding reg_hue_en_00 - 07 == 1
  the 8 regions for hue adjustment are defined by: (example are for region 0)
    a) hue:
        start: reg_hue_hue_shift_start_00[14:0]
        end:
        if reg_symmetry_en_00 == 0
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<5)
        if reg_symmetry_en_00 == 1
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<6)
    b) sat:
        start: reg_hue_sat_low_00 
        end:   reg_hue_sat_high_00  

  the 8 regions for sat adjustment should not overlap. if corresponding reg_sat_en_00 - 07 == 1
  the 8 regions for sat adjustment are defined by: (example are for region 0)
    a) hue: same as that for hue adjustment.
        start: reg_hue_hue_shift_start_00[14:0]
        end:
        if reg_symmetry_en_00 == 0
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<5)
        if reg_symmetry_en_00 == 1
        reg_hue_hue_shift_start_00[14:0] + (reg_hue_hue_shift_range_00[7:0]<<6)
    b) sat:
        start: reg_sat_sat_low_00
        end:   reg_sat_sat_high_00  

1)
  reg_hue_hue_shift_range_00[7:0]:
  reg_hue_hue_shift_range_01[7:0]:
  reg_hue_hue_shift_range_02[7:0]:
  reg_hue_hue_shift_range_03[7:0]:
  reg_hue_hue_shift_range_04[7:0]:
  reg_hue_hue_shift_range_05[7:0]:
  reg_hue_hue_shift_range_06[7:0]:
  reg_hue_hue_shift_range_07[7:0]:
  must be greater or equal than 8'd8, so as reg_hue_range_inv_regxx can be represented by 0.0000_0000_xxxx_xxxx_xxxx_xxxx

2)
  all regions of 0-7 should meet below requirement. below is just an example for region 7.
  (reg_hue_lum_high_07 - reg_hue_lum_low_07) >= 
        (1<<reg_hue_lum_low_slope_07) + (1<<reg_hue_lum_high_slope_07)

  (reg_hue_sat_high_07 - reg_hue_sat_low_07) >=
        (1<<reg_hue_sat_low_slope_07) + (1<<reg_hue_sat_high_slope_07)

  (reg_sat_lum_high_07 - reg_sat_lum_low_07) >=
        (1<<reg_sat_lum_low_slope_07) + (1<<reg_sat_lum_high_slope_07)

  (reg_sat_sat_high_07 - reg_sat_sat_low_07) >=
        (1<<reg_sat_sat_low_slope_07) + (1<<reg_sat_sat_high_slope_07)

3)
  all of reg_hue_hue_shift_start_00[14:0] ~ 07[14:0] < 0x6000.
  only region 0 and 1 can exceed 360 degrees. ie:
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<5) can greater than 0x6000.
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_01<<5) can greater than 0x6000.
  but below should be met:
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<5) < 0x8000. if reg_symmetry_en_00 == 0
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_00<<5) < 0x8000. if reg_symmetry_en_00 == 0
    reg_hue_hue_shift_start_00 + (reg_hue_hue_shift_range_00<<6) < 0x8000. if reg_symmetry_en_00 == 1
    reg_hue_hue_shift_start_01 + (reg_hue_hue_shift_range_00<<6) < 0x8000. if reg_symmetry_en_00 == 1

  others could not exceed 360 degrees. ie:
    reg_hue_hue_shift_start_02(to 7) + (reg_hue_hue_shift_range_02 (to 7) <<5) < 0x6000. if reg_symmetry_en_02 (to 7) == 0.
    reg_hue_hue_shift_start_02(to 7) + (reg_hue_hue_shift_range_02 (to 7) <<6) < 0x6000. if reg_symmetry_en_02 (to 7) == 1.

4)
  reg_hue_gain_00[7:0] <= 0x80.
  reg_hue_gain_01[7:0] <= 0x80.
  reg_hue_gain_02[7:0] <= 0x80.
  reg_hue_gain_03[7:0] <= 0x80.
  reg_hue_gain_04[7:0] <= 0x80.
  reg_hue_gain_05[7:0] <= 0x80.
  reg_hue_gain_06[7:0] <= 0x80.
  reg_hue_gain_07[7:0] <= 0x80.

5)
  below registers can only have two setting: 00 and 01.
    reg_hue_central_en_00[1:0]  .. _07[1:0]
    reg_sat_central_en_00[1:0]  .. _07[1:0]

6)
  all reg_..._slope_00-07 should not be greater than 7, ie: maximum value is 7.
   for example: below is for region 0:
   reg_hue_lum_low_slope_00[3:0]  <= 7
   reg_hue_lum_high_slope_00[3:0] <= 7
   reg_hue_sat_low_slope_00[3:0]  <= 7
   reg_hue_sat_high_slope_00[3:0] <= 7
   reg_sat_lum_low_slope_00[3:0]  <= 7
   reg_sat_lum_high_slope_00[3:0] <= 7
   reg_sat_sat_low_slope_00[3:0]  <= 7
   reg_sat_sat_high_slope_00[3:0] <= 7
*/

// synopsys translate_off
// synopsys translate_on
//
// Closing file:  chroma_reg.h
//
//hsvsharp, blue, gainoff, mat_vd1,mat_vd2, mat_post, prebld, postbld,hsharp,sco_ff, vadj1, vadj2, ofifo, chroma, clk0(free_clk) vpp_reg
//each item 2bits, for each 2bits, if bit 2*i+1 == 1, free clk, else if bit 2*i == 1 no clk, else auto gated clock 
//bit1 is not used, because I can not turn off vpp_reg clk because I can not turn on again 
//because the register itself canot be set again without clk
//Bit 31:0
#define P_VPP_GCLK_CTRL0                           (volatile unsigned long *)0xc11075c8
//Ccoring, blackext, dnlp
//Bit 5:0
#define P_VPP_GCLK_CTRL1                           (volatile unsigned long *)0xc11075cc
//prehsc_clk, line_buf, prevsc, vsc, hsc_clk, clk0(free_clk)
//Bit 11:0
#define P_VPP_SC_GCLK_CTRL                         (volatile unsigned long *)0xc11075d0
//Bit 31:24     blackext_start
//Bit 23:16     blackext_slope1
//Bit 15:8      blackext_midpt
//Bit 7:0       blackext_slope2
#define P_VPP_BLACKEXT_CTRL                        (volatile unsigned long *)0xc1107600
//Bit 31:24     bottom of region03 output value
//Bit 23:16     bottom of region02 output value
//Bit 15:8      bottom of region01 output value
//Bit 7:0       bottom of region00 output value
#define P_VPP_DNLP_CTRL_00                         (volatile unsigned long *)0xc1107604
//Bit 31:24     bottom of region07 output value
//Bit 23:16     bottom of region06 output value
//Bit 15:8      bottom of region05 output value
//Bit 7:0       bottom of region04 output value
#define P_VPP_DNLP_CTRL_01                         (volatile unsigned long *)0xc1107608
//Bit 31:24     bottom of region11 output value
//Bit 23:16     bottom of region10 output value
//Bit 15:8      bottom of region09 output value
//Bit 7:0       bottom of region08 output value
#define P_VPP_DNLP_CTRL_02                         (volatile unsigned long *)0xc110760c
//Bit 31:24     bottom of region15 output value
//Bit 23:16     bottom of region14 output value
//Bit 15:8      bottom of region13 output value
//Bit 7:0       bottom of region12 output value
#define P_VPP_DNLP_CTRL_03                         (volatile unsigned long *)0xc1107610
//Bit 31:24     bottom of region19 output value
//Bit 23:16     bottom of region18 output value
//Bit 15:8      bottom of region17 output value
//Bit 7:0       bottom of region16 output value
#define P_VPP_DNLP_CTRL_04                         (volatile unsigned long *)0xc1107614
//Bit 31:24     bottom of region23 output value
//Bit 23:16     bottom of region22 output value
//Bit 15:8      bottom of region21 output value
//Bit 7:0       bottom of region20 output value
#define P_VPP_DNLP_CTRL_05                         (volatile unsigned long *)0xc1107618
//Bit 31:24     bottom of region27 output value
//Bit 23:16     bottom of region26 output value
//Bit 15:8      bottom of region25 output value
//Bit 7:0       bottom of region24 output value
#define P_VPP_DNLP_CTRL_06                         (volatile unsigned long *)0xc110761c
//Bit 31:24     bottom of region31 output value
//Bit 23:16     bottom of region30 output value
//Bit 15:8      bottom of region29 output value
//Bit 7:0       bottom of region28 output value
#define P_VPP_DNLP_CTRL_07                         (volatile unsigned long *)0xc1107620
//Bit 31:24     bottom of region35 output value
//Bit 23:16     bottom of region34 output value
//Bit 15:8      bottom of region33 output value
//Bit 7:0       bottom of region32 output value
#define P_VPP_DNLP_CTRL_08                         (volatile unsigned long *)0xc1107624
//Bit 31:24     bottom of region39 output value
//Bit 23:16     bottom of region38 output value
//Bit 15:8      bottom of region37 output value
//Bit 7:0       bottom of region36 output value
#define P_VPP_DNLP_CTRL_09                         (volatile unsigned long *)0xc1107628
//Bit 31:24     bottom of region43 output value
//Bit 23:16     bottom of region42 output value
//Bit 15:8      bottom of region41 output value
//Bit 7:0       bottom of region40 output value
#define P_VPP_DNLP_CTRL_10                         (volatile unsigned long *)0xc110762c
//Bit 31:24     bottom of region47 output value
//Bit 23:16     bottom of region46 output value
//Bit 15:8      bottom of region45 output value
//Bit 7:0       bottom of region44 output value
#define P_VPP_DNLP_CTRL_11                         (volatile unsigned long *)0xc1107630
//Bit 31:24     bottom of region51 output value
//Bit 23:16     bottom of region50 output value
//Bit 15:8      bottom of region49 output value
//Bit 7:0       bottom of region48 output value
#define P_VPP_DNLP_CTRL_12                         (volatile unsigned long *)0xc1107634
//Bit 31:24     bottom of region55 output value
//Bit 23:16     bottom of region54 output value
//Bit 15:8      bottom of region53 output value
//Bit 7:0       bottom of region52 output value
#define P_VPP_DNLP_CTRL_13                         (volatile unsigned long *)0xc1107638
//Bit 31:24     bottom of region59 output value
//Bit 23:16     bottom of region58 output value
//Bit 15:8      bottom of region57 output value
//Bit 7:0       bottom of region56 output value
#define P_VPP_DNLP_CTRL_14                         (volatile unsigned long *)0xc110763c
//Bit 31:24     bottom of region63 output value
//Bit 23:16     bottom of region62 output value
//Bit 15:8      bottom of region61 output value
//Bit 7:0       bottom of region60 output value
#define P_VPP_DNLP_CTRL_15                         (volatile unsigned long *)0xc1107640
//Bit 28        vlti_step
//Bit 27        vlti_step2
//Bit 26:25     hlti_step
//Bit 24:20     peaking_gain_h1
//Bit 19:15     peaking_gain_h2
//Bit 14:10     peaking_gain_h3
//Bit 9:5       peaking_gain_h4
//Bit 4:0       peaking_gain_h5
#define P_VPP_PEAKING_HGAIN                        (volatile unsigned long *)0xc1107644
//Bit 31        hsvsharp_buf_en
//Bit 30        hsvsharp_buf_c5line_mode
//Bit 29:25     peaking_gain_v1
//Bit 24:20     peaking_gain_v2
//Bit 19:15     peaking_gain_v3
//Bit 14:10     peaking_gain_v4
//Bit 9:5       peaking_gain_v5
//Bit 4:0       peaking_gain_v6
#define P_VPP_PEAKING_VGAIN                        (volatile unsigned long *)0xc1107648
//Bit 31:26     hpeaking_slope1
//Bit 25:20     hpeaking_slope2
//Bit 19:12     hpeaking_slope_th1
//Bit 11:6      vpeaking_slope1
//Bit 5:0       vpeaking_slope2
#define P_VPP_PEAKING_NLP_1                        (volatile unsigned long *)0xc110764c
//Bit 31:24     hpeaking_slope_th2
//Bit 23:16     hpeaking_nlp_coring_th
//Bit 15:8      hpeaking_nlp_pgain
//Bit 7:0       hpeaking_nlp_ngain
#define P_VPP_PEAKING_NLP_2                        (volatile unsigned long *)0xc1107650
//Bit 31:24     vpeaking_slope_th1
//Bit 23:18     speaking_slope1
//Bit 17:12     speaking_slope2
//Bit 11:4      speaking_slope_th1
//Bit 3:0       peaking_coring_gain
#define P_VPP_PEAKING_NLP_3                        (volatile unsigned long *)0xc1107654
//Bit 31:24     vpeaking_slope_th2
//Bit 23:16     vpeaking_nlp_coring_th
//Bit 15:8      vpeaking_nlp_pgain
//Bit 7:0       vpeaking_nlp_ngain
#define P_VPP_PEAKING_NLP_4                        (volatile unsigned long *)0xc1107658
//Bit 31:24     speaking_slope_th2
//Bit 23:16     speaking_nlp_coring_th
//Bit 15:8      speaking_nlp_pgain
//Bit 7:0       speaking_nlp_ngain
#define P_VPP_PEAKING_NLP_5                        (volatile unsigned long *)0xc110765c
//Bit 31:24     peaking_coring_th_l
//Bit 23:16     peaking_coring_th_h
//Bit 15:12     vlimit_high_coef
//Bit 11:8      vlimit_low_coef
//Bit 7:4       hlimit_high_coef
//Bit 3:0       hlimit_low_coef
#define P_VPP_SHARP_LIMIT                          (volatile unsigned long *)0xc1107660
//Bit 31:24     vlti_neg_gain
//Bit 23:16     vlti_pos_gain
//Bit 15:8      vlti_threshold
//Bit 7:0       vlti_blend_factor
#define P_VPP_VLTI_CTRL                            (volatile unsigned long *)0xc1107664
//Bit 31:24     hlti_neg_gain
//Bit 23:16     hlti_pos_gain
//Bit 15:8      hlti_threshold
//Bit 7:0       hlti_blend_factor
#define P_VPP_HLTI_CTRL                            (volatile unsigned long *)0xc1107668
//Bit 29:28     cti_vfilter_type
//Bit 27        cti_422to444_en
//Bit 26:24     cti_step2
//Bit 23:21     cti_step
//Bit 20:16     cti_blend_factor
//Bit 15        cti_median_mode
//Bit 14:8      cti_threshold
//Bit 7:0       cti_gain
#define P_VPP_CTI_CTRL                             (volatile unsigned long *)0xc110766c
//Bit 29        blue_stretch_cb_inc
//Bit 28        blue_stretch_cr_inc
//Bit 27        the MSB of blue_stretch_error_crp_inv[11:0]
//Bit 26        the MSB of blue_stretch_error_crn_inv[11:0]
//Bit 25        the MSB of blue_stretch_error_cbp_inv[11:0]
//Bit 24        the MSB of blue_stretch_error_cbn_inv[11:0]
//Bit 23:16     blue_stretch_gain
//Bit 15:8      blue_stretch_gain_cb4cr
//Bit 7:0       blue_stretch_luma_high
#define P_VPP_BLUE_STRETCH_1                       (volatile unsigned long *)0xc1107670
//Bit 31:27     blue_stretch_error_crp
//Bit 26:16     the 11 LSB of blue_stretch_error_crp_inv[11:0]
//Bit 15:11     blue_stretch_error_crn
//Bit 10:0      the 11 LSB of blue_stretch_error_crn_inv[11:0]
#define P_VPP_BLUE_STRETCH_2                       (volatile unsigned long *)0xc1107674
//Bit 31:27     blue_stretch_error_cbp
//Bit 26:16     the 11 LSB of blue_stretch_error_cbp_inv[11:0]
//Bit 15:11     blue_stretch_error_cbn
//Bit 10:0      the 11 LSB of blue_stretch_error_cbn_inv[11:0]
#define P_VPP_BLUE_STRETCH_3                       (volatile unsigned long *)0xc1107678
//Bit 15:8, Chroma coring threshold
//Bit 3:0, Chroma coring slope
#define P_VPP_CCORING_CTRL                         (volatile unsigned long *)0xc1107680
//Bit 20 demo chroma coring enable
//Bit 19 demo black enxtension enable
//Bit 18 demo dynamic nonlinear luma processing enable
//Bit 17 demo hsvsharp enable
//Bit 16 demo bluestretch enable
//Bit 15, if true, enhance video is on the left screen, otherwises it is on the right screen
//Bit 4 chroma coring enable
//Bit 3 black enxtension enable
//Bit 2 dynamic nonlinear luma processing enable
//Bit 1 hsvsharp enable
//Bit 0 bluestretch enable
#define P_VPP_VE_ENABLE_CTRL                       (volatile unsigned long *)0xc1107684
//Bit 11:0, demo left screen width
#define P_VPP_VE_DEMO_LEFT_SCREEN_WIDTH            (volatile unsigned long *)0xc1107688
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  vpp_regs.h
//
//
//========================================================================
//	registers for ge2d (12'h8a0 - 12'h8ff)
//========================================================================
//
// Reading file:  ge2d_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// GE2D Registers    0x8a0 - 0x8ff
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  GE2D_CBUS_BASE = 0x18
// -----------------------------------------------
//Bit 31, destination bytemask only if destination bitmask is enable
//Bit 30, destination bitmask enable
//Bit 29, source2 key  enable
//Bit 28, source2 key  mode, 0: mask data when match, 1: mask data when unmatch
//Bit 27, source1 key  enable
//Bit 26, source1 key  mode, 0: mask data when match, 1: mask data when unmatch
//Bit 25:24, dst 8bit mode component selection, 
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 23 dst clip mode, 0: write inside clip window, 1: write outside clip window
//Bit 21:17  reserved
//Bit 16:15, src2 8bit mode component selection, 
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 14     src2 fill mode, 0: repeat data, 1: fill default color
//Bit 13:12  src2 picture struct, 00: frame, 10: even, 11: odd
//Bit 11     src1 x direction yc ration, 0: 1:1, 1: 2:1
//Bit 10     src1 y direction yc ration, 0: 1:1, 1: 2:1
//Bit 8:7    reserved
//Bit 6:5,   src1  8bit mode component selection, 
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 4      src1 fill mode, 0: repeat data, 1: fill default color
//Bit 3      src1 lookup table enable
//Bit 2:1    src1 picture struct, 00: frame, 10: even, 11: odd
//Bit 0      src1 separate buffer enable
#define P_GE2D_GEN_CTRL0                           (volatile unsigned long *)0xc1106280
//Bit 31, soft rst
//Bit 30, dst write response counter reset  
//Bit 29, disable adding dst write response count to busy bit 
//bit 25:24, interrupt control, if bit[0] true, generate interrupt when one command done,
//                              if bit[1] true, generate interrupt when ge2d change from busy to not busy
//Bit 23:22 src2 burst size control
//Bit 21:16 src1 burst size control, 5:4, yfifo, 3:2, cbfifo, 1:0, crfifo
//          each 2bit, 00: 24 64bitword, 01: 32 64bitword, 10: 48 64bitwords, 11: 64 64bitwords  
//Bit 15:14, dst picture struct, 00: frame, 10:top, 11: bottom
//Bit 13:12, bit 13 if true, force read src1, bit 12 if true, force read src2
//Bit 10, src1 request urgent enable
//Bit 9,  src2 request urgent enable
//Bit 8,  dst request urgent enable
//Bit 7:0 src1 global alpha
#define P_GE2D_GEN_CTRL1                           (volatile unsigned long *)0xc1106284
//Bit31      alpha conversion mode in alu, 0: alpha_out = (alpha !=0) ? alpha +1 : 0; 
//                 otherwise, alpha_out = (alpha < 128) ? alpha: alpha + 1;
//Bit30      color conversion mode in alu, 0: color_out = (color != 0) ? color +1: 0;
//                 otherwise, color_out = (color < 128) ? color: color + 1;
//Bit29      reserved
//Bit28      dst_color_round_mode, 0: truncate, 1: + 0.5 rounding
//Bit27      src2_color_expand_mode, 0: add 0, 1: add MSBs 
//Bit26      src2_alpha_expand_mode, 0: add 0, 1: add MSBs 
//Bit25      src1_color_expand_mode, 0: add 0, 1: add MSBs 
//Bit24      src1_alpha_expand_mode, 0: add 0, 1: add MSBs 
//Bit 23     if true, dst little endian, otherwise big endian
//Bit 22:19 dst color_map
//        dst_format=0                 : output 8-bit;
//        dst_format=1, dst_color_map=1: output 16-bit YCbCr  655;
//        dst_format=1, dst_color_map=2: output 16-bit YCbCr  844;
//        dst_format=1, dst_color_map=3: output 16-bit YCbCrA 6442;
//        dst_format=1, dst_color_map=4: output 16-bit YCbCrA 4444;
//        dst_format=1, dst_color_map=5: output 16-bit YCbCr  565;
//        dst_format=1, dst_color_map=6: output 16-bit AYCbCr 4444;
//        dst_format=1, dst_color_map=7: output 16-bit AYCbCr 1555;
//        dst_format=1, dst_color_map=8: output 16-bit YCbCrA 4642;
//        dst_format=2, dst_color_map=0: output 24-bit YCbCr  888;
//        dst_format=2, dst_color_map=1: output 24-bit YCbCrA 5658;
//        dst_format=2, dst_color_map=2: output 24-bit AYCbCr 8565;
//        dst_format=2, dst_color_map=3: output 24-bit YCbCrA 6666;
//        dst_format=2, dst_color_map=4: output 24-bit AYCbCr 6666;
//        dst_format=2, dst_color_map=5: output 24-bit CrCbY  888;
//        dst_format=3, dst_color_map=0: output 32-bit YCbCrA 8888;
//        dst_format=3, dst_color_map=1: output 32-bit AYCbCr 8888;
//        dst_format=3, dst_color_map=2: output 32-bit ACrCbY 8888;
//        dst_format=3, dst_color_map=3: output 32-bit CrCbYA 8888.
//Bit 17:16 dst_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
//Bit 15    if true, src2 little endian, otherwise big endian
//Bit 14:11  src2 color_map
//        src2_format=0                 : output 8-bit;
//        src2_format=1, src2_color_map=1: output 16-bit YCbCr  655;
//        src2_format=1, src2_color_map=2: output 16-bit YCbCr  844;
//        src2_format=1, src2_color_map=3: output 16-bit YCbCrA 6442;
//        src2_format=1, src2_color_map=4: output 16-bit YCbCrA 4444;
//        src2_format=1, src2_color_map=5: output 16-bit YCbCr  565;
//        src2_format=1, src2_color_map=6: output 16-bit AYCbCr 4444;
//        src2_format=1, src2_color_map=7: output 16-bit AYCbCr 1555;
//        src2_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
//        src2_format=2, src2_color_map=0: output 24-bit YCbCr  888;
//        src2_format=2, src2_color_map=1: output 24-bit YCbCrA 5658;
//        src2_format=2, src2_color_map=2: output 24-bit AYCbCr 8565;
//        src2_format=2, src2_color_map=3: output 24-bit YCbCrA 6666;
//        src2_format=2, src2_color_map=4: output 24-bit AYCbCr 6666;
//        src2_format=2, src2_color_map=5: output 24-bit CrCbY  888;
//        src2_format=3, src2_color_map=0: output 32-bit YCbCrA 8888;
//        src2_format=3, src2_color_map=1: output 32-bit AYCbCr 8888;
//        src2_format=3, src2_color_map=2: output 32-bit ACrCbY 8888;
//        src2_format=3, src2_color_map=3: output 32-bit CrCbYA 8888.
//Bit 9:8 src2 format, 00: 8bit, 01:16bit, 10:24bit 11: 32bit
//Bit 7     if true, src1 little endian, otherwise big endian
//Bit 6:3   src1 color_map
//        src1_format=0                 : output 8-bit;
//        src1_format=1, src1_color_map=0: output 4:2:2  (Y0Cb0Y1Cr0);
//        src1_format=1, src1_color_map=1: output 16-bit YCbCr  655;
//        src1_format=1, src1_color_map=2: output 16-bit YCbCr  844;
//        src1_format=1, src1_color_map=3: output 16-bit YCbCrA 6442;
//        src1_format=1, src1_color_map=4: output 16-bit YCbCrA 4444;
//        src1_format=1, src1_color_map=5: output 16-bit YCbCr  565;
//        src1_format=1, src1_color_map=6: output 16-bit AYCbCr 4444;
//        src1_format=1, src1_color_map=7: output 16-bit AYCbCr 1555;
//        src1_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
//        src1_format=2, src1_color_map=0: output 24-bit YCbCr  888;
//        src1_format=2, src1_color_map=1: output 24-bit YCbCrA 5658;
//        src1_format=2, src1_color_map=2: output 24-bit AYCbCr 8565;
//        src1_format=2, src1_color_map=3: output 24-bit YCbCrA 6666;
//        src1_format=2, src1_color_map=4: output 24-bit AYCbCr 6666;
//        src1_format=2, src1_color_map=5: output 24-bit CrCbY  888;
//        src1_format=3, src1_color_map=0: output 32-bit YCbCrA 8888;
//        src1_format=3, src1_color_map=1: output 32-bit AYCbCr 8888;
//        src1_format=3, src1_color_map=2: output 32-bit ACrCbY 8888;
//        src1_format=3, src1_color_map=3: output 32-bit CrCbYA 8888.     
//Bit 1:0 src1 format, 00: 8bit, 01:16bit/4:2:2, 10:24bit 11: 32bit 
#define P_GE2D_GEN_CTRL2                           (volatile unsigned long *)0xc1106288
//Bit 9     if true, all src2 data use default color
//Bit 8     if true, all src1 data use default color
//Bit 7     if true, dst x/y swap 
//Bit 6     if true, dst x direction reversely read
//Bit 5     if true, dst y direction reversely read
//Bit 4     if true, src2 x direction reversely read
//Bit 3     if true, src2 y direction reversely read
//Bit 2     if true, src1 x direction reversely read
//Bit 1     if true, src1 y direction reversely read
//Bit 0     cmd write
#define P_GE2D_CMD_CTRL                            (volatile unsigned long *)0xc110628c
//Read only
//Bit 28:17 dst write response counter, for debug only
//Bit 16:7  ge2d_dp status, for debug only
//Bit 6     read src1 cmd ready
//Bit 5     read src2 cmd ready
//Bit 4     pre dpcmd ready
//Bit 3     ge2d dpcmd ready
//Bit 2     ge2d buffer command valid
//Bit 1     ge2d current command valid
//Bit 0     ge2d busy
#define P_GE2D_STATUS0                             (volatile unsigned long *)0xc1106290
//
//Read only
// Bit 29:16 ge2d_dst_status, for debug only
// Bit    15 ge2d_rd_src2 core.fifo_empty
// Bit    14 ge2d_rd_src2 core.fifo_overflow
// Bit 13:12 ge2d_rd_src2 core.req_st
// Bit    11 ge2d_rd_src2 cmd_if.cmd_err, true if cmd_format=1
// Bit    10 ge2d_rd_src2 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
// Bit     9 ge2d_rd_src1 luma_core(chroma_core).fifo_empty
// Bit     8 ge2d_rd_src1 luma_core(chroma_core).fifo_overflow
// Bit  7: 6 ge2d_rd_src1 chroma_core.req_st_cr
// Bit  5: 4 ge2d_rd_src1 chroma_core.req_st_cb
// Bit  3: 2 ge2d_rd_src1 luma_core.req_st_y
// Bit     1 ge2d_rd_src1 cmd_if.stat_read_window_err, 1=reading/clipping window setting exceed limit
// Bit     0 ge2d_rd_src1 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
#define P_GE2D_STATUS1                             (volatile unsigned long *)0xc1106294
//SRC1 default clolor
//{Y,Cb,Cr,A}/{R,G,B,A}
#define P_GE2D_SRC1_DEF_COLOR                      (volatile unsigned long *)0xc1106298
//Bit 31, SRC1 clip x start extra, if true, one more data is read for chroma
//Bit 28:16, SRC1 clip x start
//Bit 15, SRC1 clip x end extra, if true, one more data is read for chroma
//Bit 12:0, SRC1 clip x end
#define P_GE2D_SRC1_CLIPX_START_END                (volatile unsigned long *)0xc110629c
//Bit 31, SRC1 clip y start extra, if true, one more data is read for chroma
//Bit 28:16, SRC1 clip y start
//Bit 15, SRC1 clip y end extra, if true, one more data is read for chroma
//Bit 12:0, SRC1 clip y end
#define P_GE2D_SRC1_CLIPY_START_END                (volatile unsigned long *)0xc11062a0
//Bit 31:24, SRC1 canvas address0
//Bit 23:16, SRC1 canvas address1
//Bit 15:8, SRC1 canvas address2
#define P_GE2D_SRC1_CANVAS                         (volatile unsigned long *)0xc11062a4
//Bit 31, SRC1 x start extra bit1, if true, one more chroma data is read for x even start chroma data when y/c ratio = 2
//             or x even/odd start chroma extra data when y/c ratio = 1
//Bit 30, SRC1 x start extra bit0, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
//Bit 29:16, SRC1 x start, signed data
//Bit 15, SRC1 x end extra bit1, if true, one more chroma data is read for x odd end chroma data when y/c ratio = 2
//             or x even/odd end chroma extra data when y/c ratio = 1
//Bit 14, SRC1 x end extra bit0, if true, one more chroma data is read for x even end chroma data when y/c ratio = 2
//Bit 13:0, SRC1 x end, signed data
#define P_GE2D_SRC1_X_START_END                    (volatile unsigned long *)0xc11062a8
//Bit 31, SRC1 y start extra, if true, one more chroma data is read for y even start chroma data when y/c ratio = 2
//             or y even/odd start chroma extra data when y/c ratio = 1
//Bit 30, SRC1 y start extra, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
//Bit 28:16, SRC1 y start
//Bit 15, SRC1 y end extra bit1, if true, one more chroma data is read for y odd end chroma data when y/c ratio = 2
//             or y even/odd end chroma extra data when y/c ratio = 1
//Bit 14, SRC1 y end extra bit0, if true, one more chroma data is read for y even end chroma data when y/c ratio = 2
//Bit 12:0, SRC1 y end
#define P_GE2D_SRC1_Y_START_END                    (volatile unsigned long *)0xc11062ac
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define P_GE2D_SRC1_LUT_ADDR                       (volatile unsigned long *)0xc11062b0
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_GE2D_SRC1_LUT_DAT                        (volatile unsigned long *)0xc11062b4
//Bit 19, if true, horizontal formatter using repeat to get the pixel, otherwise using interpolation
//Bit 18, horizontal formatter en
//Bit 17, if true, vertical formatter using repeat to get the pixel, otherwise using interpolation
//Bit 16, vertical formatter en
//Bit 15:8 X direction chroma phase,  
//          [7:4] for x direction even start/end chroma phase when y/c ratio = 2
//                or start/end even/odd chroma phase  when y/c ratio = 1 
//          [3:0] for x direction odd start/end chroma phase only when y/c ration = 2
//Bit 7:0  Y direction chroma phase, 
//          [7:4] for y direction even start/end chroma phase when y/c ratio = 2
//          or start/end even/odd chroma phase  when y/c ratio = 1 
//          [3:0] for y direction odd start/end chroma phase only when y/c ration = 2 
#define P_GE2D_SRC1_FMT_CTRL                       (volatile unsigned long *)0xc11062b8
//SRC2 default clolor
//{Y,Cb,Cr,A}/{R,G,B,A}
#define P_GE2D_SRC2_DEF_COLOR                      (volatile unsigned long *)0xc11062bc
//Bit 28:16, SRC2 clip x start
//Bit 12:0, SRC2 clip x end
#define P_GE2D_SRC2_CLIPX_START_END                (volatile unsigned long *)0xc11062c0
//Bit 28:16, SRC2 clip y start
//Bit 12:0, SRC2 clip y end
#define P_GE2D_SRC2_CLIPY_START_END                (volatile unsigned long *)0xc11062c4
//Bit 28:16, SRC2 x start
//Bit 12:0, SRC2 x end
#define P_GE2D_SRC2_X_START_END                    (volatile unsigned long *)0xc11062c8
//Bit 28:16, SRC2 y start
//Bit 12:0, SRC2 y end
#define P_GE2D_SRC2_Y_START_END                    (volatile unsigned long *)0xc11062cc
//Bit 28:16, DST clip x start
//Bit 12:0, DST clip x end
#define P_GE2D_DST_CLIPX_START_END                 (volatile unsigned long *)0xc11062d0
//
//Bit 28:16, DST clip y start
//Bit 12:0, DST clip y end
#define P_GE2D_DST_CLIPY_START_END                 (volatile unsigned long *)0xc11062d4
//Bit 28:16, DST x start
//Bit 12:0, DST x end
#define P_GE2D_DST_X_START_END                     (volatile unsigned long *)0xc11062d8
//
//Bit 28:16, DST x start
//Bit 12:0, DST x end
#define P_GE2D_DST_Y_START_END                     (volatile unsigned long *)0xc11062dc
//Bit 15:8 SRC2 canvas address
//Bit 7:0 DST canvas address
#define P_GE2D_SRC2_DST_CANVAS                     (volatile unsigned long *)0xc11062e0
//vertical scaler phase step
//Bit 28:0,  5.24 format
#define P_GE2D_VSC_START_PHASE_STEP                (volatile unsigned long *)0xc11062e4
//phase slope 
//Bit 24:0, bit 24 signed bit
#define P_GE2D_VSC_PHASE_SLOPE                     (volatile unsigned long *)0xc11062e8
//Bit 30:29, vertical repeat line0 number 
//Bit 23:0, vertical scaler initial phase
#define P_GE2D_VSC_INI_CTRL                        (volatile unsigned long *)0xc11062ec
//horizontal scaler phase step
//Bit 28:0,  5.24 format
#define P_GE2D_HSC_START_PHASE_STEP                (volatile unsigned long *)0xc11062f0
//phase slope 
//Bit 24:0, bit 24 signed bit
#define P_GE2D_HSC_PHASE_SLOPE                     (volatile unsigned long *)0xc11062f4
//Bit 30:29, horizontal repeat line0 number 
//Bit 23:0, horizontal scaler initial phase
#define P_GE2D_HSC_INI_CTRL                        (volatile unsigned long *)0xc11062f8
//Bit 31:24, advance number in this round, if horizontal scaler is working on dividing mode
//Bit 23:0, horizontal scaler advance phase in this round, if horizontal scaler is working on dividing mode 
#define P_GE2D_HSC_ADV_CTRL                        (volatile unsigned long *)0xc11062fc
//Bit 30, vertical nearest mode enable, must set vt_bank_length = 4
//Bit 29, horizontal nearest mode enable, must set hz_bank_length = 4 
//Bit 28, horizontal scaler dividing mode enable
//Bit 27:15, horizontal dividing length, if bit 25 is enable
//Bit 14, pre horizontal scaler enable 
//Bit 13, pre vertical scale enable
//Bit 12, vertical scale enable
//Bit 11, horizontal scaler enable
//Bit 9, if true, treat horizontal repeat line number(GE2D_HSC_INI_CTRL bit 30:29) as repeating line, 
//        otherwise using treat horizontal repeat line number as minus line number. 
//Bit 8, if true, treat vertical repeat line number(GE2D_VSC_INI_CTRL bit 30:29) as repeating line, 
//        otherwise using treat vertical repeat line number as minus line number. 
//Bit 7, if true, always use phase0 in vertical scaler
//Bit 6:4, vertical scaler bank length
//Bit 3, if true, always use phase0 in horizontal scaler
//Bit 2:0, horizontal scaler bank length
#define P_GE2D_SC_MISC_CTRL                        (volatile unsigned long *)0xc1106300
//Read only
//vertical scaler next round integer pixel pointer, signed data
//Bit 13:0
#define P_GE2D_VSC_NRND_POINT                      (volatile unsigned long *)0xc1106304
//Read only
//vertical scaler next round phase
//bit 23:0
#define P_GE2D_VSC_NRND_PHASE                      (volatile unsigned long *)0xc1106308
//Read only
//horizontal scaler next round integer pixel pointer, signed data
//Bit 13:0
#define P_GE2D_HSC_NRND_POINT                      (volatile unsigned long *)0xc110630c
//Read only
//horizontal scaler next round phase
//bit 23:0
#define P_GE2D_HSC_NRND_PHASE                      (volatile unsigned long *)0xc1106310
//
//Bit 28:20, pre_offset0
//Bit 18:10, pre_offset1 
//Bit 8:0,   pre_offset2
#define P_GE2D_MATRIX_PRE_OFFSET                   (volatile unsigned long *)0xc1106314
//Bit 28:16 coef00
//Bit 12:0  coef01
#define P_GE2D_MATRIX_COEF00_01                    (volatile unsigned long *)0xc1106318
//Bit 28:16 coef02
//Bit 12:0  coef10
#define P_GE2D_MATRIX_COEF02_10                    (volatile unsigned long *)0xc110631c
//Bit 28:16 coef11
//Bit 12:0  coef12
#define P_GE2D_MATRIX_COEF11_12                    (volatile unsigned long *)0xc1106320
//Bit 28:16 coef20
//Bit 12:0  coef21
#define P_GE2D_MATRIX_COEF20_21                    (volatile unsigned long *)0xc1106324
//Bit 28:16 coef22
//Bit 7    input y/cb/cr saturation enable
//Bit 0    conversion matrix enable
#define P_GE2D_MATRIX_COEF22_CTRL                  (volatile unsigned long *)0xc1106328
//Bit 28:20, offset0
//Bit 18:10, offset1 
//Bit 8:0,   offset2
#define P_GE2D_MATRIX_OFFSET                       (volatile unsigned long *)0xc110632c
//Bit 26:25, SRC1 color multiplier alpha selection
//           if 00, Cs = Csr
//           if 01, Cs = Csr * Asr * Ag (if source is not premultiplied)
//           if 10, Cs = Csr * Ag (if source is premultipied)
//Bit 24    SRC2 color multiplier alpha selection 
//          if 0, no multiplier, Cd = Cdr,  otherwise, Cd = Cdr * Ad.   
//Bit 22:12 ALU color operation
//          bit10:8 Blending Mode Parameter
//            3'b000: ADD               Cs*Fs + Cd*Fd
//            3'b001: SUBTRACT          Cs*Fs - Cd*Fd
//            3'b010: REVERSE SUBTRACT  Cd*Fd - Cs*Fs
//            3'b011: MIN               min(Cs*Fs, Cd*Fd)
//            3'b100: MAX               max(Cs*Fs, Cd*Fd)
//            3'b101: LOGIC OP          Cs op Cd
//          bit7:4 Source Color Blending Factor CFs
//            4'b0000: ZERO                        0
//            4'b0001: ONE                         1
//            4'b0010: SRC_COLOR                   Cs(RGBs)
//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
//            4'b0100: DST_COLOR                   Cd(RGBd)
//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
//            4'b0110: SRC_ALPHA                   As
//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
//            4'b1000: DST_ALPHA                   Ad
//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
//            4'b1010: CONST_COLOR                 Cc(RGBc)
//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
//            4'b1100: CONST_ALPHA                 Ac
//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
//          bit3:0 dest Color Blending Factor CFd, when bit10:8 != LOGIC OP
//            4'b0000: ZERO                        0
//            4'b0001: ONE                         1
//            4'b0010: SRC_COLOR                   Cs(RGBs)
//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
//            4'b0100: DST_COLOR                   Cd(RGBd)
//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
//            4'b0110: SRC_ALPHA                   As
//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
//            4'b1000: DST_ALPHA                   Ad
//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
//            4'b1010: CONST_COLOR                 Cc(RGBc)
//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
//            4'b1100: CONST_ALPHA                 Ac
//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
//          bit3:0 logic operations, when bit10:8 == LOGIC OP
//            4'b0000: CLEAR                       0
//            4'b0001: COPY                        s
//            4'b0010: NOOP                        d
//            4'b0011: SET                         1
//            4'b0100: COPY_INVERT                 ~s
//            4'b0101: INVERT                      ~d
//            4'b0110: AND_REVERSE                 s & ~d
//            4'b0111: OR_REVERSE                  s | ~d
//            4'b1000: AND                         s & d
//            4'b1001: OR                          s | d
//            4'b1010: NAND                        ~(s & d)
//            4'b1011: NOR                         ~(s | d)
//            4'b1100: XOR                         s ^ d
//            4'b1101: EQUIV                       ~(s ^ d)
//            4'b1110: AND_INVERTED                ~s & d
//            4'b1111: OR_INVERTED                 ~s | d
//Bit 10:0  ALU alpha operation
//            bit10:8 Blending Equation Math Operation
//              3'b000: ADD               As*Fs + Ad*Fd
//              3'b001: SUBTRACT          As*Fs - Ad*Fd
//              3'b010: REVERSE SUBTRACT  Ad*Fd - As*Fs
//              3'b011: MIN               min(As*Fs, Ad*Fd)
//              3'b100: MAX               max(As*Fs, Ad*Fd)
//              3'b101: LOGIC OP          As op Ad
//            bit7:4 Source alpha Blending Factor AFs
//              4'b0000                       0
//              4'b0001                       1
//              4'b0010                       As
//              4'b0011                       1 - As
//              4'b0100                       Ad
//              4'b0101                       1 - Ad
//              4'b0110                       Ac
//              4'b0111                       1 - Ac
//               ....                         reserved
//            bit3:0 Destination alpha Blending Factor AFd, when bit10:8 != LOGIC OP
//              4'b0000                       0
//              4'b0001                       1
//              4'b0010                       As
//              4'b0011                       1 - As
//              4'b0100                       Ad
//              4'b0101                       1 - Ad
//              4'b0110                       Ac
//              4'b0111                       1 - Ac
//               ....                         reserved
//            bit3:0 logic operations, when bit10:8 == LOGIC OP
//              4'b0000: CLEAR                       0
//              4'b0001: COPY                        s
//              4'b0010: NOOP                        d
//              4'b0011: SET                         1
//              4'b0100: COPY_INVERT                 ~s
//              4'b0101: INVERT                      ~d
//              4'b0110: AND_REVERSE                 s & ~d
//              4'b0111: OR_REVERSE                  s | ~d
//              4'b1000: AND                         s & d
//              4'b1001: OR                          s | d
//              4'b1010: NAND                        ~(s & d)
//              4'b1011: NOR                         ~(s | d)
//              4'b1100: XOR                         s ^ d
//              4'b1101: EQUIV                       ~(s ^ d)
//              4'b1110: AND_INVERTED                ~s & d
//              4'b1111: OR_INVERTED                 ~s | d
#define P_GE2D_ALU_OP_CTRL                         (volatile unsigned long *)0xc1106330
//bit 31:0 (RGBA,YCBCRA)
#define P_GE2D_ALU_CONST_COLOR                     (volatile unsigned long *)0xc1106334
//SRC1 Key
//31:0 
#define P_GE2D_SRC1_KEY                            (volatile unsigned long *)0xc1106338
//SRC1 Key Mask
//31:0 
#define P_GE2D_SRC1_KEY_MASK                       (volatile unsigned long *)0xc110633c
//SRC2 Key
//31:0 
#define P_GE2D_SRC2_KEY                            (volatile unsigned long *)0xc1106340
//SRC2 Key Mask
//31:0 
#define P_GE2D_SRC2_KEY_MASK                       (volatile unsigned long *)0xc1106344
//Destination Bit Mask
//31:0 
#define P_GE2D_DST_BITMASK                         (volatile unsigned long *)0xc1106348
//Bit 31    DP onoff mode, 0: on_counter means how many pixels will output before ge2d turns off
//                         1: on_counter means how many clocks will ge2d turn on before ge2d turns off
//Bit 30:16     DP on counter
//Bit 15        0: vd_format doesnt have onoff mode, 1: vd format has onoff mode
//Bit 14:0      DP off counter
#define P_GE2D_DP_ONOFF_CTRL                       (volatile unsigned long *)0xc110634c
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients 
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)	
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8	    type of index, 0: vertical coef
//						   1: horizontal coef
//Bit 6:0 	coef index
#define P_GE2D_SCALE_COEF_IDX                      (volatile unsigned long *)0xc1106350
//coefficients for vertical filter and horizontal filter
#define P_GE2D_SCALE_COEF                          (volatile unsigned long *)0xc1106354
//Bit 24    src2 alpha fill mode: together with GE2D_GEN_CTRL0[4](fill_mode), define what alpha values are used
//                                for the area outside the clipping window. As below:
//                                fill_mode=0, alpha_fill_mode=0 : use inner alpha, (or default_alpha if src data have no alpha values);
//                                fill_mode=0, alpha_fill_mode=1 : use outside_alpha;
//                                fill_mode=1, alpha_fill_mode=0 : use default_alpha;
//                                fill_mode=1, alpha_fill_mode=1 : use outside_alpha.
//Bit 23:16 src2 outside alpha
//Bit 8     src1 alpha fill mode, refer to src2 alpha fill mode above. 
//Bit 7:0   src1 outside alpha
#define P_GE2D_SRC_OUTSIDE_ALPHA                   (volatile unsigned long *)0xc1106358
//Bit 31       antiflick enable
//Bit 24       1: alpha value for the first line use repeated alpha, 0: use bit 23:16 as the first line alpha 
//Bit 23:16     register value for the first line alpha when bit 24 is 1 
//Bit 8        1: alpha value for the last line use repeated alpha, 0: use bit 7:0 as the last line alpha 
//Bit 7:0      register value for the last line alpha when bit 8 is 1 
#define P_GE2D_ANTIFLICK_CTRL0                     (volatile unsigned long *)0xc1106360
//Bit 25,    rgb_sel, 1: antiflick RGBA, 0: antiflick YCbCrA 
//Bit 24,    cbcr_en, 1: also filter cbcr in case of antiflicking YCbCrA, 0: no filter on cbcr in case of antiflicking YCbCrA
//Bit 23:16, R mult coef for converting RGB to Y
//Bit 15:8,  G mult coef for converting RGB to Y
//Bit 7:0,   B mult coef for converting RGB to Y
//Y = (R * y_r + G * y_g + B * y_b) / 256
#define P_GE2D_ANTIFLICK_CTRL1                     (volatile unsigned long *)0xc1106364
//Bit 31:24, Y threhold1, when   0<Y<=th1, use filter0;
//Bit 23:16, color antiflick filter0 n3
//Bit 15:8,  color antiflick filter0 n2
//Bit 7:0,   color antiflick filter0 n1
//Y = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
#define P_GE2D_ANTIFLICK_COLOR_FILT0               (volatile unsigned long *)0xc1106368
//Bit 31:24, Y threhold2, when th1<Y<=th2, use filter1;
//Bit 23:16, color antiflick filter1 n3
//Bit 15:8,  color antiflick filter1 n2
//Bit 7:0,   color antiflick filter1 n1
#define P_GE2D_ANTIFLICK_COLOR_FILT1               (volatile unsigned long *)0xc110636c
//Bit 31:24, Y threhold3, when th2<Y<=th3, use filter2; Y>th3, use filter3
//Bit 23:16, color antiflick filter2 n3
//Bit 15:8,  color antiflick filter2 n2
//Bit 7:0,   color antiflick filter2 n1
#define P_GE2D_ANTIFLICK_COLOR_FILT2               (volatile unsigned long *)0xc1106370
//Bit 23:16, color antiflick filter3 n3
//Bit 15:8,  color antiflick filter3 n2
//Bit 7:0,   color antiflick filter3 n1
#define P_GE2D_ANTIFLICK_COLOR_FILT3               (volatile unsigned long *)0xc1106374
//Bit 31:24, Alpha threhold1, when   0<Alpha<=th1, use filter0;
//Bit 23:16, Alpha antiflick filter0 n3
//Bit 15:8,  Alpha antiflick filter0 n2
//Bit 7:0,   Alpha antiflick filter0 n1
//Alpha = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
#define P_GE2D_ANTIFLICK_ALPHA_FILT0               (volatile unsigned long *)0xc1106378
//Bit 31:24, Alpha threhold2, when th1<Alpha<=th2, use filter1;
//Bit 23:16, Alpha antiflick filter1 n3
//Bit 15:8,  Alpha antiflick filter1 n2
//Bit 7:0,   Alpha antiflick filter1 n1
#define P_GE2D_ANTIFLICK_ALPHA_FILT1               (volatile unsigned long *)0xc110637c
//Bit 31:24, Alpha threhold3, when th2<Alpha<=th3, use filter2; Alpha>th3, use filter3
//Bit 23:16, Alpha antiflick filter2 n3
//Bit 15:8,  Alpha antiflick filter2 n2
//Bit 7:0,   Alpha antiflick filter2 n1
#define P_GE2D_ANTIFLICK_ALPHA_FILT2               (volatile unsigned long *)0xc1106380
//Bit 23:16, Alpha antiflick filter3 n3
//Bit 15:8,  Alpha antiflick filter3 n2
//Bit 7:0,   Alpha antiflick filter3 n1
#define P_GE2D_ANTIFLICK_ALPHA_FILT3               (volatile unsigned long *)0xc1106384
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset) 
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define P_GE2D_SRC1_RANGE_MAP_Y_CTRL               (volatile unsigned long *)0xc110638c
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset) 
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define P_GE2D_SRC1_RANGE_MAP_CB_CTRL              (volatile unsigned long *)0xc1106390
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset) 
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define P_GE2D_SRC1_RANGE_MAP_CR_CTRL              (volatile unsigned long *)0xc1106394
//Bit 21:16     src1 prearbitor burst number
//Bit 13:8      src2 prearbitor burst number
//Bit 5:0       dst prearbitor burst number
#define P_GE2D_ARB_BURST_NUM                       (volatile unsigned long *)0xc1106398
//each 6bit ID, high 4bit are thread ID, low 2bits are the token
//Bit 21:16 src1 ID
//Bit 13:8 src2 ID
//Bit 5:0  dst ID
#define P_GE2D_TID_TOKEN                           (volatile unsigned long *)0xc110639c
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ge2d_regs.h
//
//========================================================================
//  MDEC Registers				    (12'h900 - 12'h9ff)
//
//========================================================================
// -----------------------------------------------
// CBUS_BASE:  MDEC_CBUS_BASE = 0x09
// -----------------------------------------------
#define P_MC_CTRL_REG                              (volatile unsigned long *)0xc1102400
#define P_MC_MB_INFO                               (volatile unsigned long *)0xc1102404
#define P_MC_PIC_INFO                              (volatile unsigned long *)0xc1102408
#define P_MC_HALF_PEL_ONE                          (volatile unsigned long *)0xc110240c
#define P_MC_HALF_PEL_TWO                          (volatile unsigned long *)0xc1102410
#define P_POWER_CTL_MC                             (volatile unsigned long *)0xc1102414
#define P_MC_CMD                                   (volatile unsigned long *)0xc1102418
#define P_MC_CTRL0                                 (volatile unsigned long *)0xc110241c
#define P_MC_PIC_W_H                               (volatile unsigned long *)0xc1102420
#define P_MC_STATUS0                               (volatile unsigned long *)0xc1102424
#define P_MC_STATUS1                               (volatile unsigned long *)0xc1102428
#define P_MC_CTRL1                                 (volatile unsigned long *)0xc110242c
#define P_MC_MIX_RATIO0                            (volatile unsigned long *)0xc1102430
#define P_MC_MIX_RATIO1                            (volatile unsigned long *)0xc1102434
#define P_MC_DP_MB_XY                              (volatile unsigned long *)0xc1102438
#define P_MC_OM_MB_XY                              (volatile unsigned long *)0xc110243c
#define P_PSCALE_RST                               (volatile unsigned long *)0xc1102440
#define P_PSCALE_CTRL                              (volatile unsigned long *)0xc1102444
#define P_PSCALE_PICI_W                            (volatile unsigned long *)0xc1102448
#define P_PSCALE_PICI_H                            (volatile unsigned long *)0xc110244c
#define P_PSCALE_PICO_W                            (volatile unsigned long *)0xc1102450
#define P_PSCALE_PICO_H                            (volatile unsigned long *)0xc1102454
#define P_PSCALE_PICO_START_X                      (volatile unsigned long *)0xc1102458
#define P_PSCALE_PICO_START_Y                      (volatile unsigned long *)0xc110245c
#define P_PSCALE_DUMMY                             (volatile unsigned long *)0xc1102460
#define P_PSCALE_FILT0_COEF0                       (volatile unsigned long *)0xc1102464
#define P_PSCALE_FILT0_COEF1                       (volatile unsigned long *)0xc1102468
#define P_PSCALE_CMD_CTRL                          (volatile unsigned long *)0xc110246c
#define P_PSCALE_CMD_BLK_X                         (volatile unsigned long *)0xc1102470
#define P_PSCALE_CMD_BLK_Y                         (volatile unsigned long *)0xc1102474
#define P_PSCALE_STATUS                            (volatile unsigned long *)0xc1102478
#define P_PSCALE_BMEM_ADDR                         (volatile unsigned long *)0xc110247c
#define P_PSCALE_BMEM_DAT                          (volatile unsigned long *)0xc1102480
#define P_PSCALE_DRAM_BUF_CTRL                     (volatile unsigned long *)0xc1102484
#define P_PSCALE_MCMD_CTRL                         (volatile unsigned long *)0xc1102488
#define P_PSCALE_MCMD_XSIZE                        (volatile unsigned long *)0xc110248c
#define P_PSCALE_MCMD_YSIZE                        (volatile unsigned long *)0xc1102490
#define P_PSCALE_RBUF_START_BLKX                   (volatile unsigned long *)0xc1102494
#define P_PSCALE_RBUF_START_BLKY                   (volatile unsigned long *)0xc1102498
//`define PSCALE_RBUF_MB_WIDTH   8'h27
#define P_PSCALE_PICO_SHIFT_XY                     (volatile unsigned long *)0xc11024a0
#define P_PSCALE_CTRL1                             (volatile unsigned long *)0xc11024a4
//Bit 15, wmask enable
//Bit 14:13, filt0 srckey_less, 
//Bit 12:11, filt1 srckey_less, in the case of the interpolated data is equal distance to 
//key data and normal data, 00: select normal data, 01: select right data, 10: select key data
//Bit 10:9, srckey mode, 00: equal, 01: less than or equal, 10: great than or equal
//Bit 8, src key enable
//Bit 7:0, y src key
#define P_PSCALE_SRCKEY_CTRL0                      (volatile unsigned long *)0xc11024a8
//Bit 15:8, cb src key
//Bit 7:0, cr src key
#define P_PSCALE_SRCKEY_CTRL1                      (volatile unsigned long *)0xc11024ac
//Bit 22:16 canvas_rd_addr2
//Bit 14:8 canvas_rd_addr1
//Bit 6:0 canvas_rd_addr1
#define P_PSCALE_CANVAS_RD_ADDR                    (volatile unsigned long *)0xc11024b0
//Bit 22:16 canvas_wr_addr2
//Bit 14:8 canvas_wr_addr1
//Bit 6:0 canvas_wr_addr1
#define P_PSCALE_CANVAS_WR_ADDR                    (volatile unsigned long *)0xc11024b4
//bit 13:8 pscale thread ID and token 
//bit 7 disable write response count adding to busy bit 
//bit 5:0  pscale prearbitor burst num
#define P_PSCALE_CTRL2                             (volatile unsigned long *)0xc11024b8
#define P_MC_MPORT_CTRL                            (volatile unsigned long *)0xc1102500
#define P_MC_MPORT_DAT                             (volatile unsigned long *)0xc1102504
#define P_MC_WT_PRED_CTRL                          (volatile unsigned long *)0xc1102508
#define P_MC_MBBOT_ST_EVEN_ADDR                    (volatile unsigned long *)0xc1102510
#define P_MC_MBBOT_ST_ODD_ADDR                     (volatile unsigned long *)0xc1102514
#define P_MC_DPDN_MB_XY                            (volatile unsigned long *)0xc1102518
#define P_MC_OMDN_MB_XY                            (volatile unsigned long *)0xc110251c
#define P_MC_HCMDBUF_H                             (volatile unsigned long *)0xc1102520
#define P_MC_HCMDBUF_L                             (volatile unsigned long *)0xc1102524
#define P_MC_HCMD_H                                (volatile unsigned long *)0xc1102528
#define P_MC_HCMD_L                                (volatile unsigned long *)0xc110252c
#define P_MC_IDCT_DAT                              (volatile unsigned long *)0xc1102530
#define P_MC_CTRL_GCLK_CTRL                        (volatile unsigned long *)0xc1102534
#define P_MC_OTHER_GCLK_CTRL                       (volatile unsigned long *)0xc1102538
//Bit 29:24, mbbot thread ID and token 
//Bit 21:16, mc read/write thread ID and token 
//Bit 13:8,  mbbot pre-arbitor burst number 
//Bit 5:0,   mc pre-arbitor burst number 
#define P_MC_CTRL2                                 (volatile unsigned long *)0xc110253c
// `define DBLK_QUANT            8'h76 // ONLY for $ucode/real/amrisc/rv.s, reg value from apollo
//`define ANC1_CANVAS_ADDR      8'h80
//`define ANC2_CANVAS_ADDR      8'h81
//`define REC_CANVAS_ADDR       8'h89
//`define MDEC_PIC_W          8'h8c
//`define MDEC_PIC_H          8'h8d
#define P_MDEC_PIC_DC_CTRL                         (volatile unsigned long *)0xc1102638
#define P_MDEC_PIC_DC_STATUS                       (volatile unsigned long *)0xc110263c
#define P_ANC0_CANVAS_ADDR                         (volatile unsigned long *)0xc1102640
#define P_ANC1_CANVAS_ADDR                         (volatile unsigned long *)0xc1102644
#define P_ANC2_CANVAS_ADDR                         (volatile unsigned long *)0xc1102648
#define P_ANC3_CANVAS_ADDR                         (volatile unsigned long *)0xc110264c
#define P_ANC4_CANVAS_ADDR                         (volatile unsigned long *)0xc1102650
#define P_ANC5_CANVAS_ADDR                         (volatile unsigned long *)0xc1102654
#define P_ANC6_CANVAS_ADDR                         (volatile unsigned long *)0xc1102658
#define P_ANC7_CANVAS_ADDR                         (volatile unsigned long *)0xc110265c
#define P_ANC8_CANVAS_ADDR                         (volatile unsigned long *)0xc1102660
#define P_ANC9_CANVAS_ADDR                         (volatile unsigned long *)0xc1102664
#define P_ANC10_CANVAS_ADDR                        (volatile unsigned long *)0xc1102668
#define P_ANC11_CANVAS_ADDR                        (volatile unsigned long *)0xc110266c
#define P_ANC12_CANVAS_ADDR                        (volatile unsigned long *)0xc1102670
#define P_ANC13_CANVAS_ADDR                        (volatile unsigned long *)0xc1102674
#define P_ANC14_CANVAS_ADDR                        (volatile unsigned long *)0xc1102678
#define P_ANC15_CANVAS_ADDR                        (volatile unsigned long *)0xc110267c
#define P_ANC16_CANVAS_ADDR                        (volatile unsigned long *)0xc1102680
#define P_ANC17_CANVAS_ADDR                        (volatile unsigned long *)0xc1102684
#define P_ANC18_CANVAS_ADDR                        (volatile unsigned long *)0xc1102688
#define P_ANC19_CANVAS_ADDR                        (volatile unsigned long *)0xc110268c
#define P_ANC20_CANVAS_ADDR                        (volatile unsigned long *)0xc1102690
#define P_ANC21_CANVAS_ADDR                        (volatile unsigned long *)0xc1102694
#define P_ANC22_CANVAS_ADDR                        (volatile unsigned long *)0xc1102698
#define P_ANC23_CANVAS_ADDR                        (volatile unsigned long *)0xc110269c
#define P_ANC24_CANVAS_ADDR                        (volatile unsigned long *)0xc11026a0
#define P_ANC25_CANVAS_ADDR                        (volatile unsigned long *)0xc11026a4
#define P_ANC26_CANVAS_ADDR                        (volatile unsigned long *)0xc11026a8
#define P_ANC27_CANVAS_ADDR                        (volatile unsigned long *)0xc11026ac
#define P_ANC28_CANVAS_ADDR                        (volatile unsigned long *)0xc11026b0
#define P_ANC29_CANVAS_ADDR                        (volatile unsigned long *)0xc11026b4
#define P_ANC30_CANVAS_ADDR                        (volatile unsigned long *)0xc11026b8
#define P_ANC31_CANVAS_ADDR                        (volatile unsigned long *)0xc11026bc
#define P_DBKR_CANVAS_ADDR                         (volatile unsigned long *)0xc11026c0
#define P_DBKW_CANVAS_ADDR                         (volatile unsigned long *)0xc11026c4
#define P_REC_CANVAS_ADDR                          (volatile unsigned long *)0xc11026c8
//28:24, read/write, current canvas idx, used in h264 only now
//23:0, read only, current canvas address, 23:16, Cr canvas addr, 15:8, Cb canvas addr, 7:0, Y  canvas addr
#define P_CURR_CANVAS_CTRL                         (volatile unsigned long *)0xc11026cc
#define P_AV_SCRATCH_0                             (volatile unsigned long *)0xc1102700
#define P_AV_SCRATCH_1                             (volatile unsigned long *)0xc1102704
#define P_AV_SCRATCH_2                             (volatile unsigned long *)0xc1102708
#define P_AV_SCRATCH_3                             (volatile unsigned long *)0xc110270c
#define P_AV_SCRATCH_4                             (volatile unsigned long *)0xc1102710
#define P_AV_SCRATCH_5                             (volatile unsigned long *)0xc1102714
#define P_AV_SCRATCH_6                             (volatile unsigned long *)0xc1102718
#define P_AV_SCRATCH_7                             (volatile unsigned long *)0xc110271c
#define P_AV_SCRATCH_8                             (volatile unsigned long *)0xc1102720
#define P_AV_SCRATCH_9                             (volatile unsigned long *)0xc1102724
#define P_AV_SCRATCH_A                             (volatile unsigned long *)0xc1102728
#define P_AV_SCRATCH_B                             (volatile unsigned long *)0xc110272c
#define P_AV_SCRATCH_C                             (volatile unsigned long *)0xc1102730
#define P_AV_SCRATCH_D                             (volatile unsigned long *)0xc1102734
#define P_AV_SCRATCH_E                             (volatile unsigned long *)0xc1102738
#define P_AV_SCRATCH_F                             (volatile unsigned long *)0xc110273c
#define P_AV_SCRATCH_G                             (volatile unsigned long *)0xc1102740
#define P_AV_SCRATCH_H                             (volatile unsigned long *)0xc1102744
#define P_AV_SCRATCH_I                             (volatile unsigned long *)0xc1102748
#define P_AV_SCRATCH_J                             (volatile unsigned long *)0xc110274c
#define P_AV_SCRATCH_K                             (volatile unsigned long *)0xc1102750
#define P_AV_SCRATCH_L                             (volatile unsigned long *)0xc1102754
#define P_AV_SCRATCH_M                             (volatile unsigned long *)0xc1102758
#define P_AV_SCRATCH_N                             (volatile unsigned long *)0xc110275c
// bit[29:24] A_brst_num_co_mb
// bit[21:16] A_id_co_mb
// bit[11:0] wrrsp_count_co_mb
#define P_WRRSP_CO_MB                              (volatile unsigned long *)0xc1102760
// bit[29:24] A_brst_num_dcac
// bit[21:16] A_id_dcac
// bit[11:0] wrrsp_count_dcac
#define P_WRRSP_DCAC                               (volatile unsigned long *)0xc1102764
//======================================
//  MC Control Register Bits
//
//======================================
// For bits, just copy the defines...don't translate to addresses
    #define MC_ENABLE	    0x0001
    //#define MC_RESET	    0x0002
    #define SKIP_MB		    0x0004

//======================================
//  MB Info Register Bits
//
//======================================
    #define INTRA_MB	    0x0001

    #define BWD_PRED	    0x0004
    #define FWD_PRED	    0x0008

    #define FLD_MOT		    0x0100
    #define FRM_16x8_MOT	0x0200
    #define DUAL_PRM_MOT	0x0300

    #define FRM_DCT		    0x0000	    // Bit 10
    #define FLD_DCT		    0x0400

//======================================
//  MB Info Register Bits
//
//======================================
    #define I_PIC		    0x0001
    #define P_PIC		    0x0002
    #define B_PIC		    0x0003
    
    #define FLD_PIC		    0x0000	    // Bit 8
    #define FRM_PIC		    0x0100	    
//========================================================================
// DBLK Register:  12'h950 - 12'h97f 
//========================================================================
#define P_DBLK_RST                                 (volatile unsigned long *)0xc1102540
#define P_DBLK_CTRL                                (volatile unsigned long *)0xc1102544
#define P_DBLK_MB_WID_HEIGHT                       (volatile unsigned long *)0xc1102548
#define P_DBLK_STATUS                              (volatile unsigned long *)0xc110254c
#define P_DBLK_CMD_CTRL                            (volatile unsigned long *)0xc1102550
#define P_DBLK_MB_XY                               (volatile unsigned long *)0xc1102554
#define P_DBLK_QP                                  (volatile unsigned long *)0xc1102558
#define P_DBLK_Y_BHFILT                            (volatile unsigned long *)0xc110255c
#define P_DBLK_Y_BHFILT_HIGH                       (volatile unsigned long *)0xc1102560
#define P_DBLK_Y_BVFILT                            (volatile unsigned long *)0xc1102564
#define P_DBLK_CB_BFILT                            (volatile unsigned long *)0xc1102568
#define P_DBLK_CR_BFILT                            (volatile unsigned long *)0xc110256c
#define P_DBLK_Y_HFILT                             (volatile unsigned long *)0xc1102570
#define P_DBLK_Y_HFILT_HIGH                        (volatile unsigned long *)0xc1102574
#define P_DBLK_Y_VFILT                             (volatile unsigned long *)0xc1102578
#define P_DBLK_CB_FILT                             (volatile unsigned long *)0xc110257c
#define P_DBLK_CR_FILT                             (volatile unsigned long *)0xc1102580
#define P_DBLK_BETAX_QP_SEL                        (volatile unsigned long *)0xc1102584
#define P_DBLK_CLIP_CTRL0                          (volatile unsigned long *)0xc1102588
#define P_DBLK_CLIP_CTRL1                          (volatile unsigned long *)0xc110258c
#define P_DBLK_CLIP_CTRL2                          (volatile unsigned long *)0xc1102590
#define P_DBLK_CLIP_CTRL3                          (volatile unsigned long *)0xc1102594
#define P_DBLK_CLIP_CTRL4                          (volatile unsigned long *)0xc1102598
#define P_DBLK_CLIP_CTRL5                          (volatile unsigned long *)0xc110259c
#define P_DBLK_CLIP_CTRL6                          (volatile unsigned long *)0xc11025a0
#define P_DBLK_CLIP_CTRL7                          (volatile unsigned long *)0xc11025a4
#define P_DBLK_CLIP_CTRL8                          (volatile unsigned long *)0xc11025a8
#define P_DBLK_STATUS1                             (volatile unsigned long *)0xc11025ac
#define P_DBLK_GCLK_FREE                           (volatile unsigned long *)0xc11025b0
#define P_DBLK_GCLK_OFF                            (volatile unsigned long *)0xc11025b4
// bit 15:0
#define P_DBLK_CBPY                                (volatile unsigned long *)0xc11025c0
// bit 11:8 -- deblk_cbpy_bottom
// bit 7:4 -- deblk_cbpy_left
// bit 3:0 -- deblk_cbpy_top
#define P_DBLK_CBPY_ADJ                            (volatile unsigned long *)0xc11025c4
// bit 7:0 -- deblk_cbpc
#define P_DBLK_CBPC                                (volatile unsigned long *)0xc11025c8
// bit 15 -- bottom_mb
// bit 14 -- left_mb
// bit 13 -- top_mb
// bit 12 -- reserved
// bit 11:8 -- deblk_cbpc_bottom
// bit 7:4 -- deblk_cbpc_left
// bit 3:0 -- deblk_cbpc_top
#define P_DBLK_CBPC_ADJ                            (volatile unsigned long *)0xc11025cc
// bit 15:8 -- deblk_hmvd   -- {left_1, left_0, below_1, below_0, block3-0} 
// bit 7:0 -- deblk_vmvd    -- {top_1, top_0, below_1, below_0, block3-0} 
#define P_DBLK_VHMVD                               (volatile unsigned long *)0xc11025d0
// bit 13:12 -- right_vmvd
// bit 11 -- right_above_vmvd
// bit 10 -- left_below_hmvd
// bit 9 -- disable_dblk_luma  
// bit 8 -- disable_dblk_chroma
// bit 7 -- bBelowRefDiff
// bit 6 -- bLeftRefDiff
// bit 5 -- bAboveRefDiff
// bit 4 -- reserved
// bit 3 -- s_below
// bit 2 -- s_left
// bit 1 -- s_above
// bit 0 -- s 
#define P_DBLK_STRONG                              (volatile unsigned long *)0xc11025d4
// bit 14:10 -- PQUANT 
// bit 9:5 -- left_PQUANT 
// bit 4:0 -- top_PQUANT 
#define P_DBLK_RV8_QUANT                           (volatile unsigned long *)0xc11025d8
#define P_DBLK_CBUS_HCMD2                          (volatile unsigned long *)0xc11025dc
#define P_DBLK_CBUS_HCMD1                          (volatile unsigned long *)0xc11025e0
#define P_DBLK_CBUS_HCMD0                          (volatile unsigned long *)0xc11025e4
#define P_DBLK_VLD_HCMD2                           (volatile unsigned long *)0xc11025e8
#define P_DBLK_VLD_HCMD1                           (volatile unsigned long *)0xc11025ec
#define P_DBLK_VLD_HCMD0                           (volatile unsigned long *)0xc11025f0
#define P_DBLK_OST_YBASE                           (volatile unsigned long *)0xc11025f4
#define P_DBLK_OST_CBCRDIFF                        (volatile unsigned long *)0xc11025f8
//13:8 dblk thread ID and token 
//5:0  dblk prearbitor burst num
#define P_DBLK_CTRL1                               (volatile unsigned long *)0xc11025fc
//DBLK last address 12'h97f
//========================================================================
//  Video Interface				    (12'ha00 - 12'hb7f)
//
//========================================================================
// NOTE:  The BASE above applies to all of the files below
//
// Reading file:  vregs.h
//
//===========================================================================
// Video Interface Registers    0xa00 - 0xaff
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  VIU_CBUS_BASE = 0x1a
// -----------------------------------------------
#define P_VIU_ADDR_START                           (volatile unsigned long *)0xc1106800
#define P_VIU_ADDR_END                             (volatile unsigned long *)0xc1106bfc
#define P_TRACE_REG                                (volatile unsigned long *)0xc1106820
//------------------------------------------------------------------------------
// OSD1 registers
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit 10: 9 Reserved for control signals
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define P_VIU_OSD1_CTRL_STAT                       (volatile unsigned long *)0xc1106840
// Bit 31: 4 Reserved
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, alpha_expand_mode
// Bit     0 RW, color_expand_mode
#define P_VIU_OSD1_CTRL_STAT2                      (volatile unsigned long *)0xc11068b4
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define P_VIU_OSD1_COLOR_ADDR                      (volatile unsigned long *)0xc1106844
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU_OSD1_COLOR                           (volatile unsigned long *)0xc1106848
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU_OSD1_TCOLOR_AG0                      (volatile unsigned long *)0xc110685c
#define P_VIU_OSD1_TCOLOR_AG1                      (volatile unsigned long *)0xc1106860
#define P_VIU_OSD1_TCOLOR_AG2                      (volatile unsigned long *)0xc1106864
#define P_VIU_OSD1_TCOLOR_AG3                      (volatile unsigned long *)0xc1106868
// Bit 31:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define P_VIU_OSD1_BLK0_CFG_W0                     (volatile unsigned long *)0xc110686c
#define P_VIU_OSD1_BLK1_CFG_W0                     (volatile unsigned long *)0xc110687c
#define P_VIU_OSD1_BLK2_CFG_W0                     (volatile unsigned long *)0xc110688c
#define P_VIU_OSD1_BLK3_CFG_W0                     (volatile unsigned long *)0xc110689c
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define P_VIU_OSD1_BLK0_CFG_W1                     (volatile unsigned long *)0xc1106870
#define P_VIU_OSD1_BLK1_CFG_W1                     (volatile unsigned long *)0xc1106880
#define P_VIU_OSD1_BLK2_CFG_W1                     (volatile unsigned long *)0xc1106890
#define P_VIU_OSD1_BLK3_CFG_W1                     (volatile unsigned long *)0xc11068a0
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define P_VIU_OSD1_BLK0_CFG_W2                     (volatile unsigned long *)0xc1106874
#define P_VIU_OSD1_BLK1_CFG_W2                     (volatile unsigned long *)0xc1106884
#define P_VIU_OSD1_BLK2_CFG_W2                     (volatile unsigned long *)0xc1106894
#define P_VIU_OSD1_BLK3_CFG_W2                     (volatile unsigned long *)0xc11068a4
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define P_VIU_OSD1_BLK0_CFG_W3                     (volatile unsigned long *)0xc1106878
#define P_VIU_OSD1_BLK1_CFG_W3                     (volatile unsigned long *)0xc1106888
#define P_VIU_OSD1_BLK2_CFG_W3                     (volatile unsigned long *)0xc1106898
#define P_VIU_OSD1_BLK3_CFG_W3                     (volatile unsigned long *)0xc11068a8
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define P_VIU_OSD1_BLK0_CFG_W4                     (volatile unsigned long *)0xc110684c
#define P_VIU_OSD1_BLK1_CFG_W4                     (volatile unsigned long *)0xc1106850
#define P_VIU_OSD1_BLK2_CFG_W4                     (volatile unsigned long *)0xc1106854
#define P_VIU_OSD1_BLK3_CFG_W4                     (volatile unsigned long *)0xc1106858
// Bit    31 Reserved
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit 29:21 R,  fifo_count
// Bit 20:19 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT 
// Bit    18 R,  fifo_overflow
//
// Bit 17:12 RW, fifo_depth_val, max value=32: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel. 0=24(default), 1=32, 2=48, 3=64.
// Bit  9: 5 RW, hold_fifo_lines
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define P_VIU_OSD1_FIFO_CTRL_STAT                  (volatile unsigned long *)0xc11068ac
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define P_VIU_OSD1_TEST_RDDATA                     (volatile unsigned long *)0xc11068b0
//------------------------------------------------------------------------------
// OSD2 registers
//------------------------------------------------------------------------------
// Bit    31 Reserved
// Bit    30 RW, enable_free_clk: 1=use free-running clock to drive logics;
//                                0=use gated clock for low power.
// Bit    29 R, test_rd_dsr
// Bit    28 R, osd_done
// Bit 27:24 R, osd_blk_mode
// Bit 23:22 R, osd_blk_ptr
// Bit    21 R, osd_enable
//
// Bit 20:12 RW, global_alpha
// Bit    11 RW, test_rd_en
// Bit    10 RW, hl2_en
// Bit     9 RW, hl1_en
// Bit  8: 5 RW, ctrl_mtch_y
// Bit     4 RW, ctrl_422to444
// Bit  3: 0 RW, osd_blk_enable. Bit 0 to enable block 0: 1=enable, 0=disable;
//                               Bit 1 to enable block 1, and so on.
#define P_VIU_OSD2_CTRL_STAT                       (volatile unsigned long *)0xc11068c0
// Bit 31: 4 Reserved
// Bit     3 RW, rgb2yuv_full_range
// Bit     2 RW, alpha_9b_mode
// Bit     1 RW, alpha_expand_mode
// Bit     0 RW, color_expand_mode
#define P_VIU_OSD2_CTRL_STAT2                      (volatile unsigned long *)0xc1106934
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define P_VIU_OSD2_COLOR_ADDR                      (volatile unsigned long *)0xc11068c4
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU_OSD2_COLOR                           (volatile unsigned long *)0xc11068c8
// Bit 31:28 Reserved
// Bit 27:16 RW, hl[1-2]_h/v_start
// Bit 15:12 Reserved
// Bit 11: 0 RW, hl[1-2]_h/v_end
#define P_VIU_OSD2_HL1_H_START_END                 (volatile unsigned long *)0xc11068cc
#define P_VIU_OSD2_HL1_V_START_END                 (volatile unsigned long *)0xc11068d0
#define P_VIU_OSD2_HL2_H_START_END                 (volatile unsigned long *)0xc11068d4
#define P_VIU_OSD2_HL2_V_START_END                 (volatile unsigned long *)0xc11068d8
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define P_VIU_OSD2_TCOLOR_AG0                      (volatile unsigned long *)0xc11068dc
#define P_VIU_OSD2_TCOLOR_AG1                      (volatile unsigned long *)0xc11068e0
#define P_VIU_OSD2_TCOLOR_AG2                      (volatile unsigned long *)0xc11068e4
#define P_VIU_OSD2_TCOLOR_AG3                      (volatile unsigned long *)0xc11068e8
// Bit 31:24 Reserved
// Bit 23:16 RW, tbl_addr
// Bit    15 RW, little_endian: 0=big endian, 1=little endian
// Bit    14 RW, rpt_y
// Bit 13:12 RW, interp_ctrl. 0x=No interpolation; 10=Interpolate with previous
//                            pixel; 11=Interpolate with the average value
//                            between previous and next pixel.
// Bit 11: 8 RW, osd_blk_mode
// Bit     7 RW, rgb_en
// Bit     6 RW, tc_alpha_en
// Bit  5: 2 RW, color_matrix
// Bit     1 RW, interlace_en
// Bit     0 RW, interlace_sel_odd
#define P_VIU_OSD2_BLK0_CFG_W0                     (volatile unsigned long *)0xc11068ec
#define P_VIU_OSD2_BLK1_CFG_W0                     (volatile unsigned long *)0xc11068fc
#define P_VIU_OSD2_BLK2_CFG_W0                     (volatile unsigned long *)0xc110690c
#define P_VIU_OSD2_BLK3_CFG_W0                     (volatile unsigned long *)0xc110691c
// Bit 31:29 Reserved
// Bit 28:16 RW, x_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, x_start
#define P_VIU_OSD2_BLK0_CFG_W1                     (volatile unsigned long *)0xc11068f0
#define P_VIU_OSD2_BLK1_CFG_W1                     (volatile unsigned long *)0xc1106900
#define P_VIU_OSD2_BLK2_CFG_W1                     (volatile unsigned long *)0xc1106910
#define P_VIU_OSD2_BLK3_CFG_W1                     (volatile unsigned long *)0xc1106920
// Bit 31:29 Reserved
// Bit 28:16 RW, y_end
// Bit 15:13 Reserved
// Bit 12: 0 RW, y_start
#define P_VIU_OSD2_BLK0_CFG_W2                     (volatile unsigned long *)0xc11068f4
#define P_VIU_OSD2_BLK1_CFG_W2                     (volatile unsigned long *)0xc1106904
#define P_VIU_OSD2_BLK2_CFG_W2                     (volatile unsigned long *)0xc1106914
#define P_VIU_OSD2_BLK3_CFG_W2                     (volatile unsigned long *)0xc1106924
// Bit 31:28 Reserved
// Bit 27:16 RW, h_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, h_start
#define P_VIU_OSD2_BLK0_CFG_W3                     (volatile unsigned long *)0xc11068f8
#define P_VIU_OSD2_BLK1_CFG_W3                     (volatile unsigned long *)0xc1106908
#define P_VIU_OSD2_BLK2_CFG_W3                     (volatile unsigned long *)0xc1106918
#define P_VIU_OSD2_BLK3_CFG_W3                     (volatile unsigned long *)0xc1106928
// Bit 31:28 Reserved
// Bit 27:16 RW, v_end
// Bit 15:12 Reserved
// Bit 11: 0 RW, v_start
#define P_VIU_OSD2_BLK0_CFG_W4                     (volatile unsigned long *)0xc1106990
#define P_VIU_OSD2_BLK1_CFG_W4                     (volatile unsigned long *)0xc1106994
#define P_VIU_OSD2_BLK2_CFG_W4                     (volatile unsigned long *)0xc1106998
#define P_VIU_OSD2_BLK3_CFG_W4                     (volatile unsigned long *)0xc110699c
// Bit    31 Reserved
// Bit    30 RW, byte_swap: In addition to endian control, further define
//               whether to swap upper and lower byte within a 16-bit mem word.
//               0=No swap; 1=Swap data[15:0] to be {data[7:0], data[15:8]}
// Bit 29:21 R,  fifo_count
// Bit 20:19 R,  fifo_st. 0=IDLE, 1=FILL, 2=ABORT 
// Bit    18 R,  fifo_overflow
//
// Bit 17:12 RW, fifo_depth_val, max value=32: set actual fifo depth to fifo_depth_val*8.
// Bit 11:10 RW, burst_len_sel. 0=24(default), 1=32, 2=48, 3=64.
// Bit  9: 5 RW, hold_fifo_lines
// Bit     4 RW, clear_err: one pulse to clear fifo_overflow
// Bit     3 RW, fifo_sync_rst
// Bit  2: 1 RW, endian
// Bit     0 RW, urgent
#define P_VIU_OSD2_FIFO_CTRL_STAT                  (volatile unsigned long *)0xc110692c
// Bit 31:24 R, Y or R
// Bit 23:16 R, Cb or G
// Bit 15: 8 R, Cr or B
// Bit  7: 0 R, Output Alpha[8:1]
#define P_VIU_OSD2_TEST_RDDATA                     (volatile unsigned long *)0xc1106930
//------------------------------------------------------------------------------
// VD1 path
//------------------------------------------------------------------------------
#define P_VD1_IF0_GEN_REG                          (volatile unsigned long *)0xc1106940
#define P_VD1_IF0_CANVAS0                          (volatile unsigned long *)0xc1106944
#define P_VD1_IF0_CANVAS1                          (volatile unsigned long *)0xc1106948
#define P_VD1_IF0_LUMA_X0                          (volatile unsigned long *)0xc110694c
#define P_VD1_IF0_LUMA_Y0                          (volatile unsigned long *)0xc1106950
#define P_VD1_IF0_CHROMA_X0                        (volatile unsigned long *)0xc1106954
#define P_VD1_IF0_CHROMA_Y0                        (volatile unsigned long *)0xc1106958
#define P_VD1_IF0_LUMA_X1                          (volatile unsigned long *)0xc110695c
#define P_VD1_IF0_LUMA_Y1                          (volatile unsigned long *)0xc1106960
#define P_VD1_IF0_CHROMA_X1                        (volatile unsigned long *)0xc1106964
#define P_VD1_IF0_CHROMA_Y1                        (volatile unsigned long *)0xc1106968
#define P_VD1_IF0_RPT_LOOP                         (volatile unsigned long *)0xc110696c
#define P_VD1_IF0_LUMA0_RPT_PAT                    (volatile unsigned long *)0xc1106970
#define P_VD1_IF0_CHROMA0_RPT_PAT                  (volatile unsigned long *)0xc1106974
#define P_VD1_IF0_LUMA1_RPT_PAT                    (volatile unsigned long *)0xc1106978
#define P_VD1_IF0_CHROMA1_RPT_PAT                  (volatile unsigned long *)0xc110697c
#define P_VD1_IF0_LUMA_PSEL                        (volatile unsigned long *)0xc1106980
#define P_VD1_IF0_CHROMA_PSEL                      (volatile unsigned long *)0xc1106984
#define P_VD1_IF0_DUMMY_PIXEL                      (volatile unsigned long *)0xc1106988
#define P_VD1_IF0_LUMA_FIFO_SIZE                   (volatile unsigned long *)0xc110698c
#define P_VD1_IF0_RANGE_MAP_Y                      (volatile unsigned long *)0xc11069a8
#define P_VD1_IF0_RANGE_MAP_CB                     (volatile unsigned long *)0xc11069ac
#define P_VD1_IF0_RANGE_MAP_CR                     (volatile unsigned long *)0xc11069b0
//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
//Bit 27:24 horizontal formatter initial phase
//Bit 23    horizontal formatter repeat pixel 0 enable
//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    horizontal formatter enable
//Bit 19    if true, always use phase0 while vertical formater, meaning always
//          repeat data, no interpolation
//Bit 18    if true, disable vertical formatter chroma repeat last line
//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    veritcal formatter repeat line 0 enable
//Bit 15:12 vertical formatter skip line num at the beginning
//Bit 11:8  vertical formatter initial phase
//Bit 7:1   vertical formatter phase step (3.4)  
//Bit 0     vertical formatter enable
#define P_VIU_VD1_FMT_CTRL                         (volatile unsigned long *)0xc11069a0
//Bit 27:16  horizontal formatter width
//Bit 11:0   vertical formatter width
#define P_VIU_VD1_FMT_W                            (volatile unsigned long *)0xc11069a4
//------------------------------------------------------------------------------
// VD2 path
//------------------------------------------------------------------------------
#define P_VD2_IF0_GEN_REG                          (volatile unsigned long *)0xc11069c0
#define P_VD2_IF0_CANVAS0                          (volatile unsigned long *)0xc11069c4
#define P_VD2_IF0_CANVAS1                          (volatile unsigned long *)0xc11069c8
#define P_VD2_IF0_LUMA_X0                          (volatile unsigned long *)0xc11069cc
#define P_VD2_IF0_LUMA_Y0                          (volatile unsigned long *)0xc11069d0
#define P_VD2_IF0_CHROMA_X0                        (volatile unsigned long *)0xc11069d4
#define P_VD2_IF0_CHROMA_Y0                        (volatile unsigned long *)0xc11069d8
#define P_VD2_IF0_LUMA_X1                          (volatile unsigned long *)0xc11069dc
#define P_VD2_IF0_LUMA_Y1                          (volatile unsigned long *)0xc11069e0
#define P_VD2_IF0_CHROMA_X1                        (volatile unsigned long *)0xc11069e4
#define P_VD2_IF0_CHROMA_Y1                        (volatile unsigned long *)0xc11069e8
#define P_VD2_IF0_RPT_LOOP                         (volatile unsigned long *)0xc11069ec
#define P_VD2_IF0_LUMA0_RPT_PAT                    (volatile unsigned long *)0xc11069f0
#define P_VD2_IF0_CHROMA0_RPT_PAT                  (volatile unsigned long *)0xc11069f4
#define P_VD2_IF0_LUMA1_RPT_PAT                    (volatile unsigned long *)0xc11069f8
#define P_VD2_IF0_CHROMA1_RPT_PAT                  (volatile unsigned long *)0xc11069fc
#define P_VD2_IF0_LUMA_PSEL                        (volatile unsigned long *)0xc1106a00
#define P_VD2_IF0_CHROMA_PSEL                      (volatile unsigned long *)0xc1106a04
#define P_VD2_IF0_DUMMY_PIXEL                      (volatile unsigned long *)0xc1106a08
#define P_VD2_IF0_LUMA_FIFO_SIZE                   (volatile unsigned long *)0xc1106a0c
#define P_VD2_IF0_RANGE_MAP_Y                      (volatile unsigned long *)0xc1106a28
#define P_VD2_IF0_RANGE_MAP_CB                     (volatile unsigned long *)0xc1106a2c
#define P_VD2_IF0_RANGE_MAP_CR                     (volatile unsigned long *)0xc1106a30
//Bit 28    if true, horizontal formatter use repeating to generete pixel, otherwise use bilinear interpolation
//Bit 27:24 horizontal formatter initial phase
//Bit 23    horizontal formatter repeat pixel 0 enable
//Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1
//Bit 20    horizontal formatter enable
//Bit 17    veritcal formatter dont need repeat line on phase0, 1: enable, 0: disable
//Bit 16    veritcal formatter repeat line 0 enable
//Bit 15:12 vertical formatter skip line num at the beginning
//Bit 11:8  vertical formatter initial phase
//Bit 7:1   vertical formatter phase step (3.4)  
//Bit 0     vertical formatter enable
#define P_VIU_VD2_FMT_CTRL                         (volatile unsigned long *)0xc1106a20
//Bit 27:16  horizontal formatter width
//Bit 11:0   vertical formatter width
#define P_VIU_VD2_FMT_W                            (volatile unsigned long *)0xc1106a24
//DEINTERLACE module start from 8'h90 end to 8'hff
#define P_DI_PRE_CTRL                              (volatile unsigned long *)0xc1106a40
#define P_DI_POST_CTRL                             (volatile unsigned long *)0xc1106a44
#define P_DI_POST_SIZE                             (volatile unsigned long *)0xc1106a48
#define P_DI_PRE_SIZE                              (volatile unsigned long *)0xc1106a4c
#define P_DI_EI_CTRL0                              (volatile unsigned long *)0xc1106a50
#define P_DI_EI_CTRL1                              (volatile unsigned long *)0xc1106a54
#define P_DI_EI_CTRL2                              (volatile unsigned long *)0xc1106a58
#define P_DI_NRMTN_CTRL0                           (volatile unsigned long *)0xc1106a5c
#define P_DI_NR_CTRL1                              (volatile unsigned long *)0xc1106a60
#define P_DI_BLEND_CTRL                            (volatile unsigned long *)0xc1106a64
#define P_DI_BLEND_REG0_X                          (volatile unsigned long *)0xc1106a68
#define P_DI_BLEND_REG0_Y                          (volatile unsigned long *)0xc1106a6c
#define P_DI_BLEND_REG1_X                          (volatile unsigned long *)0xc1106a70
#define P_DI_BLEND_REG1_Y                          (volatile unsigned long *)0xc1106a74
#define P_DI_BLEND_REG2_X                          (volatile unsigned long *)0xc1106a78
#define P_DI_BLEND_REG2_Y                          (volatile unsigned long *)0xc1106a7c
#define P_DI_BLEND_REG3_X                          (volatile unsigned long *)0xc1106a80
#define P_DI_BLEND_REG3_Y                          (volatile unsigned long *)0xc1106a84
// DEINTERLACE mode check.
#define P_DI_MC_REG0_X                             (volatile unsigned long *)0xc1106a88
#define P_DI_MC_REG0_Y                             (volatile unsigned long *)0xc1106a8c
#define P_DI_MC_REG1_X                             (volatile unsigned long *)0xc1106a90
#define P_DI_MC_REG1_Y                             (volatile unsigned long *)0xc1106a94
#define P_DI_MC_REG2_X                             (volatile unsigned long *)0xc1106a98
#define P_DI_MC_REG2_Y                             (volatile unsigned long *)0xc1106a9c
#define P_DI_MC_REG3_X                             (volatile unsigned long *)0xc1106aa0
#define P_DI_MC_REG3_Y                             (volatile unsigned long *)0xc1106aa4
#define P_DI_MC_REG4_X                             (volatile unsigned long *)0xc1106aa8
#define P_DI_MC_REG4_Y                             (volatile unsigned long *)0xc1106aac
#define P_DI_MC_32LVL0                             (volatile unsigned long *)0xc1106ab0
#define P_DI_MC_32LVL1                             (volatile unsigned long *)0xc1106ab4
#define P_DI_MC_22LVL0                             (volatile unsigned long *)0xc1106ab8
#define P_DI_MC_22LVL1                             (volatile unsigned long *)0xc1106abc
#define P_DI_MC_22LVL2                             (volatile unsigned long *)0xc1106ac0
#define P_DI_MC_CTRL                               (volatile unsigned long *)0xc1106ac4
#define P_DI_INTR_CTRL                             (volatile unsigned long *)0xc1106ac8
#define P_DI_INFO_ADDR                             (volatile unsigned long *)0xc1106acc
#define P_DI_INFO_DATA                             (volatile unsigned long *)0xc1106ad0
#define P_DI_PRE_HOLD                              (volatile unsigned long *)0xc1106ad4
#define P_DI_NRWR_X                                (volatile unsigned long *)0xc1106b00
#define P_DI_NRWR_Y                                (volatile unsigned long *)0xc1106b04
#define P_DI_NRWR_CTRL                             (volatile unsigned long *)0xc1106b08
#define P_DI_MTNWR_X                               (volatile unsigned long *)0xc1106b0c
#define P_DI_MTNWR_Y                               (volatile unsigned long *)0xc1106b10
#define P_DI_MTNWR_CTRL                            (volatile unsigned long *)0xc1106b14
#define P_DI_DIWR_X                                (volatile unsigned long *)0xc1106b18
#define P_DI_DIWR_Y                                (volatile unsigned long *)0xc1106b1c
#define P_DI_DIWR_CTRL                             (volatile unsigned long *)0xc1106b20
#define P_DI_MTNCRD_X                              (volatile unsigned long *)0xc1106b24
#define P_DI_MTNCRD_Y                              (volatile unsigned long *)0xc1106b28
#define P_DI_MTNPRD_X                              (volatile unsigned long *)0xc1106b2c
#define P_DI_MTNPRD_Y                              (volatile unsigned long *)0xc1106b30
#define P_DI_MTNRD_CTRL                            (volatile unsigned long *)0xc1106b34
#define P_DI_INP_GEN_REG                           (volatile unsigned long *)0xc1106b38
#define P_DI_INP_CANVAS0                           (volatile unsigned long *)0xc1106b3c
#define P_DI_INP_LUMA_X0                           (volatile unsigned long *)0xc1106b40
#define P_DI_INP_LUMA_Y0                           (volatile unsigned long *)0xc1106b44
#define P_DI_INP_CHROMA_X0                         (volatile unsigned long *)0xc1106b48
#define P_DI_INP_CHROMA_Y0                         (volatile unsigned long *)0xc1106b4c
#define P_DI_INP_RPT_LOOP                          (volatile unsigned long *)0xc1106b50
#define P_DI_INP_LUMA0_RPT_PAT                     (volatile unsigned long *)0xc1106b54
#define P_DI_INP_CHROMA0_RPT_PAT                   (volatile unsigned long *)0xc1106b58
#define P_DI_INP_DUMMY_PIXEL                       (volatile unsigned long *)0xc1106b5c
#define P_DI_INP_LUMA_FIFO_SIZE                    (volatile unsigned long *)0xc1106b60
#define P_DI_INP_RANGE_MAP_Y                       (volatile unsigned long *)0xc1106ae8
#define P_DI_INP_RANGE_MAP_CB                      (volatile unsigned long *)0xc1106aec
#define P_DI_INP_RANGE_MAP_CR                      (volatile unsigned long *)0xc1106af0
#define P_DI_INP_FMT_CTRL                          (volatile unsigned long *)0xc1106b64
#define P_DI_INP_FMT_W                             (volatile unsigned long *)0xc1106b68
#define P_DI_MEM_GEN_REG                           (volatile unsigned long *)0xc1106b6c
#define P_DI_MEM_CANVAS0                           (volatile unsigned long *)0xc1106b70
#define P_DI_MEM_LUMA_X0                           (volatile unsigned long *)0xc1106b74
#define P_DI_MEM_LUMA_Y0                           (volatile unsigned long *)0xc1106b78
#define P_DI_MEM_CHROMA_X0                         (volatile unsigned long *)0xc1106b7c
#define P_DI_MEM_CHROMA_Y0                         (volatile unsigned long *)0xc1106b80
#define P_DI_MEM_RPT_LOOP                          (volatile unsigned long *)0xc1106b84
#define P_DI_MEM_LUMA0_RPT_PAT                     (volatile unsigned long *)0xc1106b88
#define P_DI_MEM_CHROMA0_RPT_PAT                   (volatile unsigned long *)0xc1106b8c
#define P_DI_MEM_DUMMY_PIXEL                       (volatile unsigned long *)0xc1106b90
#define P_DI_MEM_LUMA_FIFO_SIZE                    (volatile unsigned long *)0xc1106b94
#define P_DI_MEM_RANGE_MAP_Y                       (volatile unsigned long *)0xc1106af4
#define P_DI_MEM_RANGE_MAP_CB                      (volatile unsigned long *)0xc1106af8
#define P_DI_MEM_RANGE_MAP_CR                      (volatile unsigned long *)0xc1106afc
#define P_DI_MEM_FMT_CTRL                          (volatile unsigned long *)0xc1106b98
#define P_DI_MEM_FMT_W                             (volatile unsigned long *)0xc1106b9c
#define P_DI_IF1_GEN_REG                           (volatile unsigned long *)0xc1106ba0
#define P_DI_IF1_CANVAS0                           (volatile unsigned long *)0xc1106ba4
#define P_DI_IF1_LUMA_X0                           (volatile unsigned long *)0xc1106ba8
#define P_DI_IF1_LUMA_Y0                           (volatile unsigned long *)0xc1106bac
#define P_DI_IF1_CHROMA_X0                         (volatile unsigned long *)0xc1106bb0
#define P_DI_IF1_CHROMA_Y0                         (volatile unsigned long *)0xc1106bb4
#define P_DI_IF1_RPT_LOOP                          (volatile unsigned long *)0xc1106bb8
#define P_DI_IF1_LUMA0_RPT_PAT                     (volatile unsigned long *)0xc1106bbc
#define P_DI_IF1_CHROMA0_RPT_PAT                   (volatile unsigned long *)0xc1106bc0
#define P_DI_IF1_DUMMY_PIXEL                       (volatile unsigned long *)0xc1106bc4
#define P_DI_IF1_LUMA_FIFO_SIZE                    (volatile unsigned long *)0xc1106bc8
#define P_DI_IF1_RANGE_MAP_Y                       (volatile unsigned long *)0xc1106bf0
#define P_DI_IF1_RANGE_MAP_CB                      (volatile unsigned long *)0xc1106bf4
#define P_DI_IF1_RANGE_MAP_CR                      (volatile unsigned long *)0xc1106bf8
#define P_DI_IF1_FMT_CTRL                          (volatile unsigned long *)0xc1106bcc
#define P_DI_IF1_FMT_W                             (volatile unsigned long *)0xc1106bd0
#define P_DI_CHAN2_GEN_REG                         (volatile unsigned long *)0xc1106bd4
#define P_DI_CHAN2_CANVAS                          (volatile unsigned long *)0xc1106bd8
#define P_DI_CHAN2_LUMA_X                          (volatile unsigned long *)0xc1106bdc
#define P_DI_CHAN2_LUMA_Y                          (volatile unsigned long *)0xc1106be0
#define P_DI_CHAN2_RPT_LOOP                        (volatile unsigned long *)0xc1106be4
#define P_DI_CHAN2_LUMA_RPT_PAT                    (volatile unsigned long *)0xc1106be8
#define P_DI_CHAN2_DUMMY_PIXEL                     (volatile unsigned long *)0xc1106bec
#define P_DI_CHAN2_RANGE_MAP_Y                     (volatile unsigned long *)0xc1106ae4
//
// Closing file:  vregs.h
//
//
// Reading file:  venc_regs.h
//
//===========================================================================
// Video Interface Registers    0xa00 - 0xbff
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  VENC_CBUS_BASE = 0x1b
// -----------------------------------------------
// bit 15:8 -- vfifo2vd_vd_sel
// bit 0 -- vfifo2vd_en
#define P_VFIFO2VD_CTL                             (volatile unsigned long *)0xc1106d60
// bit 12:0 -- vfifo2vd_pixel_start 
#define P_VFIFO2VD_PIXEL_START                     (volatile unsigned long *)0xc1106d64
// bit 12:00 -- vfifo2vd_pixel_end   
#define P_VFIFO2VD_PIXEL_END                       (volatile unsigned long *)0xc1106d68
// bit 10:0 -- vfifo2vd_line_top_start 
#define P_VFIFO2VD_LINE_TOP_START                  (volatile unsigned long *)0xc1106d6c
// bit 10:00 -- vfifo2vd_line_top_end   
#define P_VFIFO2VD_LINE_TOP_END                    (volatile unsigned long *)0xc1106d70
// bit 10:00 -- vfifo2vd_line_bot_start 
#define P_VFIFO2VD_LINE_BOT_START                  (volatile unsigned long *)0xc1106d74
// bit 10:00 -- vfifo2vd_line_bot_end   
#define P_VFIFO2VD_LINE_BOT_END                    (volatile unsigned long *)0xc1106d78
// Route the hsync and vsync signals round the chip. There are three
// sources and users of these signals: VIU, internal video encoder, and
// the pins on the chip. Some muxing is still being done in the VIU. It
// was not moved to the venc module so that the same exact VIU code could
// be used both in Twister and Twister2000.
// Bit 2: venc_sync_source (1=>pins, 0=>viu)
// Bit 1: viu_sync_source (1=>pins, 0=>venc)
// Bit 0: vpins_sync_source (1=>venc, 0=>viu)
#define P_VENC_SYNC_ROUTE                          (volatile unsigned long *)0xc1106d80
#define P_VENC_VIDEO_EXSRC                         (volatile unsigned long *)0xc1106d84
#define P_VENC_DVI_SETTING                         (volatile unsigned long *)0xc1106d88
#define P_VENC_C656_CTRL                           (volatile unsigned long *)0xc1106d8c
#define P_VENC_UPSAMPLE_CTRL0                      (volatile unsigned long *)0xc1106d90
#define P_VENC_UPSAMPLE_CTRL1                      (volatile unsigned long *)0xc1106d94
#define P_VENC_UPSAMPLE_CTRL2                      (volatile unsigned long *)0xc1106d98
// Invert control for tcon output
// bit[15:14] -- vsync, hsync, 
// bit[13:0] --  oev3, oev2, cpv2, cph3, cph2, cph1, oeh, vcom, stv2, stv1, cpv1, oev1, sth1, sth2
#define P_TCON_INVERT_CTL                          (volatile unsigned long *)0xc1106d9c
#define P_VENC_VIDEO_PROG_MODE                     (volatile unsigned long *)0xc1106da0
//---- Venc pixel/line info
#define P_VENC_ENCI_LINE                           (volatile unsigned long *)0xc1106da4
#define P_VENC_ENCI_PIXEL                          (volatile unsigned long *)0xc1106da8
#define P_VENC_ENCP_LINE                           (volatile unsigned long *)0xc1106dac
#define P_VENC_ENCP_PIXEL                          (volatile unsigned long *)0xc1106db0
//---- Status
#define P_VENC_STATA                               (volatile unsigned long *)0xc1106db4
//---- Interrupt setting
#define P_VENC_INTCTRL                             (volatile unsigned long *)0xc1106db8
#define P_VENC_INTFLAG                             (volatile unsigned long *)0xc1106dbc
//--------- Video test configuration
#define P_VENC_VIDEO_TST_EN                        (volatile unsigned long *)0xc1106dc0
#define P_VENC_VIDEO_TST_MDSEL                     (volatile unsigned long *)0xc1106dc4
#define P_VENC_VIDEO_TST_Y                         (volatile unsigned long *)0xc1106dc8
#define P_VENC_VIDEO_TST_CB                        (volatile unsigned long *)0xc1106dcc
#define P_VENC_VIDEO_TST_CR                        (volatile unsigned long *)0xc1106dd0
#define P_VENC_VIDEO_TST_CLRBAR_STRT               (volatile unsigned long *)0xc1106dd4
#define P_VENC_VIDEO_TST_CLRBAR_WIDTH              (volatile unsigned long *)0xc1106dd8
#define P_VENC_VIDEO_TST_VDCNT_STSET               (volatile unsigned long *)0xc1106ddc
//----- Video dac setting
#define P_VENC_VDAC_DACSEL0                        (volatile unsigned long *)0xc1106de0
#define P_VENC_VDAC_DACSEL1                        (volatile unsigned long *)0xc1106de4
#define P_VENC_VDAC_DACSEL2                        (volatile unsigned long *)0xc1106de8
#define P_VENC_VDAC_DACSEL3                        (volatile unsigned long *)0xc1106dec
#define P_VENC_VDAC_DACSEL4                        (volatile unsigned long *)0xc1106df0
#define P_VENC_VDAC_DACSEL5                        (volatile unsigned long *)0xc1106df4
#define P_VENC_VDAC_SETTING                        (volatile unsigned long *)0xc1106df8
#define P_VENC_VDAC_TST_VAL                        (volatile unsigned long *)0xc1106dfc
#define P_VENC_VDAC_DAC0_GAINCTRL                  (volatile unsigned long *)0xc1106fc0
#define P_VENC_VDAC_DAC0_OFFSET                    (volatile unsigned long *)0xc1106fc4
#define P_VENC_VDAC_DAC1_GAINCTRL                  (volatile unsigned long *)0xc1106fc8
#define P_VENC_VDAC_DAC1_OFFSET                    (volatile unsigned long *)0xc1106fcc
#define P_VENC_VDAC_DAC2_GAINCTRL                  (volatile unsigned long *)0xc1106fd0
#define P_VENC_VDAC_DAC2_OFFSET                    (volatile unsigned long *)0xc1106fd4
#define P_VENC_VDAC_DAC3_GAINCTRL                  (volatile unsigned long *)0xc1106fd8
#define P_VENC_VDAC_DAC3_OFFSET                    (volatile unsigned long *)0xc1106fdc
//====== No prgressive venc
//
// Closing file:  venc_regs.h
//
//
// Reading file:  enc480p_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// Video Encoder 480p Registers    0xb80 - 0xbef
//===========================================================================
//-------- Video basic setting
#define P_ENCP_VIDEO_EN                            (volatile unsigned long *)0xc1106e00
#define P_ENCP_VIDEO_SYNC_MODE                     (volatile unsigned long *)0xc1106e04
#define P_ENCP_MACV_EN                             (volatile unsigned long *)0xc1106e08
#define P_ENCP_VIDEO_Y_SCL                         (volatile unsigned long *)0xc1106e0c
#define P_ENCP_VIDEO_PB_SCL                        (volatile unsigned long *)0xc1106e10
#define P_ENCP_VIDEO_PR_SCL                        (volatile unsigned long *)0xc1106e14
#define P_ENCP_VIDEO_SYNC_SCL                      (volatile unsigned long *)0xc1106e18
#define P_ENCP_VIDEO_MACV_SCL                      (volatile unsigned long *)0xc1106e1c
#define P_ENCP_VIDEO_Y_OFFST                       (volatile unsigned long *)0xc1106e20
#define P_ENCP_VIDEO_PB_OFFST                      (volatile unsigned long *)0xc1106e24
#define P_ENCP_VIDEO_PR_OFFST                      (volatile unsigned long *)0xc1106e28
#define P_ENCP_VIDEO_SYNC_OFFST                    (volatile unsigned long *)0xc1106e2c
#define P_ENCP_VIDEO_MACV_OFFST                    (volatile unsigned long *)0xc1106e30
//----- Video mode
#define P_ENCP_VIDEO_MODE                          (volatile unsigned long *)0xc1106e34
#define P_ENCP_VIDEO_MODE_ADV                      (volatile unsigned long *)0xc1106e38
//--------------- Debug pins
#define P_ENCP_DBG_PX_RST                          (volatile unsigned long *)0xc1106e40
#define P_ENCP_DBG_LN_RST                          (volatile unsigned long *)0xc1106e44
#define P_ENCP_DBG_PX_INT                          (volatile unsigned long *)0xc1106e48
#define P_ENCP_DBG_LN_INT                          (volatile unsigned long *)0xc1106e4c
//----------- Video Advanced setting
#define P_ENCP_VIDEO_YFP1_HTIME                    (volatile unsigned long *)0xc1106e50
#define P_ENCP_VIDEO_YFP2_HTIME                    (volatile unsigned long *)0xc1106e54
#define P_ENCP_VIDEO_YC_DLY                        (volatile unsigned long *)0xc1106e58
#define P_ENCP_VIDEO_MAX_PXCNT                     (volatile unsigned long *)0xc1106e5c
#define P_ENCP_VIDEO_HSPULS_BEGIN                  (volatile unsigned long *)0xc1106e60
#define P_ENCP_VIDEO_HSPULS_END                    (volatile unsigned long *)0xc1106e64
#define P_ENCP_VIDEO_HSPULS_SWITCH                 (volatile unsigned long *)0xc1106e68
#define P_ENCP_VIDEO_VSPULS_BEGIN                  (volatile unsigned long *)0xc1106e6c
#define P_ENCP_VIDEO_VSPULS_END                    (volatile unsigned long *)0xc1106e70
#define P_ENCP_VIDEO_VSPULS_BLINE                  (volatile unsigned long *)0xc1106e74
#define P_ENCP_VIDEO_VSPULS_ELINE                  (volatile unsigned long *)0xc1106e78
#define P_ENCP_VIDEO_EQPULS_BEGIN                  (volatile unsigned long *)0xc1106e7c
#define P_ENCP_VIDEO_EQPULS_END                    (volatile unsigned long *)0xc1106e80
#define P_ENCP_VIDEO_EQPULS_BLINE                  (volatile unsigned long *)0xc1106e84
#define P_ENCP_VIDEO_EQPULS_ELINE                  (volatile unsigned long *)0xc1106e88
#define P_ENCP_VIDEO_HAVON_END                     (volatile unsigned long *)0xc1106e8c
#define P_ENCP_VIDEO_HAVON_BEGIN                   (volatile unsigned long *)0xc1106e90
#define P_ENCP_VIDEO_VAVON_ELINE                   (volatile unsigned long *)0xc1106ebc
#define P_ENCP_VIDEO_VAVON_BLINE                   (volatile unsigned long *)0xc1106e98
#define P_ENCP_VIDEO_HSO_BEGIN                     (volatile unsigned long *)0xc1106e9c
#define P_ENCP_VIDEO_HSO_END                       (volatile unsigned long *)0xc1106ea0
#define P_ENCP_VIDEO_VSO_BEGIN                     (volatile unsigned long *)0xc1106ea4
#define P_ENCP_VIDEO_VSO_END                       (volatile unsigned long *)0xc1106ea8
#define P_ENCP_VIDEO_VSO_BLINE                     (volatile unsigned long *)0xc1106eac
#define P_ENCP_VIDEO_VSO_ELINE                     (volatile unsigned long *)0xc1106eb0
#define P_ENCP_VIDEO_SYNC_WAVE_CURVE               (volatile unsigned long *)0xc1106eb4
#define P_ENCP_VIDEO_MAX_LNCNT                     (volatile unsigned long *)0xc1106eb8
#define P_ENCP_VIDEO_SY_VAL                        (volatile unsigned long *)0xc1106ec0
#define P_ENCP_VIDEO_SY2_VAL                       (volatile unsigned long *)0xc1106ec4
#define P_ENCP_VIDEO_BLANKY_VAL                    (volatile unsigned long *)0xc1106ec8
#define P_ENCP_VIDEO_BLANKPB_VAL                   (volatile unsigned long *)0xc1106ecc
#define P_ENCP_VIDEO_BLANKPR_VAL                   (volatile unsigned long *)0xc1106ed0
#define P_ENCP_VIDEO_HOFFST                        (volatile unsigned long *)0xc1106ed4
#define P_ENCP_VIDEO_VOFFST                        (volatile unsigned long *)0xc1106ed8
#define P_ENCP_VIDEO_RGB_CTRL                      (volatile unsigned long *)0xc1106edc
#define P_ENCP_VIDEO_FILT_CTRL                     (volatile unsigned long *)0xc1106ee0
#define P_ENCP_VIDEO_OFLD_VPEQ_OFST                (volatile unsigned long *)0xc1106ee4
#define P_ENCP_VIDEO_OFLD_VOAV_OFST                (volatile unsigned long *)0xc1106ee8
#define P_ENCP_VIDEO_MATRIX_CB                     (volatile unsigned long *)0xc1106eec
#define P_ENCP_VIDEO_MATRIX_CR                     (volatile unsigned long *)0xc1106ef0
#define P_ENCP_VIDEO_RGBIN_CTRL                    (volatile unsigned long *)0xc1106ef4
//------------------Macrovision advanced setting
#define P_ENCP_MACV_BLANKY_VAL                     (volatile unsigned long *)0xc1106f00
#define P_ENCP_MACV_MAXY_VAL                       (volatile unsigned long *)0xc1106f04
#define P_ENCP_MACV_1ST_PSSYNC_STRT                (volatile unsigned long *)0xc1106f08
#define P_ENCP_MACV_PSSYNC_STRT                    (volatile unsigned long *)0xc1106f0c
#define P_ENCP_MACV_AGC_STRT                       (volatile unsigned long *)0xc1106f10
#define P_ENCP_MACV_AGC_END                        (volatile unsigned long *)0xc1106f14
#define P_ENCP_MACV_WAVE_END                       (volatile unsigned long *)0xc1106f18
#define P_ENCP_MACV_STRTLINE                       (volatile unsigned long *)0xc1106f1c
#define P_ENCP_MACV_ENDLINE                        (volatile unsigned long *)0xc1106f20
#define P_ENCP_MACV_TS_CNT_MAX_L                   (volatile unsigned long *)0xc1106f24
#define P_ENCP_MACV_TS_CNT_MAX_H                   (volatile unsigned long *)0xc1106f28
#define P_ENCP_MACV_TIME_DOWN                      (volatile unsigned long *)0xc1106f2c
#define P_ENCP_MACV_TIME_LO                        (volatile unsigned long *)0xc1106f30
#define P_ENCP_MACV_TIME_UP                        (volatile unsigned long *)0xc1106f34
#define P_ENCP_MACV_TIME_RST                       (volatile unsigned long *)0xc1106f38
//---------------- VBI control -------------------
#define P_ENCP_VBI_CTRL                            (volatile unsigned long *)0xc1106f40
#define P_ENCP_VBI_SETTING                         (volatile unsigned long *)0xc1106f44
#define P_ENCP_VBI_BEGIN                           (volatile unsigned long *)0xc1106f48
#define P_ENCP_VBI_WIDTH                           (volatile unsigned long *)0xc1106f4c
#define P_ENCP_VBI_HVAL                            (volatile unsigned long *)0xc1106f50
#define P_ENCP_VBI_DATA0                           (volatile unsigned long *)0xc1106f54
#define P_ENCP_VBI_DATA1                           (volatile unsigned long *)0xc1106f58
//----------------C656 OUT Control------------- Grant
#define P_C656_HS_ST                               (volatile unsigned long *)0xc1106f80
#define P_C656_HS_ED                               (volatile unsigned long *)0xc1106f84
#define P_C656_VS_LNST_E                           (volatile unsigned long *)0xc1106f88
#define P_C656_VS_LNST_O                           (volatile unsigned long *)0xc1106f8c
#define P_C656_VS_LNED_E                           (volatile unsigned long *)0xc1106f90
#define P_C656_VS_LNED_O                           (volatile unsigned long *)0xc1106f94
#define P_C656_FS_LNST                             (volatile unsigned long *)0xc1106f98
#define P_C656_FS_LNED                             (volatile unsigned long *)0xc1106f9c
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  enc480p_regs.h
//
//
// Reading file:  enci_regs.h
//
//===========================================================================
// Video Interface Registers    0xb00 - 0xb57
//===========================================================================
#define P_ENCI_VIDEO_MODE                          (volatile unsigned long *)0xc1106c00
#define P_ENCI_VIDEO_MODE_ADV                      (volatile unsigned long *)0xc1106c04
#define P_ENCI_VIDEO_FSC_ADJ                       (volatile unsigned long *)0xc1106c08
#define P_ENCI_VIDEO_BRIGHT                        (volatile unsigned long *)0xc1106c0c
#define P_ENCI_VIDEO_CONT                          (volatile unsigned long *)0xc1106c10
#define P_ENCI_VIDEO_SAT                           (volatile unsigned long *)0xc1106c14
#define P_ENCI_VIDEO_HUE                           (volatile unsigned long *)0xc1106c18
#define P_ENCI_VIDEO_SCH                           (volatile unsigned long *)0xc1106c1c
#define P_ENCI_SYNC_MODE                           (volatile unsigned long *)0xc1106c20
#define P_ENCI_SYNC_CTRL                           (volatile unsigned long *)0xc1106c24
#define P_ENCI_SYNC_HSO_BEGIN                      (volatile unsigned long *)0xc1106c28
#define P_ENCI_SYNC_HSO_END                        (volatile unsigned long *)0xc1106c2c
#define P_ENCI_SYNC_VSO_EVN                        (volatile unsigned long *)0xc1106c30
#define P_ENCI_SYNC_VSO_ODD                        (volatile unsigned long *)0xc1106c34
#define P_ENCI_SYNC_VSO_EVNLN                      (volatile unsigned long *)0xc1106c38
#define P_ENCI_SYNC_VSO_ODDLN                      (volatile unsigned long *)0xc1106c3c
#define P_ENCI_SYNC_HOFFST                         (volatile unsigned long *)0xc1106c40
#define P_ENCI_SYNC_VOFFST                         (volatile unsigned long *)0xc1106c44
#define P_ENCI_SYNC_ADJ                            (volatile unsigned long *)0xc1106c48
#define P_ENCI_RGB_SETTING                         (volatile unsigned long *)0xc1106c4c
//`define	ENCI_CMPN_MATRIX_CB		8'h14
//`define	ENCI_CMPN_MATRIX_CR		8'h15
#define P_ENCI_DE_H_BEGIN                          (volatile unsigned long *)0xc1106c58
#define P_ENCI_DE_H_END                            (volatile unsigned long *)0xc1106c5c
#define P_ENCI_DE_V_BEGIN_EVEN                     (volatile unsigned long *)0xc1106c60
#define P_ENCI_DE_V_END_EVEN                       (volatile unsigned long *)0xc1106c64
#define P_ENCI_DE_V_BEGIN_ODD                      (volatile unsigned long *)0xc1106c68
#define P_ENCI_DE_V_END_ODD                        (volatile unsigned long *)0xc1106c6c
#define P_ENCI_VBI_SETTING                         (volatile unsigned long *)0xc1106c80
#define P_ENCI_VBI_CCDT_EVN                        (volatile unsigned long *)0xc1106c84
#define P_ENCI_VBI_CCDT_ODD                        (volatile unsigned long *)0xc1106c88
#define P_ENCI_VBI_CC525_LN                        (volatile unsigned long *)0xc1106c8c
#define P_ENCI_VBI_CC625_LN                        (volatile unsigned long *)0xc1106c90
#define P_ENCI_VBI_WSSDT                           (volatile unsigned long *)0xc1106c94
#define P_ENCI_VBI_WSS_LN                          (volatile unsigned long *)0xc1106c98
#define P_ENCI_VBI_CGMSDT_L                        (volatile unsigned long *)0xc1106c9c
#define P_ENCI_VBI_CGMSDT_H                        (volatile unsigned long *)0xc1106ca0
#define P_ENCI_VBI_CGMS_LN                         (volatile unsigned long *)0xc1106ca4
#define P_ENCI_VBI_TTX_HTIME                       (volatile unsigned long *)0xc1106ca8
#define P_ENCI_VBI_TTX_LN                          (volatile unsigned long *)0xc1106cac
#define P_ENCI_VBI_TTXDT0                          (volatile unsigned long *)0xc1106cb0
#define P_ENCI_VBI_TTXDT1                          (volatile unsigned long *)0xc1106cb4
#define P_ENCI_VBI_TTXDT2                          (volatile unsigned long *)0xc1106cb8
#define P_ENCI_VBI_TTXDT3                          (volatile unsigned long *)0xc1106cbc
#define P_ENCI_MACV_N0                             (volatile unsigned long *)0xc1106cc0
#define P_ENCI_MACV_N1                             (volatile unsigned long *)0xc1106cc4
#define P_ENCI_MACV_N2                             (volatile unsigned long *)0xc1106cc8
#define P_ENCI_MACV_N3                             (volatile unsigned long *)0xc1106ccc
#define P_ENCI_MACV_N4                             (volatile unsigned long *)0xc1106cd0
#define P_ENCI_MACV_N5                             (volatile unsigned long *)0xc1106cd4
#define P_ENCI_MACV_N6                             (volatile unsigned long *)0xc1106cd8
#define P_ENCI_MACV_N7                             (volatile unsigned long *)0xc1106cdc
#define P_ENCI_MACV_N8                             (volatile unsigned long *)0xc1106ce0
#define P_ENCI_MACV_N9                             (volatile unsigned long *)0xc1106ce4
#define P_ENCI_MACV_N10                            (volatile unsigned long *)0xc1106ce8
#define P_ENCI_MACV_N11                            (volatile unsigned long *)0xc1106cec
#define P_ENCI_MACV_N12                            (volatile unsigned long *)0xc1106cf0
#define P_ENCI_MACV_N13                            (volatile unsigned long *)0xc1106cf4
#define P_ENCI_MACV_N14                            (volatile unsigned long *)0xc1106cf8
#define P_ENCI_MACV_N15                            (volatile unsigned long *)0xc1106cfc
#define P_ENCI_MACV_N16                            (volatile unsigned long *)0xc1106d00
#define P_ENCI_MACV_N17                            (volatile unsigned long *)0xc1106d04
#define P_ENCI_MACV_N18                            (volatile unsigned long *)0xc1106d08
#define P_ENCI_MACV_N19                            (volatile unsigned long *)0xc1106d0c
#define P_ENCI_MACV_N20                            (volatile unsigned long *)0xc1106d10
#define P_ENCI_MACV_N21                            (volatile unsigned long *)0xc1106d14
#define P_ENCI_MACV_N22                            (volatile unsigned long *)0xc1106d18
//`define	ENCI_MACV_P_AGC			8'h47
#define P_ENCI_DBG_PX_RST                          (volatile unsigned long *)0xc1106d20
#define P_ENCI_DBG_FLDLN_RST                       (volatile unsigned long *)0xc1106d24
#define P_ENCI_DBG_PX_INT                          (volatile unsigned long *)0xc1106d28
#define P_ENCI_DBG_FLDLN_INT                       (volatile unsigned long *)0xc1106d2c
#define P_ENCI_DBG_MAXPX                           (volatile unsigned long *)0xc1106d30
#define P_ENCI_DBG_MAXLN                           (volatile unsigned long *)0xc1106d34
#define P_ENCI_MACV_MAX_AMP                        (volatile unsigned long *)0xc1106d40
#define P_ENCI_MACV_PULSE_LO                       (volatile unsigned long *)0xc1106d44
#define P_ENCI_MACV_PULSE_HI                       (volatile unsigned long *)0xc1106d48
#define P_ENCI_MACV_BKP_MAX                        (volatile unsigned long *)0xc1106d4c
#define P_ENCI_CFILT_CTRL                          (volatile unsigned long *)0xc1106d50
#define P_ENCI_CFILT7                              (volatile unsigned long *)0xc1106d54
#define P_ENCI_YC_DELAY                            (volatile unsigned long *)0xc1106d58
#define P_ENCI_VIDEO_EN                            (volatile unsigned long *)0xc1106d5c
//
// Closing file:  enci_regs.h
//
//
// Reading file:  venc2_regs.h
//
//===========================================================================
// Venc Registers (Cont.)    0xc00 - 0xcff
//===========================================================================
// -----------------------------------------------
// CBUS_BASE:  VENC2_CBUS_BASE = 0x1c
// -----------------------------------------------
// Program video control signals from ENCI core to DVI/HDMI interface
#define P_ENCI_DVI_HSO_BEGIN                       (volatile unsigned long *)0xc1107000
#define P_ENCI_DVI_HSO_END                         (volatile unsigned long *)0xc1107004
#define P_ENCI_DVI_VSO_BLINE_EVN                   (volatile unsigned long *)0xc1107008
#define P_ENCI_DVI_VSO_BLINE_ODD                   (volatile unsigned long *)0xc110700c
#define P_ENCI_DVI_VSO_ELINE_EVN                   (volatile unsigned long *)0xc1107010
#define P_ENCI_DVI_VSO_ELINE_ODD                   (volatile unsigned long *)0xc1107014
#define P_ENCI_DVI_VSO_BEGIN_EVN                   (volatile unsigned long *)0xc1107018
#define P_ENCI_DVI_VSO_BEGIN_ODD                   (volatile unsigned long *)0xc110701c
#define P_ENCI_DVI_VSO_END_EVN                     (volatile unsigned long *)0xc1107020
#define P_ENCI_DVI_VSO_END_ODD                     (volatile unsigned long *)0xc1107024
// Define cmpt and cvbs cb/cr delay after ENCI chroma filters
// Bit 15:12 RW, enci_cb_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit 11: 8 RW, enci_cr_cvbs_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit  7: 4 RW, enci_cb_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
// Bit  3: 0 RW, enci_cr_cmpt_dly_sel. 0=no delay; 1~6=delay by 1~6 clk; 7~15 reserved.
#define P_ENCI_CFILT_CTRL2                         (volatile unsigned long *)0xc1107028
// Program video control signals from ENCP core to DVI/HDMI interface
#define P_ENCP_DVI_HSO_BEGIN                       (volatile unsigned long *)0xc1107100
#define P_ENCP_DVI_HSO_END                         (volatile unsigned long *)0xc1107104
#define P_ENCP_DVI_VSO_BLINE_EVN                   (volatile unsigned long *)0xc1107108
#define P_ENCP_DVI_VSO_BLINE_ODD                   (volatile unsigned long *)0xc110710c
#define P_ENCP_DVI_VSO_ELINE_EVN                   (volatile unsigned long *)0xc1107110
#define P_ENCP_DVI_VSO_ELINE_ODD                   (volatile unsigned long *)0xc1107114
#define P_ENCP_DVI_VSO_BEGIN_EVN                   (volatile unsigned long *)0xc1107118
#define P_ENCP_DVI_VSO_BEGIN_ODD                   (volatile unsigned long *)0xc110711c
#define P_ENCP_DVI_VSO_END_EVN                     (volatile unsigned long *)0xc1107120
#define P_ENCP_DVI_VSO_END_ODD                     (volatile unsigned long *)0xc1107124
#define P_ENCP_DE_H_BEGIN                          (volatile unsigned long *)0xc1107128
#define P_ENCP_DE_H_END                            (volatile unsigned long *)0xc110712c
#define P_ENCP_DE_V_BEGIN_EVEN                     (volatile unsigned long *)0xc1107130
#define P_ENCP_DE_V_END_EVEN                       (volatile unsigned long *)0xc1107134
#define P_ENCP_DE_V_BEGIN_ODD                      (volatile unsigned long *)0xc1107138
#define P_ENCP_DE_V_END_ODD                        (volatile unsigned long *)0xc110713c
// bit    3 cfg_encp_lcd_scaler_bypass. 1=Do not scale LCD input data;
//                                      0=Scale LCD input data to y [16*4,235*4], c [16*4,240*4].
// bit    2 cfg_encp_vadj_scaler_bypass. 1=Do not scale data to enc480p_vadj;
//                                       0=Scale enc480p_vadj input data to y [16*4,235*4], c [16*4,240*4].
// bit    1 cfg_vfifo2vd_out_scaler_bypass. 1=Do not scale vfifo2vd's output vdata;
//                                          0=Scale vfifo2vd's output vdata to y [16,235], c [16,240].
// bit    0 cfg_vfifo_din_full_range. 1=Data from viu fifo is full range [0,1023];
//                                    0=Data from viu fifo is y [16*4,235*4], c [16*4,240*4].
#define P_VENC_VFIFO2VD_CTL2                       (volatile unsigned long *)0xc1107200
// bit 15:1 Reserved.
// bit    0 cfg_int_dvi_sel_rgb. Applicable for using on-chip hdmi tx module only. This bit controls correct bit-mapping from
//          Venc to hdmi_tx depending on whether YCbCr or RGB mode.
//                               1=Map data bit from Venc to hdmi_tx for RGB mode;
//                               0=Default. Map data bit from Venc to hdmi_tx for YCbCr mode.
#define P_VENC_DVI_SETTING_MORE                    (volatile unsigned long *)0xc1107204
//Bit 0   filter_en
#define P_VENC_VDAC_DAC0_FILT_CTRL0                (volatile unsigned long *)0xc1107220
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0, 
#define P_VENC_VDAC_DAC0_FILT_CTRL1                (volatile unsigned long *)0xc1107224
//Bit 0   filter_en
#define P_VENC_VDAC_DAC1_FILT_CTRL0                (volatile unsigned long *)0xc1107228
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0, 
#define P_VENC_VDAC_DAC1_FILT_CTRL1                (volatile unsigned long *)0xc110722c
//Bit 0   filter_en
#define P_VENC_VDAC_DAC2_FILT_CTRL0                (volatile unsigned long *)0xc1107230
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0, 
#define P_VENC_VDAC_DAC2_FILT_CTRL1                (volatile unsigned long *)0xc1107234
//Bit 0   filter_en
#define P_VENC_VDAC_DAC3_FILT_CTRL0                (volatile unsigned long *)0xc1107238
//dout = ((din + din_d2) * coef1 + (din_d1 * coef0) + 32) >> 6
//Bit 15:8, coef1,
//Bit 7:0, coef0, 
#define P_VENC_VDAC_DAC3_FILT_CTRL1                (volatile unsigned long *)0xc110723c
//
// Closing file:  venc2_regs.h
//
//
// Reading file:  lcd_regs.h
//
//========================================================================
//LCD DRV     12'h480~12'h4ef
//=======================================================================
//**************************************************************************
//*  NOTE::    When Programming the Gamma, please turn off the IRQ service *
//**************************************************************************
// -----------------------------------------------
// CBUS_BASE:  LCD_CBUS_BASE = 0x14
// -----------------------------------------------
#define P_GAMMA_CNTL_PORT                          (volatile unsigned long *)0xc1105200
   #define  GAMMA_VCOM_POL    7     //RW
   #define  GAMMA_RVS_OUT     6     //RW
   #define  ADR_RDY           5     //Read Only
   #define  WR_RDY            4     //Read Only
   #define  RD_RDY            3     //Read Only
   #define  GAMMA_TR          2     //RW
   #define  GAMMA_SET         1     //RW
   #define  GAMMA_EN          0     //RW
#define P_GAMMA_DATA_PORT                          (volatile unsigned long *)0xc1105204
#define P_GAMMA_ADDR_PORT                          (volatile unsigned long *)0xc1105208
   #define  H_RD              12
   #define  H_AUTO_INC        11
   #define  H_SEL_R           10
   #define  H_SEL_G           9
   #define  H_SEL_B           8
   #define  HADR_MSB          7            //7:0
   #define  HADR              0            //7:0
#define P_GAMMA_VCOM_HSWITCH_ADDR                  (volatile unsigned long *)0xc110520c
#define P_RGB_BASE_ADDR                            (volatile unsigned long *)0xc1105214
#define P_RGB_COEFF_ADDR                           (volatile unsigned long *)0xc1105218
#define P_POL_CNTL_ADDR                            (volatile unsigned long *)0xc110521c
   #define   DCLK_SEL             14    //FOR DCLK OUTPUT
   #define   TCON_VSYNC_SEL_DVI   11    //FOR RGB format DVI output
   #define   TCON_HSYNC_SEL_DVI   10    //FOR RGB format DVI output
   #define   TCON_DE_SEL_DVI      9     //FOR RGB format DVI output
   #define   CPH3_POL         8
   #define   CPH2_POL         7
   #define   CPH1_POL         6
   #define   TCON_DE_SEL      5
   #define   TCON_VS_SEL      4
   #define   TCON_HS_SEL      3
   #define   DE_POL           2
   #define   VS_POL           1
   #define   HS_POL           0
#define P_DITH_CNTL_ADDR                           (volatile unsigned long *)0xc1105220
   #define  DITH10_EN         10
   #define  DITH8_EN          9
   #define  DITH_MD           8
   #define  DITH10_CNTL_MSB   7          //7:4
   #define  DITH10_CNTL       4          //7:4
   #define  DITH8_CNTL_MSB    3          //3:0
   #define  DITH8_CNTL        0          //3:0
#define P_STH1_HS_ADDR                             (volatile unsigned long *)0xc1105240
#define P_STH1_HE_ADDR                             (volatile unsigned long *)0xc1105244
#define P_STH1_VS_ADDR                             (volatile unsigned long *)0xc1105248
#define P_STH1_VE_ADDR                             (volatile unsigned long *)0xc110524c
#define P_STH2_HS_ADDR                             (volatile unsigned long *)0xc1105250
#define P_STH2_HE_ADDR                             (volatile unsigned long *)0xc1105254
#define P_STH2_VS_ADDR                             (volatile unsigned long *)0xc1105258
#define P_STH2_VE_ADDR                             (volatile unsigned long *)0xc110525c
#define P_OEH_HS_ADDR                              (volatile unsigned long *)0xc1105260
#define P_OEH_HE_ADDR                              (volatile unsigned long *)0xc1105264
#define P_OEH_VS_ADDR                              (volatile unsigned long *)0xc1105268
#define P_OEH_VE_ADDR                              (volatile unsigned long *)0xc110526c
#define P_VCOM_HSWITCH_ADDR                        (volatile unsigned long *)0xc1105270
#define P_VCOM_VS_ADDR                             (volatile unsigned long *)0xc1105274
#define P_VCOM_VE_ADDR                             (volatile unsigned long *)0xc1105278
#define P_CPV1_HS_ADDR                             (volatile unsigned long *)0xc110527c
#define P_CPV1_HE_ADDR                             (volatile unsigned long *)0xc1105280
#define P_CPV1_VS_ADDR                             (volatile unsigned long *)0xc1105284
#define P_CPV1_VE_ADDR                             (volatile unsigned long *)0xc1105288
#define P_CPV2_HS_ADDR                             (volatile unsigned long *)0xc110528c
#define P_CPV2_HE_ADDR                             (volatile unsigned long *)0xc1105290
#define P_CPV2_VS_ADDR                             (volatile unsigned long *)0xc1105294
#define P_CPV2_VE_ADDR                             (volatile unsigned long *)0xc1105298
#define P_STV1_HS_ADDR                             (volatile unsigned long *)0xc110529c
#define P_STV1_HE_ADDR                             (volatile unsigned long *)0xc11052a0
#define P_STV1_VS_ADDR                             (volatile unsigned long *)0xc11052a4
#define P_STV1_VE_ADDR                             (volatile unsigned long *)0xc11052a8
#define P_STV2_HS_ADDR                             (volatile unsigned long *)0xc11052ac
#define P_STV2_HE_ADDR                             (volatile unsigned long *)0xc11052b0
#define P_STV2_VS_ADDR                             (volatile unsigned long *)0xc11052b4
#define P_STV2_VE_ADDR                             (volatile unsigned long *)0xc11052b8
#define P_OEV1_HS_ADDR                             (volatile unsigned long *)0xc11052bc
#define P_OEV1_HE_ADDR                             (volatile unsigned long *)0xc11052c0
#define P_OEV1_VS_ADDR                             (volatile unsigned long *)0xc11052c4
#define P_OEV1_VE_ADDR                             (volatile unsigned long *)0xc11052c8
#define P_OEV2_HS_ADDR                             (volatile unsigned long *)0xc11052cc
#define P_OEV2_HE_ADDR                             (volatile unsigned long *)0xc11052d0
#define P_OEV2_VS_ADDR                             (volatile unsigned long *)0xc11052d4
#define P_OEV2_VE_ADDR                             (volatile unsigned long *)0xc11052d8
#define P_OEV3_HS_ADDR                             (volatile unsigned long *)0xc11052dc
#define P_OEV3_HE_ADDR                             (volatile unsigned long *)0xc11052e0
#define P_OEV3_VS_ADDR                             (volatile unsigned long *)0xc11052e4
#define P_OEV3_VE_ADDR                             (volatile unsigned long *)0xc11052e8
#define P_LCD_PWR_ADDR                             (volatile unsigned long *)0xc11052ec
#define P_LCD_VDD                                  (volatile unsigned long *)0xc1105014
#define P_LCD_VBL                                  (volatile unsigned long *)0xc1105010
#define P_LCD_GPI_MSB                              (volatile unsigned long *)0xc110500c
#define P_LCD_GPIO                                 (volatile unsigned long *)0xc1105000
#define P_LCD_PWM0_LO_ADDR                         (volatile unsigned long *)0xc11052f0
#define P_LCD_PWM0_HI_ADDR                         (volatile unsigned long *)0xc11052f4
#define P_LCD_PWM1_LO_ADDR                         (volatile unsigned long *)0xc11052f8
#define P_LCD_PWM1_HI_ADDR                         (volatile unsigned long *)0xc11052fc
#define P_INV_CNT_ADDR                             (volatile unsigned long *)0xc1105300
   #define     INV_EN          4
   #define     INV_CNT_MSB     3
   #define     INV_CNT         0
#define P_TCON_MISC_SEL_ADDR                       (volatile unsigned long *)0xc1105304
   #define     STH2_SEL        12
   #define     STH1_SEL        11
   #define     OEH_SEL         10
   #define     VCOM_SEL         9
   #define     DB_LINE_SW       8
   #define     CPV2_SEL         7
   #define     CPV1_SEL         6
   #define     STV2_SEL         5
   #define     STV1_SEL         4
   #define     OEV_UNITE        3
   #define     OEV3_SEL         2
   #define     OEV2_SEL         1
   #define     OEV1_SEL         0
#define P_DUAL_PORT_CNTL_ADDR                      (volatile unsigned long *)0xc1105308
   #define     OUTPUT_YUV       15
   #define     DUAL_IDF         12   // 14:12
   #define     DUAL_ISF         9    // 11:9
   #define     LCD_ANALOG_SEL_CPH3   8
   #define     LCD_ANALOG_3PHI_CLK_SEL   7
   #define     LCD_LVDS_SEL54   6
   #define     LCD_LVDS_SEL27   5
   #define     LCD_TTL_SEL      4
   #define     DUAL_LVDC_EN     3
   #define     PORT_SWP         2
   #define     RGB_SWP          1
   #define     BIT_SWP          0
#define P_LVDS_CLK_CNTL                            (volatile unsigned long *)0xc110530c
#define P_LVDS_PHY_CNTL0                           (volatile unsigned long *)0xc1105310
#define P_LVDS_PHY_CNTL1                           (volatile unsigned long *)0xc1105314
#define P_LVDS_PHY_CNTL2                           (volatile unsigned long *)0xc1105318
#define P_LVDS_PHY_CNTL3                           (volatile unsigned long *)0xc110531c
#define P_LVDS_SRG_TEST                            (volatile unsigned long *)0xc1105320
#define P_LVDS_BIST_MUX0                           (volatile unsigned long *)0xc1105324
#define P_LVDS_BIST_MUX1                           (volatile unsigned long *)0xc1105328
#define P_LVDS_BIST_FIXED0                         (volatile unsigned long *)0xc110532c
#define P_LVDS_BIST_FIXED1                         (volatile unsigned long *)0xc1105330
#define P_LVDS_BIST_CNTL0                          (volatile unsigned long *)0xc1105334
#define P_LVDS_CLKB_CLKA                           (volatile unsigned long *)0xc1105338
#define P_LVDS_GEN_CTNL                            (volatile unsigned long *)0xc110533c
#define P_LVDS_PACK_CNTL_ADDR                      (volatile unsigned long *)0xc1105340
   #define     LVDS_USE_TCON    7
   #define     LVDS_DUAL        6
   #define     PN_SWP           5
   #define     LSB_FIRST        4
   #define     LVDS_RESV        3
   #define     ODD_EVEN_SWP     2
   #define     LVDS_REPACK      0
#define P_DE_HS_ADDR                               (volatile unsigned long *)0xc1105344
#define P_DE_HE_ADDR                               (volatile unsigned long *)0xc1105348
#define P_DE_VS_ADDR                               (volatile unsigned long *)0xc110534c
#define P_DE_VE_ADDR                               (volatile unsigned long *)0xc1105350
#define P_HSYNC_HS_ADDR                            (volatile unsigned long *)0xc1105354
#define P_HSYNC_HE_ADDR                            (volatile unsigned long *)0xc1105358
#define P_HSYNC_VS_ADDR                            (volatile unsigned long *)0xc110535c
#define P_HSYNC_VE_ADDR                            (volatile unsigned long *)0xc1105360
#define P_VSYNC_HS_ADDR                            (volatile unsigned long *)0xc1105364
#define P_VSYNC_HE_ADDR                            (volatile unsigned long *)0xc1105368
#define P_VSYNC_VS_ADDR                            (volatile unsigned long *)0xc110536c
#define P_VSYNC_VE_ADDR                            (volatile unsigned long *)0xc1105370
// bit 8 -- vfifo_mcu_enable
// bit 7 -- halt_vs_de
// bit 6 -- R8G8B8_format
// bit 5 -- R6G6B6_format (round to 6 bits)
// bit 4 -- R5G6B5_format
// bit 3 -- dac_dith_sel
// bit 2 -- lcd_mcu_enable_de     -- ReadOnly
// bit 1 -- lcd_mcu_enable_vsync  -- ReadOnly
// bit 0 -- lcd_mcu_enable
#define P_LCD_MCU_CTL                              (volatile unsigned long *)0xc1105374
// ReadOnly 
//   R5G6B5 when R5G6B5_format
//   G8R8   when R8G8B8_format
//   G5R10  Other
#define P_LCD_MCU_DATA_0                           (volatile unsigned long *)0xc1105378
// ReadOnly
//   G8B8   when R8G8B8_format
//   G5B10  Other
#define P_LCD_MCU_DATA_1                           (volatile unsigned long *)0xc110537c
//===============================================================
//LCD DRIVER BASE   END
//===============================================================
//
// Closing file:  lcd_regs.h
//
//======================================================================
//   vpu  register.
//======================================================================
// -----------------------------------------------
// CBUS_BASE:  VPU_CBUS_BASE = 0x27
// -----------------------------------------------
#define P_VPU_OSD1_MMC_CTRL                        (volatile unsigned long *)0xc1109c04
#define P_VPU_OSD2_MMC_CTRL                        (volatile unsigned long *)0xc1109c08
#define P_VPU_VD1_MMC_CTRL                         (volatile unsigned long *)0xc1109c0c
#define P_VPU_VD2_MMC_CTRL                         (volatile unsigned long *)0xc1109c10
#define P_VPU_DI_IF1_MMC_CTRL                      (volatile unsigned long *)0xc1109c14
#define P_VPU_DI_MEM_MMC_CTRL                      (volatile unsigned long *)0xc1109c18
#define P_VPU_DI_INP_MMC_CTRL                      (volatile unsigned long *)0xc1109c1c
#define P_VPU_DI_MTNRD_MMC_CTRL                    (volatile unsigned long *)0xc1109c20
#define P_VPU_DI_CHAN2_MMC_CTRL                    (volatile unsigned long *)0xc1109c24
#define P_VPU_DI_MTNWR_MMC_CTRL                    (volatile unsigned long *)0xc1109c28
#define P_VPU_DI_NRWR_MMC_CTRL                     (volatile unsigned long *)0xc1109c2c
#define P_VPU_DI_DIWR_MMC_CTRL                     (volatile unsigned long *)0xc1109c30
#define P_VPU_VDIN_MMC_CTRL                        (volatile unsigned long *)0xc1109c34
#define P_VPU_DVIN_MMC_CTRL                        (volatile unsigned long *)0xc1109c38
#define P_VPU_BT656_MMC_CTRL                       (volatile unsigned long *)0xc1109c3c
//========================================================================
//  VLD Registers				    (12'hC00 - 12'hCff)
//
//========================================================================
// -----------------------------------------------
// CBUS_BASE:  VLD_CBUS_BASE = 0x0c
// -----------------------------------------------
#define P_VLD_STATUS_CTRL                          (volatile unsigned long *)0xc1103000
//
// bit 10 -- use_old_shift_en
// bit 9 -- output_mv_not_pmv
// bit 8:5 -- force_zigzag
// bit 4 -- force_zigzag_en
// bit 3 -- disable_viff_anempty_int
// bit 2 -- disable_m2_ac_coeff_one_cycle
// bit 1 -- forced_reset  force reset pmv
// bit 0 -- mpeg_type  0:mpeg1 1: mpeg2
#define P_MPEG1_2_REG                              (volatile unsigned long *)0xc1103004
#define P_F_CODE_REG                               (volatile unsigned long *)0xc1103008
#define P_PIC_HEAD_INFO                            (volatile unsigned long *)0xc110300c
#define P_SLICE_VER_POS_PIC_TYPE                   (volatile unsigned long *)0xc1103010
#define P_QP_VALUE_REG                             (volatile unsigned long *)0xc1103014
#define P_MBA_INC                                  (volatile unsigned long *)0xc1103018
#define P_MB_MOTION_MODE                           (volatile unsigned long *)0xc110301c
//`define PACKET_BYTE_COUNT   8'h08
// bit 15 -- force_search_startcode_en
// bit 14 -- int_cpu_when_error (before do anything)
// bit 13 -- vld_error_reset
// bit 12 -- return_on_slice_header
// bit 6 -- jpeg_ff00_en 
// bit 5:0 -- vld_power_ctl
#define P_POWER_CTL_VLD                            (volatile unsigned long *)0xc1103020
#define P_MB_WIDTH                                 (volatile unsigned long *)0xc1103024
#define P_SLICE_QP                                 (volatile unsigned long *)0xc1103028
// `define MB_X_MB_Y           8'h0b   /* current MBX and MBY                  */
#define P_PRE_START_CODE                           (volatile unsigned long *)0xc110302c
#define P_SLICE_START_BYTE_01                      (volatile unsigned long *)0xc1103030
#define P_SLICE_START_BYTE_23                      (volatile unsigned long *)0xc1103034
#define P_RESYNC_MARKER_LENGTH                     (volatile unsigned long *)0xc1103038
#define P_FST_FOR_MV_X                             (volatile unsigned long *)0xc1103040
#define P_FST_FOR_MV_Y                             (volatile unsigned long *)0xc1103044
#define P_SCD_FOR_MV_X                             (volatile unsigned long *)0xc1103048
#define P_SCD_FOR_MV_Y                             (volatile unsigned long *)0xc110304c
#define P_FST_BAK_MV_X                             (volatile unsigned long *)0xc1103050
#define P_FST_BAK_MV_Y                             (volatile unsigned long *)0xc1103054
#define P_SCD_BAK_MV_X                             (volatile unsigned long *)0xc1103058
#define P_SCD_BAK_MV_Y                             (volatile unsigned long *)0xc110305c
#define P_HALF_PEL_ONE                             (volatile unsigned long *)0xc1103060
#define P_HALF_PEL_TWO                             (volatile unsigned long *)0xc1103064
#define P_VIFF_BIT_CNT                             (volatile unsigned long *)0xc1103068
#define P_BYTE_ALIGN_PEAK_HI                       (volatile unsigned long *)0xc110306c
#define P_BYTE_ALIGN_PEAK_LO                       (volatile unsigned long *)0xc1103070
#define P_NEXT_ALIGN_PEAK                          (volatile unsigned long *)0xc1103074
// bit 6 : disable_dblk_hcmd
// bit 5 : disable_mc_hcmd
// bit 4 : first_mode3_set enable
// bit 3 : first_mode3
// bit 2:1 : vc1_profile  0-SP, 1-MP, 2-reserved, 3-AP
// bit 0   : vc1_enable
#define P_VC1_CONTROL_REG                          (volatile unsigned long *)0xc1103078
#define P_PMV1_X                                   (volatile unsigned long *)0xc1103080
#define P_PMV1_Y                                   (volatile unsigned long *)0xc1103084
#define P_PMV2_X                                   (volatile unsigned long *)0xc1103088
#define P_PMV2_Y                                   (volatile unsigned long *)0xc110308c
#define P_PMV3_X                                   (volatile unsigned long *)0xc1103090
#define P_PMV3_Y                                   (volatile unsigned long *)0xc1103094
#define P_PMV4_X                                   (volatile unsigned long *)0xc1103098
#define P_PMV4_Y                                   (volatile unsigned long *)0xc110309c
// Can't use the same address for different defines
// Therefore, create a single define that covers both
// Only appears to be used in micro-code since the VLD hardware is 
// hard coded.
// `define M4_TABLE_SELECT     8'h28  // Does this exist in HW ? Added from register_mp2.h
// `define M4_TABLE_OUTPUT     8'h28  // Does this exist in HW ? Added from register_mp2.h
#define P_M4_TABLE_SELECT                          (volatile unsigned long *)0xc11030a0
#define P_M4_CONTROL_REG                           (volatile unsigned long *)0xc11030a4
#define P_BLOCK_NUM                                (volatile unsigned long *)0xc11030a8
#define P_PATTERN_CODE                             (volatile unsigned long *)0xc11030ac
#define P_MB_INFO                                  (volatile unsigned long *)0xc11030b0
#define P_VLD_DC_PRED                              (volatile unsigned long *)0xc11030b4
#define P_VLD_ERROR_MASK                           (volatile unsigned long *)0xc11030b8
#define P_VLD_DC_PRED_C                            (volatile unsigned long *)0xc11030bc
#define P_LAST_SLICE_MV_ADDR                       (volatile unsigned long *)0xc11030c0
#define P_LAST_MVX                                 (volatile unsigned long *)0xc11030c4
#define P_LAST_MVY                                 (volatile unsigned long *)0xc11030c8
#define P_VLD_C38                                  (volatile unsigned long *)0xc11030e0
#define P_VLD_C39                                  (volatile unsigned long *)0xc11030e4
#define P_VLD_STATUS                               (volatile unsigned long *)0xc11030e8
#define P_VLD_SHIFT_STATUS                         (volatile unsigned long *)0xc11030ec
// `define VLD_SHIFT_INFO      8'h3b  // Does this exist in HW ? used in $ucode/mpeg4
#define P_VOFF_STATUS                              (volatile unsigned long *)0xc11030f0
#define P_VLD_C3D                                  (volatile unsigned long *)0xc11030f4
#define P_VLD_DBG_INDEX                            (volatile unsigned long *)0xc11030f8
// vld_buff_info -- (index == 0) 
// Bit[7:6]  mv_UR_ready_cnt;
// Bit[5]  vld_wr_idx
// Bit[4]  iq_rd_idx
// Bit[3]  vld_vi_block_rdy_1
// Bit[2]  vld_vi_block_rdy_2
// Bit[1]  voff_empty_1
// Bit[0]  voff_empty_2
// cabac_buff_info_0 -- (index == 1) 
// Bit[31] shift_data_ready
// Bit[30:29] Reserved
// Bit[28:24] cabac_buffer_ptr
// Bit[23:0] cabac_buffer
// cabac_buff_info_1 -- (index == 2) 
// Bit[31:29] Reserved
// Bit[28:20] Drange
// Bit[19:16] bin_count_4
// Bit[15:13] Reserved
// Bit[12:6] context_mem_do
// Bit[5:3] coeff_state
// Bit[2:0] mvd_state
// h264_mv_present -- (index == 3) 
// Bit[31:16] mv_present_l0
// Bit[15:0] mv_present_l1
// h264_mv_cal_info_0 -- (index == 4) 
// [31:28] mv_cal_state
// [27:24] direct_spatial_cnt
// Bit[23:21] Reserved
// Bit[20] mv_UR_ready_for_mv_cal
// Bit[19] co_mb_mem_ready_for_mv_cal
// Bit[18] mc_dblk_cmd_if_busy
// Bit[17] h264_co_mb_wr_busy
// Bit[16] H264_cbp_blk_ready
// Bit[15] mc_hcmd_rrdy
// Bit[14] mc_hcmd_srdy
// Bit[13] mc_cmd_if_ready
// Bit[12] mc_hcmd_mv_available
// Bit[11:8] mc_cmd_if_state
// Bit[7] dblk_hcmd_rrdy
// Bit[6] dblk_hcmd_srdy
// Bit[5] dblk_cmd_if_ready
// Bit[4] dblk_hcmd_mv_available
// Bit[3:0] dblk_cmd_if_state
// h264_mv_cal_info_1 -- (index == 5) 
//  Bit[31:29] Reserved
//  Bit[28:24] total_mvd_num_l0
//  Bit[23:21] Reserved
//  Bit[20:16] mv_cal_ptr_l0
//  Bit[15:13] Reserved
//  Bit[12:8] mc_hcmd_ptr_l0
//  Bit[7:5] Reserved
//  Bit[4:0] dblk_hcmd_ptr_l0
// h264_mv_cal_info_2 -- (index == 6) 
//  Bit[31:29] Reserved
//  Bit[28:24] total_mvd_num_l1
//  Bit[23:21] Reserved
//  Bit[20:16] mv_cal_ptr_l1
//  Bit[15:13] Reserved
//  Bit[12:8] mc_hcmd_ptr_l1
//  Bit[7:5] Reserved
//  Bit[4:0] dblk_hcmd_ptr_l1
// h264_co_mb_info -- (index == 7)
// Bit[31:26] Reserved
// Bit[25] mv_scale_cal_busy
// Bit[24:20] co_mv_count
// Bit[19:16] co_mv_process_state
// Bit[15] h264_co_mb_rd_busy
// Bit[15] h264_co_mb_rd_ready
// Bit[13:12] co_mv_transfer_block_cnt
// Bit[11:8] co_mv_transfer_ptr
// Bit[7] co_mv_POC_l1_busy
// Bit[6] h264_weight_scale_cal_en
// Bit[5] weight_cal_busy
// Bit[4] weight_cal_not_finished
// Bit[3:0] weight_process_state
#define P_VLD_DBG_DATA                             (volatile unsigned long *)0xc11030fc
// --------------------------------------------
// VIFIFO DDR Interface
// --------------------------------------------
// The VIFIFO start pointer into DDR memory is a 32-bit number
// The Start pointer will automatically be truncated to land on 
// an 8-byte boundary.  That is, bits [2:0] = 0;
#define P_VLD_MEM_VIFIFO_START_PTR                 (volatile unsigned long *)0xc1103100
// The current pointer points so some location between the START and END 
// pointers.  The current pointer is a BYTE pointer.  That is, you can 
// point to any BYTE address within the START/END range
#define P_VLD_MEM_VIFIFO_CURR_PTR                  (volatile unsigned long *)0xc1103104
#define P_VLD_MEM_VIFIFO_END_PTR                   (volatile unsigned long *)0xc1103108
#define P_VLD_MEM_VIFIFO_BYTES_AVAIL               (volatile unsigned long *)0xc110310c
// VIFIFO FIFO Control
// bit  [31:24] viff_empty_int_enable_cpu[7:0] 
// bit  [23:16] viff_empty_int_enable_amrisc[7:0] 
//   -bit 23 Video BUFFER < 0x400 Bytes
//   -bit 22 Video BUFFER < 0x200 Bytes
//   -bit 21 Video BUFFER < 0x100 Bytes
//   -bit 20 Video BUFFER < 0x80 Bytes
//   -bit 19 Video BUFFER < 0x40 Bytes
//   -bit 18 Video BUFFER < 0x20 Bytes
//   -bit 17 vififo  < 16 double words
//   -bit 16 vififo  < 8 double words
// bit  [15:13] unused
// bit  [12]    A_urgent
// bit  [11]    transfer_length 0 - 32x64 Bits per request, 1 - 16x64 Bits per request
// bit  [10]    use_level       Set this bit to 1 to enable filling of the FIFO controlled by the buffer
//                              level control.  If this bit is 0, then use bit[1] to control the enabling of filling
// bit  [9]     Data Ready.     This bit is set when data can be popped
// bit  [8]     fill busy       This bit will be high when we're fetching data from the DDR memory
//                              To reset this module, set cntl_enable = 0, and then wait for busy = 0. 
//                              After that you can pulse cntl_init to start over
// bit  [7]     unused
// bit  [6]     unused
// bits [5:3]   endian:         see $lib/rtl/ddr_endian.v
// bit  [2]     cntl_empty_en   Set to 1 to enable reading the DDR memory FIFO
//                              Set cntl_empty_en = cntl_fill_en = 0 when pulsing cntl_init
// bit  [1]     cntl_fill_en    Set to 1 to enable reading data from DDR memory
// bit  [0]     cntl_init:      After setting the read pointers, sizes, channel masks
//                              and read masks, set this bit to 1 and then to 0
//                              NOTE:  You don't need to pulse cntl_init if only the start address is
//                              being changed
#define P_VLD_MEM_VIFIFO_CONTROL                   (volatile unsigned long *)0xc1103110
// --------------------------------------------
// VIFIFO Buffer Level Manager
// --------------------------------------------
#define P_VLD_MEM_VIFIFO_WP                        (volatile unsigned long *)0xc1103114
#define P_VLD_MEM_VIFIFO_RP                        (volatile unsigned long *)0xc1103118
#define P_VLD_MEM_VIFIFO_LEVEL                     (volatile unsigned long *)0xc110311c
//
// bit  [1]     manual mode     Set to 1 for manual write pointer mode
// bit  [0]     Init            Set high then low after everything has been initialized
#define P_VLD_MEM_VIFIFO_BUF_CNTL                  (volatile unsigned long *)0xc1103120
// bit 31:16 -- drop_bytes
// bit 15:14 -- drop_status (Read-Only)
// bit 13:12 -- sync_match_position (Read-Only)
// bit 11:6 -- reserved
// bit 5:4 -- TIME_STAMP_NUMBER, 0-32bits, 1-64bits, 2-96bits, 3-128bits 
// bit 3 -- stamp_soft_reset
// bit 2 -- TIME_STAMP_length_enable
// bit 1 -- TIME_STAMP_sync64_enable
// bit 0 -- TIME_STAMP_enable
#define P_VLD_TIME_STAMP_CNTL                      (volatile unsigned long *)0xc1103124
// bit 31:0 -- TIME_STAMP_SYNC_CODE_0
#define P_VLD_TIME_STAMP_SYNC_0                    (volatile unsigned long *)0xc1103128
// bit 31:0 -- TIME_STAMP_SYNC_CODE_1 
#define P_VLD_TIME_STAMP_SYNC_1                    (volatile unsigned long *)0xc110312c
// bit 31:0 TIME_STAMP_0
#define P_VLD_TIME_STAMP_0                         (volatile unsigned long *)0xc1103130
// bit 31:0 TIME_STAMP_1
#define P_VLD_TIME_STAMP_1                         (volatile unsigned long *)0xc1103134
// bit 31:0 TIME_STAMP_2
#define P_VLD_TIME_STAMP_2                         (volatile unsigned long *)0xc1103138
// bit 31:0 TIME_STAMP_3
#define P_VLD_TIME_STAMP_3                         (volatile unsigned long *)0xc110313c
// bit 31:0 TIME_STAMP_LENGTH
#define P_VLD_TIME_STAMP_LENGTH                    (volatile unsigned long *)0xc1103140
// bit 15:0 vififo_rd_count
#define P_VLD_MEM_VIFIFO_WRAP_COUNT                (volatile unsigned long *)0xc1103144
// bit 29:24 A_brst_num
// bit 21:16 A_id
// bit 15:0 level_hold 
#define P_VLD_MEM_VIFIFO_MEM_CTL                   (volatile unsigned long *)0xc1103148
//========================================================================
//  IQ/IDCT Registers				    (12'he00 - 12'heff)
//
//========================================================================
// -----------------------------------------------
// CBUS_BASE:  IQIDCT_CBUS_BASE = 0x0e
// -----------------------------------------------
#define P_VCOP_CTRL_REG                            (volatile unsigned long *)0xc1103800
#define P_QP_CTRL_REG                              (volatile unsigned long *)0xc1103804
#define P_INTRA_QUANT_MATRIX                       (volatile unsigned long *)0xc1103808
#define P_NON_I_QUANT_MATRIX                       (volatile unsigned long *)0xc110380c
#define P_DC_SCALER                                (volatile unsigned long *)0xc1103810
#define P_DC_AC_CTRL                               (volatile unsigned long *)0xc1103814
// `define RV_AI_CTRL          8'h05  // ONLY for $ucode/real/amrisc/rv.s reg value from apollo
#define P_DC_AC_SCALE_MUL                          (volatile unsigned long *)0xc1103818
#define P_DC_AC_SCALE_DIV                          (volatile unsigned long *)0xc110381c
// `define DC_AC_SCALE_RESULT  8'h06
// `define RESERVED_E07        8'h07
#define P_POWER_CTL_IQIDCT                         (volatile unsigned long *)0xc1103820
#define P_RV_AI_Y_X                                (volatile unsigned long *)0xc1103824
#define P_RV_AI_U_X                                (volatile unsigned long *)0xc1103828
#define P_RV_AI_V_X                                (volatile unsigned long *)0xc110382c
// bit 15:0 will count up when rv_ai_mb finished when non zero
// and rv_ai_mb_finished_int will be generate when this is not zero
#define P_RV_AI_MB_COUNT                           (volatile unsigned long *)0xc1103830
// For H264 I in PB picture Use -- dma type : h264_next_intra_dma
#define P_NEXT_INTRA_DMA_ADDRESS                   (volatile unsigned long *)0xc1103834
// Bit 0 -- constrained_intra_pred_flag for H264
#define P_IQIDCT_CONTROL                           (volatile unsigned long *)0xc1103838
// Bit[31:19] Reserved
// Bit[18] iq_waiting
// Bit[17] iq_om_wr_idx
// Bit[16] iq_om_rd_idx
// Bit[15] iq_om_busy
// Bit[14] iq_om_2_busy 
// Bit[13] idx_fifo_0
// Bit[12] idx_fifo_1
// Bit[11] idx_fifo_2
// Bit[10] idx_fifo_3
// Bit[9] idx_fifo_4
// Bit[8] idx_fifo_5
// Bit[7] idx_fifo_6
// Bit[6] idx_fifo_7
// Bit[5:3] idx_fifo_wp
// Bit[2:0] idx_fifo_rp
#define P_IQIDCT_DEBUG_INFO_0                      (volatile unsigned long *)0xc110383c
// For RTL Simulation Only
#define P_DEBLK_CMD                                (volatile unsigned long *)0xc1103840
// Bit[15+16] ds_mc_valid_2
// Bit[14+16] new_idct1_rd_idx_2
// Bit[13+16] new_idct1_wr_idx_2
// Bit[12+16] idct1_buff0_busy_2
// Bit[11+16] idct1_buff1_busy_2
// Bit[10+16] new_idct1_busy_2
// Bit[9+16] iq_om_8val_2
// Bit[8+16] idct1_pipe_busy_2
// Bit[7+16] wait_mb_left_finish_hold_2
// Bit[6+16] new_idct2_rd_idx_2
// Bit[5+16] new_idct2_wr_idx_2
// Bit[4+16] idct2_buff0_busy_2
// Bit[3+16] idct2_buff1_busy_2
// Bit[2+16] idct2_en_2
// Bit[1+16] new_idct2_busy_2
// Bit[0+16] new_idct1_ready_2
// Bit[15] ds_mc_valid_1
// Bit[14] new_idct1_rd_idx_1
// Bit[13] new_idct1_wr_idx_1
// Bit[12] idct1_buff0_busy_1
// Bit[11] idct1_buff1_busy_1
// Bit[10] new_idct1_busy_1
// Bit[9] iq_om_8val_1
// Bit[8] idct1_pipe_busy_1
// Bit[7] wait_mb_left_finish_hold_1
// Bit[6] new_idct2_rd_idx_1
// Bit[5] new_idct2_wr_idx_1
// Bit[4] idct2_buff0_busy_1
// Bit[3] idct2_buff1_busy_1
// Bit[2] idct2_en_1
// Bit[1] new_idct2_busy_1
// Bit[0] new_idct1_ready_1
#define P_IQIDCT_DEBUG_IDCT                        (volatile unsigned long *)0xc1103844
// bit 31 -- convas_enable
// bit 30:24 -- convas_x_count ( 8 pixels / 64 bits )
// bit 23:16 -- convas_y_count
// bit 15   -- dcac_dma_busy
// bit 14   -- dcac_dma_urgent
// bit 13:8 -- dcac_dma_count
// bit 7    -- dcac_dma_rw
// bit 6    -- dcac_skip_read_mode
// bit 5:0  -- dcac_dma_offset
#define P_DCAC_DMA_CTRL                            (volatile unsigned long *)0xc1103848
// when (convas_enable == 0 )
//   bit 31:0 dcac_dma_addr
// when (convas_enable == 1 )
//   bit 31:25 canvas_addr (7 bits)
//   bit 24:12 convas_y_start ( 13 btis )
//   bit 11:0  convas_x_start ( 12 btis )
#define P_DCAC_DMA_ADDRESS                         (volatile unsigned long *)0xc110384c
// bit 7:0 -- dcac_cpu_addr
#define P_DCAC_CPU_ADDRESS                         (volatile unsigned long *)0xc1103850
// bit 31:0 -- dcac_cpu_data
#define P_DCAC_CPU_DATA                            (volatile unsigned long *)0xc1103854
// bit 31:19 -- reserved
// bit 18:16 -- block_num_reg -- Read-Only 
// bit 15:0 -- dcac_mb_count
#define P_DCAC_MB_COUNT                            (volatile unsigned long *)0xc1103858
// bit 31:18 -- reserved
// For H264 :
//   bit 17:2 -- h264_quant 
//   bit 11:6 -- h264_quant_c 
//   bit  5:0 -- h264_quant_c 
// For VC1 :
//   bit    17 -- qindex_GT_8
//   bit    16 -- HalfQPStep
//   bit 15:12 -- eQuantMode 
//   bit 11:6  -- AltPQuant 
//   bit  5:0  -- PQuant 
//             
#define P_IQ_QUANT                                 (volatile unsigned long *)0xc110385c
// bit 31:24  -- bitplane_width 
// bit 23:16  -- bitplane_height 
// bit 15:14  -- bitplane_start_x 
// bit 13:12  -- bitplane_start_y 
// bit 11:4   -- reserved
// bit 3:1    -- bitplane_type
// bit 0      -- bitplane_busy
#define P_VC1_BITPLANE_CTL                         (volatile unsigned long *)0xc1103860
    #define RAM_TEST_CMD        0x002
    #define RAM_TEST_ADDR       0x003
    #define RAM_TEST_DATAH      0x004
    #define RAM_TEST_DATAL      0x005

    #define RAM_TEST_RD_CMD	    0x0000
    #define RAM_TEST_WR_CMD	    0x8000
    #define IDCT_TM2_PT0	    0x0001
    #define IDCT_TM2_PT1	    0x0002
    #define IDCT_TM1_PT0	    0x0004
    #define IDCT_TM1_PT1	    0x0008
    #define IQ_OMEM_PT0	        0x0010
    #define IQ_OMEM_PT1	        0x0020
    #define MC_IMEM_PT0	        0x0040
    #define ALL_RAM_PTS	        0x007f
//======================================
//  VCOP Control Register Bits
//
//======================================
    //#define IQIDCT_RESET	    0x0001	    // Bit 0
    #define QM_WEN		    0x0002	    // Bit 1
    #define IQIDCT_ENABLE	    0x0004	    // Bit 2
    #define INTRA_QM	    0x0008	    // Bit 3	0 = Use default; 1 = use loaded
    #define NINTRA_QM	    0x0010	    // Bit 4	0 = Use default; 1 = use loaded
//======================================
//  QP Control Register Bits
//
//======================================
    #define INTRA_MODE	    0x0080	    // Bit 7
// Duplicate Address:  When actually used
// please move to a different address
// `define FLD_DCT_TYPE	    16'h0100	    // Bit 8	0 = Frame DCT; 1 = field DCT
//========================================================================
//  DSP Co-Processor Registers			    ( 8'he00 - 12'hfff)
//
//========================================================================
// Duplicate Address:  When actually used
// please move to a different address
// `define AUDIO_COP_CTL1      12'hf00  // r & w; r-> 6'h00,bsmod[2:0],acmod[2:0],lfeon,nfchans[2:0]
#define P_AUDIO_COP_CTL2                           (volatile unsigned long *)0xc1103c04
//  f02 -f0d are special regs , not in ac3_reg.h, but used by CPU for AC3 operations
#define P_OPERAND_M_CTL                            (volatile unsigned long *)0xc1103c08
#define P_OPERAND1_ADDR                            (volatile unsigned long *)0xc1103c0c
#define P_OPERAND2_ADDR                            (volatile unsigned long *)0xc1103c10
#define P_RESULT_M_CTL                             (volatile unsigned long *)0xc1103c14
#define P_RESULT1_ADDR                             (volatile unsigned long *)0xc1103c18
#define P_RESULT2_ADDR                             (volatile unsigned long *)0xc1103c1c
#define P_ADD_SHFT_CTL                             (volatile unsigned long *)0xc1103c20
#define P_OPERAND_ONE_H                            (volatile unsigned long *)0xc1103c24
#define P_OPERAND_ONE_L                            (volatile unsigned long *)0xc1103c28
#define P_OPERAND_TWO_H                            (volatile unsigned long *)0xc1103c2c
#define P_OPERAND_TWO_L                            (volatile unsigned long *)0xc1103c30
#define P_RESULT_H                                 (volatile unsigned long *)0xc1103c34
#define P_RESULT_M                                 (volatile unsigned long *)0xc1103c38
// special reg 
#define P_RESULT_L                                 (volatile unsigned long *)0xc1103c3c
// 
#define P_WMEM_R_PTR                               (volatile unsigned long *)0xc1103c40
#define P_WMEM_W_PTR                               (volatile unsigned long *)0xc1103c44
#define P_AUDIO_LAYER                              (volatile unsigned long *)0xc1103c80
#define P_AC3_DECODING                             (volatile unsigned long *)0xc1103c84
#define P_AC3_DYNAMIC                              (volatile unsigned long *)0xc1103c88
#define P_AC3_MELODY                               (volatile unsigned long *)0xc1103c8c
#define P_AC3_VOCAL                                (volatile unsigned long *)0xc1103c90
//======================================
//  CPU Assist module
//
//======================================
// -----------------------------------------------
// CBUS_BASE:  ASSIST_CBUS_BASE = 0x1f
// -----------------------------------------------
#define P_ASSIST_AMR1_INT0                         (volatile unsigned long *)0xc1107c94
#define P_ASSIST_AMR1_INT1                         (volatile unsigned long *)0xc1107c98
#define P_ASSIST_AMR1_INT2                         (volatile unsigned long *)0xc1107c9c
#define P_ASSIST_AMR1_INT3                         (volatile unsigned long *)0xc1107ca0
#define P_ASSIST_AMR1_INT4                         (volatile unsigned long *)0xc1107ca4
#define P_ASSIST_AMR1_INT5                         (volatile unsigned long *)0xc1107ca8
#define P_ASSIST_AMR1_INT6                         (volatile unsigned long *)0xc1107cac
#define P_ASSIST_AMR1_INT7                         (volatile unsigned long *)0xc1107cb0
#define P_ASSIST_AMR1_INT8                         (volatile unsigned long *)0xc1107cb4
#define P_ASSIST_AMR1_INT9                         (volatile unsigned long *)0xc1107cb8
#define P_ASSIST_AMR1_INTA                         (volatile unsigned long *)0xc1107cbc
#define P_ASSIST_AMR1_INTB                         (volatile unsigned long *)0xc1107cc0
#define P_ASSIST_AMR1_INTC                         (volatile unsigned long *)0xc1107cc4
#define P_ASSIST_AMR1_INTD                         (volatile unsigned long *)0xc1107cc8
#define P_ASSIST_AMR1_INTE                         (volatile unsigned long *)0xc1107ccc
#define P_ASSIST_AMR1_INTF                         (volatile unsigned long *)0xc1107cd0
#define P_ASSIST_AMR2_INT0                         (volatile unsigned long *)0xc1107cd4
#define P_ASSIST_AMR2_INT1                         (volatile unsigned long *)0xc1107cd8
#define P_ASSIST_AMR2_INT2                         (volatile unsigned long *)0xc1107cdc
#define P_ASSIST_AMR2_INT3                         (volatile unsigned long *)0xc1107ce0
#define P_ASSIST_AMR2_INT4                         (volatile unsigned long *)0xc1107ce4
#define P_ASSIST_AMR2_INT5                         (volatile unsigned long *)0xc1107ce8
#define P_ASSIST_AMR2_INT6                         (volatile unsigned long *)0xc1107cec
#define P_ASSIST_AMR2_INT7                         (volatile unsigned long *)0xc1107cf0
#define P_ASSIST_AMR2_INT8                         (volatile unsigned long *)0xc1107cf4
#define P_ASSIST_AMR2_INT9                         (volatile unsigned long *)0xc1107cf8
#define P_ASSIST_AMR2_INTA                         (volatile unsigned long *)0xc1107cfc
#define P_ASSIST_AMR2_INTB                         (volatile unsigned long *)0xc1107d00
#define P_ASSIST_AMR2_INTC                         (volatile unsigned long *)0xc1107d04
#define P_ASSIST_AMR2_INTD                         (volatile unsigned long *)0xc1107d08
#define P_ASSIST_AMR2_INTE                         (volatile unsigned long *)0xc1107d0c
#define P_ASSIST_AMR2_INTF                         (volatile unsigned long *)0xc1107d10
#define P_ASSIST_AMR_MBOX1_INT                     (volatile unsigned long *)0xc1107d34
#define P_ASSIST_AMR_MBOX2_INT                     (volatile unsigned long *)0xc1107d38
#define P_ASSIST_AMR_SCRATCH0                      (volatile unsigned long *)0xc1107d3c
#define P_ASSIST_AMR_SCRATCH1                      (volatile unsigned long *)0xc1107d40
#define P_ASSIST_AMR_SCRATCH2                      (volatile unsigned long *)0xc1107d44
#define P_ASSIST_AMR_SCRATCH3                      (volatile unsigned long *)0xc1107d48
#define P_ASSIST_HW_REV                            (volatile unsigned long *)0xc1107d4c
#define P_ASSIST_CBUS_ARB                          (volatile unsigned long *)0xc1107d50
#define P_ASSIST_POR_CONFIG                        (volatile unsigned long *)0xc1107d54
#define P_ASSIST_SPARE16_REG1                      (volatile unsigned long *)0xc1107d58
#define P_ASSIST_SPARE16_REG2                      (volatile unsigned long *)0xc1107d5c
#define P_ASSIST_SPARE8_REG1                       (volatile unsigned long *)0xc1107d60
#define P_ASSIST_SPARE8_REG2                       (volatile unsigned long *)0xc1107d64
// Duplicate Address...when used please move to a new address
// `define TO_AMRISC_REG                 8'h59 // for amrisc
#define P_ASSIST_SPARE8_REG3                       (volatile unsigned long *)0xc1107d68
// Duplicate Address...when used please move to a new address
// `define FROM_AMRISC_REG               8'h5a // for amrisc
// Duplicate Address...when used please move to a new address
// `define MPEG2_DECODER_CONTROL         8'h5b // for amrisc
#define P_AC3_CTRL_REG1                            (volatile unsigned long *)0xc1107d6c
#define P_AC3_CTRL_REG2                            (volatile unsigned long *)0xc1107d70
#define P_AC3_CTRL_REG3                            (volatile unsigned long *)0xc1107d74
#define P_AC3_CTRL_REG4                            (volatile unsigned long *)0xc1107d78
#define P_ASSIST_PMEM_SPLIT                        (volatile unsigned long *)0xc1107d7c
#define P_TIMER0_LO                                (volatile unsigned long *)0xc1107d80
#define P_TIMER0_HI                                (volatile unsigned long *)0xc1107d84
#define P_TIMER1_LO                                (volatile unsigned long *)0xc1107d88
#define P_TIMER1_HI                                (volatile unsigned long *)0xc1107d8c
#define P_DMA_INT                                  (volatile unsigned long *)0xc1107d90
#define P_DMA_INT_MSK                              (volatile unsigned long *)0xc1107d94
#define P_DMA_INT2                                 (volatile unsigned long *)0xc1107d98
#define P_DMA_INT_MSK2                             (volatile unsigned long *)0xc1107d9c
#define P_ASSIST_MBOX0_IRQ_REG                     (volatile unsigned long *)0xc1107dc0
#define P_ASSIST_MBOX0_CLR_REG                     (volatile unsigned long *)0xc1107dc4
#define P_ASSIST_MBOX0_MASK                        (volatile unsigned long *)0xc1107dc8
#define P_ASSIST_MBOX0_FIQ_SEL                     (volatile unsigned long *)0xc1107dcc
#define P_ASSIST_MBOX1_IRQ_REG                     (volatile unsigned long *)0xc1107dd0
#define P_ASSIST_MBOX1_CLR_REG                     (volatile unsigned long *)0xc1107dd4
#define P_ASSIST_MBOX1_MASK                        (volatile unsigned long *)0xc1107dd8
#define P_ASSIST_MBOX1_FIQ_SEL                     (volatile unsigned long *)0xc1107ddc
#define P_ASSIST_MBOX2_IRQ_REG                     (volatile unsigned long *)0xc1107de0
#define P_ASSIST_MBOX2_CLR_REG                     (volatile unsigned long *)0xc1107de4
#define P_ASSIST_MBOX2_MASK                        (volatile unsigned long *)0xc1107de8
#define P_ASSIST_MBOX2_FIQ_SEL                     (volatile unsigned long *)0xc1107dec
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./register_map.h
//

#endif // C_ARC_POINTER_H

